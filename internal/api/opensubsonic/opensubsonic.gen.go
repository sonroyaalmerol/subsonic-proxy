//go:build go1.22

// Package opensubsonic provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package opensubsonic

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

const (
	ApiKeyAuthScopes      = "apiKeyAuth.Scopes"
	ClientNameScopes      = "clientName.Scopes"
	FormatScopes          = "format.Scopes"
	LegacyPasswordScopes  = "legacyPassword.Scopes"
	ProtocolVersionScopes = "protocolVersion.Scopes"
	SaltScopes            = "salt.Scopes"
	TokenScopes           = "token.Scopes"
	UsernameScopes        = "username.Scopes"
)

// Defines values for AlbumListType.
const (
	AlbumListTypeAlphabeticalByArtist AlbumListType = "alphabeticalByArtist"
	AlbumListTypeAlphabeticalByName   AlbumListType = "alphabeticalByName"
	AlbumListTypeByGenre              AlbumListType = "byGenre"
	AlbumListTypeByYear               AlbumListType = "byYear"
	AlbumListTypeFrequent             AlbumListType = "frequent"
	AlbumListTypeHighest              AlbumListType = "highest"
	AlbumListTypeNewest               AlbumListType = "newest"
	AlbumListTypeRandom               AlbumListType = "random"
	AlbumListTypeRecent               AlbumListType = "recent"
	AlbumListTypeStarred              AlbumListType = "starred"
)

// Defines values for CodecProfileType.
const (
	AudioCodec CodecProfileType = "AudioCodec"
)

// Defines values for CreatePlaylistSuccessResponseStatus.
const (
	CreatePlaylistSuccessResponseStatusOk CreatePlaylistSuccessResponseStatus = "ok"
)

// Defines values for CreateSharesSuccessResponseStatus.
const (
	CreateSharesSuccessResponseStatusOk CreateSharesSuccessResponseStatus = "ok"
)

// Defines values for DirectPlayProfileProtocols.
const (
	DirectPlayProfileProtocolsHls  DirectPlayProfileProtocols = "hls"
	DirectPlayProfileProtocolsHttp DirectPlayProfileProtocols = "http"
)

// Defines values for ErrorCode.
const (
	ErrorCodeN0  ErrorCode = 0
	ErrorCodeN10 ErrorCode = 10
	ErrorCodeN20 ErrorCode = 20
	ErrorCodeN30 ErrorCode = 30
	ErrorCodeN40 ErrorCode = 40
	ErrorCodeN41 ErrorCode = 41
	ErrorCodeN42 ErrorCode = 42
	ErrorCodeN43 ErrorCode = 43
	ErrorCodeN44 ErrorCode = 44
	ErrorCodeN50 ErrorCode = 50
	ErrorCodeN60 ErrorCode = 60
	ErrorCodeN70 ErrorCode = 70
)

// Defines values for ExplicitStatus.
const (
	Clean    ExplicitStatus = "clean"
	Empty    ExplicitStatus = ""
	Explicit ExplicitStatus = "explicit"
)

// Defines values for GenericMediaType.
const (
	GenericMediaTypeAudiobook GenericMediaType = "audiobook"
	GenericMediaTypeMusic     GenericMediaType = "music"
	GenericMediaTypePodcast   GenericMediaType = "podcast"
	GenericMediaTypeVideo     GenericMediaType = "video"
)

// Defines values for GetAlbumInfoSuccessResponseStatus.
const (
	GetAlbumInfoSuccessResponseStatusOk GetAlbumInfoSuccessResponseStatus = "ok"
)

// Defines values for GetAlbumList2SuccessResponseStatus.
const (
	GetAlbumList2SuccessResponseStatusOk GetAlbumList2SuccessResponseStatus = "ok"
)

// Defines values for GetAlbumListSuccessResponseStatus.
const (
	GetAlbumListSuccessResponseStatusOk GetAlbumListSuccessResponseStatus = "ok"
)

// Defines values for GetAlbumSuccessResponseStatus.
const (
	GetAlbumSuccessResponseStatusOk GetAlbumSuccessResponseStatus = "ok"
)

// Defines values for GetArtistInfo2SuccessResponseStatus.
const (
	GetArtistInfo2SuccessResponseStatusOk GetArtistInfo2SuccessResponseStatus = "ok"
)

// Defines values for GetArtistInfoSuccessResponseStatus.
const (
	GetArtistInfoSuccessResponseStatusOk GetArtistInfoSuccessResponseStatus = "ok"
)

// Defines values for GetArtistSuccessResponseStatus.
const (
	GetArtistSuccessResponseStatusOk GetArtistSuccessResponseStatus = "ok"
)

// Defines values for GetArtistsSuccessResponseStatus.
const (
	GetArtistsSuccessResponseStatusOk GetArtistsSuccessResponseStatus = "ok"
)

// Defines values for GetBookmarksSuccessResponseStatus.
const (
	GetBookmarksSuccessResponseStatusOk GetBookmarksSuccessResponseStatus = "ok"
)

// Defines values for GetChatMessagesSuccessResponseStatus.
const (
	GetChatMessagesSuccessResponseStatusOk GetChatMessagesSuccessResponseStatus = "ok"
)

// Defines values for GetGenresSuccessResponseStatus.
const (
	GetGenresSuccessResponseStatusOk GetGenresSuccessResponseStatus = "ok"
)

// Defines values for GetIndexesSuccessResponseStatus.
const (
	GetIndexesSuccessResponseStatusOk GetIndexesSuccessResponseStatus = "ok"
)

// Defines values for GetInternetRadioStationsSuccessResponseStatus.
const (
	GetInternetRadioStationsSuccessResponseStatusOk GetInternetRadioStationsSuccessResponseStatus = "ok"
)

// Defines values for GetLicenseSuccessResponseStatus.
const (
	GetLicenseSuccessResponseStatusOk GetLicenseSuccessResponseStatus = "ok"
)

// Defines values for GetLyricsBySongIdSuccessResponseStatus.
const (
	GetLyricsBySongIdSuccessResponseStatusOk GetLyricsBySongIdSuccessResponseStatus = "ok"
)

// Defines values for GetLyricsSuccessResponseStatus.
const (
	GetLyricsSuccessResponseStatusOk GetLyricsSuccessResponseStatus = "ok"
)

// Defines values for GetMusicDirectorySuccessResponseStatus.
const (
	GetMusicDirectorySuccessResponseStatusOk GetMusicDirectorySuccessResponseStatus = "ok"
)

// Defines values for GetMusicFoldersSuccessResponseStatus.
const (
	GetMusicFoldersSuccessResponseStatusOk GetMusicFoldersSuccessResponseStatus = "ok"
)

// Defines values for GetNewestPodcastsSuccessResponseStatus.
const (
	GetNewestPodcastsSuccessResponseStatusOk GetNewestPodcastsSuccessResponseStatus = "ok"
)

// Defines values for GetNowPlayingSuccessResponseStatus.
const (
	GetNowPlayingSuccessResponseStatusOk GetNowPlayingSuccessResponseStatus = "ok"
)

// Defines values for GetOpenSubsonicExtensionsSuccessResponseStatus.
const (
	GetOpenSubsonicExtensionsSuccessResponseStatusOk GetOpenSubsonicExtensionsSuccessResponseStatus = "ok"
)

// Defines values for GetPlayQueueByIndexSuccessResponseStatus.
const (
	GetPlayQueueByIndexSuccessResponseStatusOk GetPlayQueueByIndexSuccessResponseStatus = "ok"
)

// Defines values for GetPlayQueueSuccessResponseStatus.
const (
	GetPlayQueueSuccessResponseStatusOk GetPlayQueueSuccessResponseStatus = "ok"
)

// Defines values for GetPlaylistSuccessResponseStatus.
const (
	GetPlaylistSuccessResponseStatusOk GetPlaylistSuccessResponseStatus = "ok"
)

// Defines values for GetPlaylistsSuccessResponseStatus.
const (
	GetPlaylistsSuccessResponseStatusOk GetPlaylistsSuccessResponseStatus = "ok"
)

// Defines values for GetPodcastEpisodeSuccessResponseStatus.
const (
	GetPodcastEpisodeSuccessResponseStatusOk GetPodcastEpisodeSuccessResponseStatus = "ok"
)

// Defines values for GetPodcastsSuccessResponseStatus.
const (
	GetPodcastsSuccessResponseStatusOk GetPodcastsSuccessResponseStatus = "ok"
)

// Defines values for GetRandomSongsSuccessResponseStatus.
const (
	GetRandomSongsSuccessResponseStatusOk GetRandomSongsSuccessResponseStatus = "ok"
)

// Defines values for GetScanStatusSuccessResponseStatus.
const (
	GetScanStatusSuccessResponseStatusOk GetScanStatusSuccessResponseStatus = "ok"
)

// Defines values for GetSharesSuccessResponseStatus.
const (
	GetSharesSuccessResponseStatusOk GetSharesSuccessResponseStatus = "ok"
)

// Defines values for GetSimilarSongs2SuccessResponseStatus.
const (
	GetSimilarSongs2SuccessResponseStatusOk GetSimilarSongs2SuccessResponseStatus = "ok"
)

// Defines values for GetSimilarSongsSuccessResponseStatus.
const (
	GetSimilarSongsSuccessResponseStatusOk GetSimilarSongsSuccessResponseStatus = "ok"
)

// Defines values for GetSongSuccessResponseStatus.
const (
	GetSongSuccessResponseStatusOk GetSongSuccessResponseStatus = "ok"
)

// Defines values for GetSongsByGenreSuccessResponseStatus.
const (
	GetSongsByGenreSuccessResponseStatusOk GetSongsByGenreSuccessResponseStatus = "ok"
)

// Defines values for GetStarred2SuccessResponseStatus.
const (
	GetStarred2SuccessResponseStatusOk GetStarred2SuccessResponseStatus = "ok"
)

// Defines values for GetStarredSuccessResponseStatus.
const (
	GetStarredSuccessResponseStatusOk GetStarredSuccessResponseStatus = "ok"
)

// Defines values for GetTokenInfoSuccessResponseStatus.
const (
	GetTokenInfoSuccessResponseStatusOk GetTokenInfoSuccessResponseStatus = "ok"
)

// Defines values for GetTopSongsSuccessResponseStatus.
const (
	GetTopSongsSuccessResponseStatusOk GetTopSongsSuccessResponseStatus = "ok"
)

// Defines values for GetUserSuccessResponseStatus.
const (
	GetUserSuccessResponseStatusOk GetUserSuccessResponseStatus = "ok"
)

// Defines values for GetUsersSuccessResponseStatus.
const (
	GetUsersSuccessResponseStatusOk GetUsersSuccessResponseStatus = "ok"
)

// Defines values for GetVideoInfoSuccessResponseStatus.
const (
	GetVideoInfoSuccessResponseStatusOk GetVideoInfoSuccessResponseStatus = "ok"
)

// Defines values for GetVideosSuccessResponseStatus.
const (
	GetVideosSuccessResponseStatusOk GetVideosSuccessResponseStatus = "ok"
)

// Defines values for JukeboxAction.
const (
	Add     JukeboxAction = "add"
	Clear   JukeboxAction = "clear"
	Get     JukeboxAction = "get"
	Remove  JukeboxAction = "remove"
	Set     JukeboxAction = "set"
	SetGain JukeboxAction = "setGain"
	Shuffle JukeboxAction = "shuffle"
	Skip    JukeboxAction = "skip"
	Start   JukeboxAction = "start"
	Status  JukeboxAction = "status"
	Stop    JukeboxAction = "stop"
)

// Defines values for JukeboxControlSuccessResponseStatus.
const (
	JukeboxControlSuccessResponseStatusOk JukeboxControlSuccessResponseStatus = "ok"
)

// Defines values for LimitationComparison.
const (
	Equals           LimitationComparison = "Equals"
	GreaterThanEqual LimitationComparison = "GreaterThanEqual"
	LessThanEqual    LimitationComparison = "LessThanEqual"
	NotEquals        LimitationComparison = "NotEquals"
)

// Defines values for LimitationName.
const (
	AudioBitdepth   LimitationName = "audioBitdepth"
	AudioBitrate    LimitationName = "audioBitrate"
	AudioChannels   LimitationName = "audioChannels"
	AudioProfile    LimitationName = "audioProfile"
	AudioSamplerate LimitationName = "audioSamplerate"
)

// Defines values for MediaType.
const (
	MediaTypeAlbum  MediaType = "album"
	MediaTypeArtist MediaType = "artist"
	MediaTypeSong   MediaType = "song"
)

// Defines values for PodcastStatus.
const (
	PodcastStatusCompleted   PodcastStatus = "completed"
	PodcastStatusDeleted     PodcastStatus = "deleted"
	PodcastStatusDownloading PodcastStatus = "downloading"
	PodcastStatusError       PodcastStatus = "error"
	PodcastStatusNew         PodcastStatus = "new"
	PodcastStatusSkipped     PodcastStatus = "skipped"
)

// Defines values for Search2SuccessResponseStatus.
const (
	Search2SuccessResponseStatusOk Search2SuccessResponseStatus = "ok"
)

// Defines values for Search3SuccessResponseStatus.
const (
	Search3SuccessResponseStatusOk Search3SuccessResponseStatus = "ok"
)

// Defines values for SearchSuccessResponseStatus.
const (
	SearchSuccessResponseStatusOk SearchSuccessResponseStatus = "ok"
)

// Defines values for StartScanSuccessResponseStatus.
const (
	StartScanSuccessResponseStatusOk StartScanSuccessResponseStatus = "ok"
)

// Defines values for StreamDetailsProtocol.
const (
	StreamDetailsProtocolHls  StreamDetailsProtocol = "hls"
	StreamDetailsProtocolHttp StreamDetailsProtocol = "http"
)

// Defines values for SubsonicFailureResponseStatus.
const (
	Failed SubsonicFailureResponseStatus = "failed"
)

// Defines values for SubsonicSuccessResponseStatus.
const (
	SubsonicSuccessResponseStatusOk SubsonicSuccessResponseStatus = "ok"
)

// Defines values for TranscodingProfileProtocol.
const (
	Hls  TranscodingProfileProtocol = "hls"
	Http TranscodingProfileProtocol = "http"
)

// Defines values for GetCaptionsParamsFormat.
const (
	GetCaptionsParamsFormatSrt GetCaptionsParamsFormat = "srt"
	GetCaptionsParamsFormatVtt GetCaptionsParamsFormat = "vtt"
)

// Defines values for PostGetCaptionsFormdataBodyFormat.
const (
	PostGetCaptionsFormdataBodyFormatSrt PostGetCaptionsFormdataBodyFormat = "srt"
	PostGetCaptionsFormdataBodyFormatVtt PostGetCaptionsFormdataBodyFormat = "vtt"
)

// Defines values for GetTranscodeDecisionParamsMediaType.
const (
	GetTranscodeDecisionParamsMediaTypePodcast GetTranscodeDecisionParamsMediaType = "podcast"
	GetTranscodeDecisionParamsMediaTypeSong    GetTranscodeDecisionParamsMediaType = "song"
)

// Defines values for GetTranscodeStreamParamsMediaType.
const (
	GetTranscodeStreamParamsMediaTypePodcast GetTranscodeStreamParamsMediaType = "podcast"
	GetTranscodeStreamParamsMediaTypeSong    GetTranscodeStreamParamsMediaType = "song"
)

// Defines values for UpdateUserParamsMaxBitRate.
const (
	UpdateUserParamsMaxBitRateN0   UpdateUserParamsMaxBitRate = 0
	UpdateUserParamsMaxBitRateN112 UpdateUserParamsMaxBitRate = 112
	UpdateUserParamsMaxBitRateN128 UpdateUserParamsMaxBitRate = 128
	UpdateUserParamsMaxBitRateN160 UpdateUserParamsMaxBitRate = 160
	UpdateUserParamsMaxBitRateN192 UpdateUserParamsMaxBitRate = 192
	UpdateUserParamsMaxBitRateN224 UpdateUserParamsMaxBitRate = 224
	UpdateUserParamsMaxBitRateN256 UpdateUserParamsMaxBitRate = 256
	UpdateUserParamsMaxBitRateN32  UpdateUserParamsMaxBitRate = 32
	UpdateUserParamsMaxBitRateN320 UpdateUserParamsMaxBitRate = 320
	UpdateUserParamsMaxBitRateN40  UpdateUserParamsMaxBitRate = 40
	UpdateUserParamsMaxBitRateN48  UpdateUserParamsMaxBitRate = 48
	UpdateUserParamsMaxBitRateN56  UpdateUserParamsMaxBitRate = 56
	UpdateUserParamsMaxBitRateN64  UpdateUserParamsMaxBitRate = 64
	UpdateUserParamsMaxBitRateN80  UpdateUserParamsMaxBitRate = 80
	UpdateUserParamsMaxBitRateN96  UpdateUserParamsMaxBitRate = 96
)

// Defines values for PostUpdateUserFormdataBodyMaxBitRate.
const (
	N0   PostUpdateUserFormdataBodyMaxBitRate = 0
	N112 PostUpdateUserFormdataBodyMaxBitRate = 112
	N128 PostUpdateUserFormdataBodyMaxBitRate = 128
	N160 PostUpdateUserFormdataBodyMaxBitRate = 160
	N192 PostUpdateUserFormdataBodyMaxBitRate = 192
	N224 PostUpdateUserFormdataBodyMaxBitRate = 224
	N256 PostUpdateUserFormdataBodyMaxBitRate = 256
	N32  PostUpdateUserFormdataBodyMaxBitRate = 32
	N320 PostUpdateUserFormdataBodyMaxBitRate = 320
	N40  PostUpdateUserFormdataBodyMaxBitRate = 40
	N48  PostUpdateUserFormdataBodyMaxBitRate = 48
	N56  PostUpdateUserFormdataBodyMaxBitRate = 56
	N64  PostUpdateUserFormdataBodyMaxBitRate = 64
	N80  PostUpdateUserFormdataBodyMaxBitRate = 80
	N96  PostUpdateUserFormdataBodyMaxBitRate = 96
)

// AlbumID3 Album with songs.
type AlbumID3 struct {
	// Artist Artist name.
	Artist *string `json:"artist,omitempty"`

	// ArtistId The id of the artist
	ArtistId *string `json:"artistId,omitempty"`

	// Artists The list of all album artists of the album.
	Artists *[]ArtistID3 `json:"artists,omitempty"`

	// CoverArt A covertArt id.
	CoverArt *string `json:"coverArt,omitempty"`

	// Created Date the album was added. [ISO 8601]
	Created time.Time `json:"created"`

	// DiscTitles The list of all disc titles of the album.
	DiscTitles *[]DiscTitle `json:"discTitles,omitempty"`

	// DisplayArtist The single value display artist.
	DisplayArtist *string `json:"displayArtist,omitempty"`

	// Duration Total duration of the album in seconds
	Duration int `json:"duration"`

	// ExplicitStatus Returns “explicit”, “clean” or “”. (For songs extracted from tags “ITUNESADVISORY”: 1 = explicit, 2 = clean, MP4 “rtng”: 1 or 4 = explicit, 2 = clean. See `albumID3` for albums)
	ExplicitStatus *ExplicitStatus `json:"explicitStatus,omitempty"`

	// Genre The album genre
	Genre *string `json:"genre,omitempty"`

	// Genres The list of all genres of the album.
	Genres *[]ItemGenre `json:"genres,omitempty"`

	// Id The id of the album
	Id string `json:"id"`

	// IsCompilation True if the album is a compilation.
	IsCompilation *bool `json:"isCompilation,omitempty"`

	// Moods The list of all moods of the album.
	Moods *[]string `json:"moods,omitempty"`

	// MusicBrainzId The album MusicBrainzID.
	MusicBrainzId *string `json:"musicBrainzId,omitempty"`

	// Name The album name.
	Name string `json:"name"`

	// OriginalReleaseDate Date the album was originally released.
	OriginalReleaseDate *ItemDate `json:"originalReleaseDate,omitempty"`

	// PlayCount Number of play of the album
	PlayCount *int `json:"playCount,omitempty"`

	// Played Date the album was last played. [ISO 8601]
	Played *time.Time `json:"played,omitempty"`

	// RecordLabels The labels producing the album.
	RecordLabels *[]RecordLabel `json:"recordLabels,omitempty"`

	// ReleaseDate Date the specific edition of the album was released. Note: for files using ID3 tags, releaseDate should generally be read from the TDRL tag. Servers that use a different source for this field should document the behavior.
	ReleaseDate *ItemDate `json:"releaseDate,omitempty"`

	// ReleaseTypes The types of this album release. (Album, Compilation, EP, Remix, …).
	ReleaseTypes *[]string `json:"releaseTypes,omitempty"`

	// Song The list of songs
	Song *[]Child `json:"song,omitempty"`

	// SongCount Number of songs
	SongCount int `json:"songCount"`

	// SortName The album sort name.
	SortName *string `json:"sortName,omitempty"`

	// Starred Date the album was added. [ISO 8601]
	Starred *time.Time `json:"starred,omitempty"`

	// UserRating The user rating of the album. [1-5]
	UserRating *int `json:"userRating,omitempty"`

	// Version The album version name (Remastered, Anniversary Box Set, …).
	Version *string `json:"version,omitempty"`

	// Year The album year
	Year *int `json:"year,omitempty"`
}

// AlbumID3WithSongs defines model for AlbumID3WithSongs.
type AlbumID3WithSongs struct {
	// Artist Artist name.
	Artist *string `json:"artist,omitempty"`

	// ArtistId The id of the artist
	ArtistId *string `json:"artistId,omitempty"`

	// Artists The list of all album artists of the album.
	Artists *[]ArtistID3 `json:"artists,omitempty"`

	// CoverArt A covertArt id.
	CoverArt *string `json:"coverArt,omitempty"`

	// Created Date the album was added. [ISO 8601]
	Created time.Time `json:"created"`

	// DiscTitles The list of all disc titles of the album.
	DiscTitles *[]DiscTitle `json:"discTitles,omitempty"`

	// DisplayArtist The single value display artist.
	DisplayArtist *string `json:"displayArtist,omitempty"`

	// Duration Total duration of the album in seconds
	Duration int `json:"duration"`

	// ExplicitStatus Returns “explicit”, “clean” or “”. (For songs extracted from tags “ITUNESADVISORY”: 1 = explicit, 2 = clean, MP4 “rtng”: 1 or 4 = explicit, 2 = clean. See `albumID3` for albums)
	ExplicitStatus *ExplicitStatus `json:"explicitStatus,omitempty"`

	// Genre The album genre
	Genre *string `json:"genre,omitempty"`

	// Genres The list of all genres of the album.
	Genres *[]ItemGenre `json:"genres,omitempty"`

	// Id The id of the album
	Id string `json:"id"`

	// IsCompilation True if the album is a compilation.
	IsCompilation *bool `json:"isCompilation,omitempty"`

	// Moods The list of all moods of the album.
	Moods *[]string `json:"moods,omitempty"`

	// MusicBrainzId The album MusicBrainzID.
	MusicBrainzId *string `json:"musicBrainzId,omitempty"`

	// Name The album name.
	Name string `json:"name"`

	// OriginalReleaseDate Date the album was originally released.
	OriginalReleaseDate *ItemDate `json:"originalReleaseDate,omitempty"`

	// PlayCount Number of play of the album
	PlayCount *int `json:"playCount,omitempty"`

	// Played Date the album was last played. [ISO 8601]
	Played *time.Time `json:"played,omitempty"`

	// RecordLabels The labels producing the album.
	RecordLabels *[]RecordLabel `json:"recordLabels,omitempty"`

	// ReleaseDate Date the specific edition of the album was released. Note: for files using ID3 tags, releaseDate should generally be read from the TDRL tag. Servers that use a different source for this field should document the behavior.
	ReleaseDate *ItemDate `json:"releaseDate,omitempty"`

	// ReleaseTypes The types of this album release. (Album, Compilation, EP, Remix, …).
	ReleaseTypes *[]string `json:"releaseTypes,omitempty"`

	// Song The list of songs
	Song []Child `json:"song"`

	// SongCount Number of songs
	SongCount int `json:"songCount"`

	// SortName The album sort name.
	SortName *string `json:"sortName,omitempty"`

	// Starred Date the album was added. [ISO 8601]
	Starred *time.Time `json:"starred,omitempty"`

	// UserRating The user rating of the album. [1-5]
	UserRating *int `json:"userRating,omitempty"`

	// Version The album version name (Remastered, Anniversary Box Set, …).
	Version *string `json:"version,omitempty"`

	// Year The album year
	Year *int `json:"year,omitempty"`
}

// AlbumInfo Album info.
type AlbumInfo struct {
	// LargeImageUrl Album largeImageUrl
	LargeImageUrl *string `json:"largeImageUrl,omitempty"`

	// LastFmUrl Album lastFmUrl
	LastFmUrl *string `json:"lastFmUrl,omitempty"`

	// MediumImageUrl Album mediumImageUrl
	MediumImageUrl *string `json:"mediumImageUrl,omitempty"`

	// MusicBrainzId Album musicBrainzId
	MusicBrainzId *string `json:"musicBrainzId,omitempty"`

	// Notes Album notes
	Notes *string `json:"notes,omitempty"`

	// SmallImageUrl Album smallImageUrl
	SmallImageUrl *string `json:"smallImageUrl,omitempty"`
}

// AlbumList Album list.
type AlbumList struct {
	// Album Artist albums
	Album *[]Child `json:"album,omitempty"`
}

// AlbumListType The list type. Must be one of the following: random, newest, highest, frequent, recent. Since 1.8.0 you can also use alphabeticalByName or alphabeticalByArtist to page through all albums alphabetically, and starred to retrieve starred albums. Since 1.10.1 you can use byYear and byGenre to list albums in a given year range or genre.
type AlbumListType string

// Artist Artist details.
type Artist struct {
	// ArtistImageUrl Artist image url
	ArtistImageUrl *string `json:"artistImageUrl,omitempty"`

	// AverageRating Artist average rating [1.0-5.0]
	AverageRating *float32 `json:"averageRating,omitempty"`

	// Id Artist id
	Id string `json:"id"`

	// Name Artist name
	Name string `json:"name"`

	// Starred Artist starred date [ISO 8601]
	Starred *time.Time `json:"starred,omitempty"`

	// UserRating Artist rating [1-5]
	UserRating *int `json:"userRating,omitempty"`
}

// ArtistID3 An artist from ID3 tags.
type ArtistID3 struct {
	// AlbumCount Artist album count.
	AlbumCount *int `json:"albumCount,omitempty"`

	// ArtistImageUrl An url to an external image source.
	ArtistImageUrl *string `json:"artistImageUrl,omitempty"`

	// CoverArt A covertArt id.
	CoverArt *string `json:"coverArt,omitempty"`

	// Id The id of the artist
	Id string `json:"id"`

	// MusicBrainzId The artist MusicBrainzID.
	MusicBrainzId *string `json:"musicBrainzId,omitempty"`

	// Name The artist name.
	Name string `json:"name"`

	// Roles The list of all roles this artist has in the library.
	Roles *[]string `json:"roles,omitempty"`

	// SortName The artist sort name.
	SortName *string `json:"sortName,omitempty"`

	// Starred Date the artist was starred. [ISO 8601]
	Starred *time.Time `json:"starred,omitempty"`
}

// ArtistInfo Artist info.
type ArtistInfo struct {
	// Biography Artist biography
	Biography *string `json:"biography,omitempty"`

	// LargeImageUrl Artist largeImageUrl
	LargeImageUrl *string `json:"largeImageUrl,omitempty"`

	// LastFmUrl Artist lastFmUrl
	LastFmUrl *string `json:"lastFmUrl,omitempty"`

	// MediumImageUrl Artist mediumImageUrl
	MediumImageUrl *string `json:"mediumImageUrl,omitempty"`

	// MusicBrainzId Artist musicBrainzId
	MusicBrainzId *string `json:"musicBrainzId,omitempty"`

	// SimilarArtist Similar artists
	SimilarArtist *[]Artist `json:"similarArtist,omitempty"`

	// SmallImageUrl Artist smallImageUrl
	SmallImageUrl *string `json:"smallImageUrl,omitempty"`
}

// ArtistInfo2 Artist info.
type ArtistInfo2 struct {
	// Biography Artist biography
	Biography *string `json:"biography,omitempty"`

	// LargeImageUrl Artist largeImageUrl
	LargeImageUrl *string `json:"largeImageUrl,omitempty"`

	// LastFmUrl Artist lastFmUrl
	LastFmUrl *string `json:"lastFmUrl,omitempty"`

	// MediumImageUrl Artist mediumImageUrl
	MediumImageUrl *string `json:"mediumImageUrl,omitempty"`

	// MusicBrainzId Artist musicBrainzId
	MusicBrainzId *string `json:"musicBrainzId,omitempty"`

	// SimilarArtist Similar artists
	SimilarArtist *[]ArtistID3 `json:"similarArtist,omitempty"`

	// SmallImageUrl Artist smallImageUrl
	SmallImageUrl *string `json:"smallImageUrl,omitempty"`
}

// ArtistWithAlbumsID3 defines model for ArtistWithAlbumsID3.
type ArtistWithAlbumsID3 struct {
	// Album Artist albums
	Album []AlbumID3 `json:"album"`

	// AlbumCount Artist album count.
	AlbumCount *int `json:"albumCount,omitempty"`

	// ArtistImageUrl An url to an external image source.
	ArtistImageUrl *string `json:"artistImageUrl,omitempty"`

	// CoverArt A covertArt id.
	CoverArt *string `json:"coverArt,omitempty"`

	// Id The id of the artist
	Id string `json:"id"`

	// MusicBrainzId The artist MusicBrainzID.
	MusicBrainzId *string `json:"musicBrainzId,omitempty"`

	// Name The artist name.
	Name string `json:"name"`

	// Roles The list of all roles this artist has in the library.
	Roles *[]string `json:"roles,omitempty"`

	// SortName The artist sort name.
	SortName *string `json:"sortName,omitempty"`

	// Starred Date the artist was starred. [ISO 8601]
	Starred *time.Time `json:"starred,omitempty"`
}

// ArtistsID3 A list of indexed Artists.
type ArtistsID3 struct {
	// IgnoredArticles List of ignored articles space separated
	IgnoredArticles *string `json:"ignoredArticles,omitempty"`

	// Index Index list
	Index *[]ArtistID3 `json:"index,omitempty"`
}

// Bookmark A bookmark.
type Bookmark struct {
	// Changed Bookmark last updated date [ISO 8601]
	Changed time.Time `json:"changed"`

	// Comment Bookmark comment
	Comment *string `json:"comment,omitempty"`

	// Created Bookmark creation date [ISO 8601]
	Created time.Time `json:"created"`

	// Entry The bookmark file
	Entry Child `json:"entry"`

	// Position Bookmark position in milliseconds
	Position int `json:"position"`

	// Username Username
	Username string `json:"username"`
}

// Bookmarks Bookmarks list.
type Bookmarks struct {
	// Bookmark List of bookmark
	Bookmark *[]Bookmark `json:"bookmark,omitempty"`
}

// ChatMessage A chatMessage.
type ChatMessage struct {
	// Message The message
	Message string `json:"message"`

	// Time Time in millis since Jan 1 1970
	Time int `json:"time"`

	// Username Username
	Username string `json:"username"`
}

// ChatMessages Chat messages list.
type ChatMessages struct {
	// ChatMessage List of chatMessage
	ChatMessage *[]ChatMessage `json:"chatMessage,omitempty"`
}

// Child A media.
type Child struct {
	// Album The album name.
	Album *string `json:"album,omitempty"`

	// AlbumArtists The list of all album artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
	AlbumArtists *[]ArtistID3 `json:"albumArtists,omitempty"`

	// AlbumId The corresponding album id
	AlbumId *string `json:"albumId,omitempty"`

	// Artist The artist name.
	Artist *string `json:"artist,omitempty"`

	// ArtistId The corresponding artist id
	ArtistId *string `json:"artistId,omitempty"`

	// Artists The list of all song artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
	Artists *[]ArtistID3 `json:"artists,omitempty"`

	// AverageRating The average rating of the media [1.0-5.0]
	AverageRating *float32 `json:"averageRating,omitempty"`

	// BitDepth The bit depth of the media.
	BitDepth *int `json:"bitDepth,omitempty"`

	// BitRate The bitrate of the media.
	BitRate *int `json:"bitRate,omitempty"`

	// BookmarkPosition The bookmark position in seconds
	BookmarkPosition *int `json:"bookmarkPosition,omitempty"`

	// Bpm The BPM of the song.
	Bpm *int `json:"bpm,omitempty"`

	// ChannelCount The number of channels of the media.
	ChannelCount *int `json:"channelCount,omitempty"`

	// Comment The comment tag of the song.
	Comment *string `json:"comment,omitempty"`

	// ContentType The mimeType of the media.
	ContentType *string `json:"contentType,omitempty"`

	// Contributors The list of all contributor artists of the song.
	Contributors *[]Contributor `json:"contributors,omitempty"`

	// CoverArt The coverArt id.
	CoverArt *string `json:"coverArt,omitempty"`

	// Created Date the media was created. [ISO 8601]
	Created *time.Time `json:"created,omitempty"`

	// DiscNumber The disc number.
	DiscNumber *int `json:"discNumber,omitempty"`

	// DisplayAlbumArtist The single value display album artist.
	DisplayAlbumArtist *string `json:"displayAlbumArtist,omitempty"`

	// DisplayArtist The single value display artist.
	DisplayArtist *string `json:"displayArtist,omitempty"`

	// DisplayComposer The single value display composer.
	DisplayComposer *string `json:"displayComposer,omitempty"`

	// Duration The duration of the media in seconds.
	Duration *int `json:"duration,omitempty"`

	// ExplicitStatus Returns “explicit”, “clean” or “”. (For songs extracted from tags “ITUNESADVISORY”: 1 = explicit, 2 = clean, MP4 “rtng”: 1 or 4 = explicit, 2 = clean. See `albumID3` for albums)
	ExplicitStatus *ExplicitStatus `json:"explicitStatus,omitempty"`

	// Genre The media genre
	Genre *string `json:"genre,omitempty"`

	// Genres The list of all genres of the song.
	Genres *[]ItemGenre `json:"genres,omitempty"`

	// Id The id of the media.
	Id string `json:"id"`

	// IsDir The media is a directory
	IsDir bool `json:"isDir"`

	// IsVideo Media is a video
	IsVideo *bool `json:"isVideo,omitempty"`

	// Isrc The track ISRC(s).
	Isrc *[]string `json:"isrc,omitempty"`

	// MediaType Note: If you support `musicBrainzId` you must support this field to ensure clients knows what the ID refers to.
	MediaType *MediaType `json:"mediaType,omitempty"`

	// Moods The list of all moods of the song.
	Moods *[]string `json:"moods,omitempty"`

	// MusicBrainzId The track MusicBrainzID.
	MusicBrainzId *string `json:"musicBrainzId,omitempty"`

	// OriginalHeight The video original Height
	OriginalHeight *int `json:"originalHeight,omitempty"`

	// OriginalWidth The video original Width
	OriginalWidth *int `json:"originalWidth,omitempty"`

	// Parent The id of the parent (folder/album)
	Parent *string `json:"parent,omitempty"`

	// Path The full path of the media.
	Path *string `json:"path,omitempty"`

	// PlayCount The play count.
	PlayCount *int `json:"playCount,omitempty"`

	// Played Date the album was last played. [ISO 8601]
	Played *time.Time `json:"played,omitempty"`

	// ReplayGain The replay gain data of the song.
	ReplayGain *ReplayGain `json:"replayGain,omitempty"`

	// SamplingRate The sampling rate of the media.
	SamplingRate *int `json:"samplingRate,omitempty"`

	// Size A file size of the media.
	Size *int `json:"size,omitempty"`

	// SortName The song sort name.
	SortName *string `json:"sortName,omitempty"`

	// Starred Date the media was starred. [ISO 8601]
	Starred *time.Time `json:"starred,omitempty"`

	// Suffix The file suffix of the media.
	Suffix *string `json:"suffix,omitempty"`

	// Title The media name.
	Title string `json:"title"`

	// Track The track number.
	Track *int `json:"track,omitempty"`

	// TranscodedContentType The transcoded mediaType if transcoding should happen.
	TranscodedContentType *string `json:"transcodedContentType,omitempty"`

	// TranscodedSuffix The file suffix of the transcoded media.
	TranscodedSuffix *string `json:"transcodedSuffix,omitempty"`

	// Type The generic type of media [music/podcast/audiobook/video]
	Type *GenericMediaType `json:"type,omitempty"`

	// UserRating The user rating of the media [1-5]
	UserRating *int `json:"userRating,omitempty"`

	// Year The media year.
	Year *int `json:"year,omitempty"`
}

// ClientInfo defines model for ClientInfo.
type ClientInfo struct {
	CodecProfiles              *[]CodecProfile       `json:"codecProfiles,omitempty"`
	DirectPlayProfiles         *[]DirectPlayProfile  `json:"directPlayProfiles,omitempty"`
	MaxAudioBitrate            *int                  `json:"maxAudioBitrate,omitempty"`
	MaxTranscodingAudioBitrate *int                  `json:"maxTranscodingAudioBitrate,omitempty"`
	Name                       string                `json:"name"`
	Platform                   string                `json:"platform"`
	TranscodingProfiles        *[]TranscodingProfile `json:"transcodingProfiles,omitempty"`
}

// CodecProfile defines model for CodecProfile.
type CodecProfile struct {
	Limitations *[]Limitation    `json:"limitations,omitempty"`
	Name        string           `json:"name"`
	Type        CodecProfileType `json:"type"`
}

// CodecProfileType defines model for CodecProfile.Type.
type CodecProfileType string

// Contributor A contributor artist for a song or an album
type Contributor struct {
	// Artist An artist from ID3 tags.
	Artist ArtistID3 `json:"artist"`

	// Role The contributor role.
	Role string `json:"role"`

	// SubRole The subRole for roles that may require it. Ex: The instrument for the performer role (TMCL/performer tags). Note: For consistency between different tag formats, the TIPL sub roles should be directly exposed in the role field.
	SubRole *string `json:"subRole,omitempty"`
}

// CreatePlaylistResponse A subsonic-response element with a nested playlist element on success.
type CreatePlaylistResponse struct {
	SubsonicResponse *CreatePlaylistResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// CreatePlaylistResponse_SubsonicResponse defines model for CreatePlaylistResponse.SubsonicResponse.
type CreatePlaylistResponse_SubsonicResponse struct {
	union json.RawMessage
}

// CreatePlaylistSuccessResponse defines model for CreatePlaylistSuccessResponse.
type CreatePlaylistSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool              `json:"openSubsonic"`
	Playlist     PlaylistWithSongs `json:"playlist"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status CreatePlaylistSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// CreatePlaylistSuccessResponseStatus The command result. `ok`
type CreatePlaylistSuccessResponseStatus string

// CreateSharesResponse A subsonic-response element with a nested shares element on success. Which in turns contains a single share element for the newly created share
type CreateSharesResponse struct {
	SubsonicResponse *CreateSharesResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// CreateSharesResponse_SubsonicResponse defines model for CreateSharesResponse.SubsonicResponse.
type CreateSharesResponse_SubsonicResponse struct {
	union json.RawMessage
}

// CreateSharesSuccessResponse defines model for CreateSharesSuccessResponse.
type CreateSharesSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Shares Shares.
	Shares Shares `json:"shares"`

	// Status The command result. `ok`
	Status CreateSharesSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// CreateSharesSuccessResponseStatus The command result. `ok`
type CreateSharesSuccessResponseStatus string

// DirectPlayProfile defines model for DirectPlayProfile.
type DirectPlayProfile struct {
	// AudioCodecs The list of supported codecs. An empty array means any codecs.
	AudioCodecs []string `json:"audioCodecs"`

	// Containers The list of supported containers. An empty array means any containers.
	Containers       []string `json:"containers"`
	MaxAudioChannels *int     `json:"maxAudioChannels,omitempty"`

	// Protocols The list of supported protocols. An empty array means any protocols.
	Protocols []DirectPlayProfileProtocols `json:"protocols"`
}

// DirectPlayProfileProtocols defines model for DirectPlayProfile.Protocols.
type DirectPlayProfileProtocols string

// Directory Directory.
type Directory struct {
	// AverageRating The average rating [1-5]
	AverageRating *float32 `json:"averageRating,omitempty"`

	// Child The directory content
	Child *[]Child `json:"child,omitempty"`

	// Id The id
	Id string `json:"id"`

	// Name The directory name
	Name string `json:"name"`

	// Parent Parent item
	Parent *string `json:"parent,omitempty"`

	// PlayCount The play count
	PlayCount *int `json:"playCount,omitempty"`

	// Starred Starred date [ISO 8601]
	Starred *time.Time `json:"starred,omitempty"`

	// UserRating The user rating [1-5]
	UserRating *int `json:"userRating,omitempty"`
}

// DiscTitle A disc title for an album
type DiscTitle struct {
	// Disc The disc number.
	Disc int `json:"disc"`

	// Title The name of the disc.
	Title string `json:"title"`
}

// Error defines model for Error.
type Error struct {
	// Code The error code.
	// * 0: A generic error.
	// * 10: Required parameter is missing.
	// * 20: Incompatible Subsonic REST protocol version. Client must upgrade.
	// * 30: Incompatible Subsonic REST protocol version. Server must upgrade.
	// * 40: Wrong username or password.
	// * 41: Token authentication not supported for LDAP users.
	// * 42: Provided authentication mechanism not supported.
	// * 43: Multiple conflicting authentication mechanisms provided.
	// * 44: Invalid API key.
	// * 50: User is not authorized for the given operation.
	// * 60: The trial period for the Subsonic server is over. Please upgrade to Subsonic Premium. Visit subsonic.org for details.
	// * 70: The requested data was not found.
	Code ErrorCode `json:"code"`

	// HelpUrl A URL (documentation, configuration, etc) which may provide additional context for the error)
	HelpUrl *string `json:"helpUrl,omitempty"`

	// Message The optional error message
	Message *string `json:"message,omitempty"`
}

// ErrorCode The error code.
// * 0: A generic error.
// * 10: Required parameter is missing.
// * 20: Incompatible Subsonic REST protocol version. Client must upgrade.
// * 30: Incompatible Subsonic REST protocol version. Server must upgrade.
// * 40: Wrong username or password.
// * 41: Token authentication not supported for LDAP users.
// * 42: Provided authentication mechanism not supported.
// * 43: Multiple conflicting authentication mechanisms provided.
// * 44: Invalid API key.
// * 50: User is not authorized for the given operation.
// * 60: The trial period for the Subsonic server is over. Please upgrade to Subsonic Premium. Visit subsonic.org for details.
// * 70: The requested data was not found.
type ErrorCode int

// ExplicitStatus Returns “explicit”, “clean” or “”. (For songs extracted from tags “ITUNESADVISORY”: 1 = explicit, 2 = clean, MP4 “rtng”: 1 or 4 = explicit, 2 = clean. See `albumID3` for albums)
type ExplicitStatus string

// GenericMediaType The generic type of media [music/podcast/audiobook/video]
type GenericMediaType string

// Genre A genre.
type Genre struct {
	// AlbumCount Genre album count
	AlbumCount int `json:"albumCount"`

	// SongCount Genre song count
	SongCount int `json:"songCount"`

	// Value Genre name
	Value string `json:"value"`
}

// Genres Genres list.
type Genres struct {
	// Genre List of genre
	Genre *[]Genre `json:"genre,omitempty"`
}

// GetAlbumInfoResponse A subsonic-response element with a nested albumInfo element on success.
type GetAlbumInfoResponse struct {
	SubsonicResponse *GetAlbumInfoResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetAlbumInfoResponse_SubsonicResponse defines model for GetAlbumInfoResponse.SubsonicResponse.
type GetAlbumInfoResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetAlbumInfoSuccessResponse defines model for GetAlbumInfoSuccessResponse.
type GetAlbumInfoSuccessResponse struct {
	// AlbumInfo Album info.
	AlbumInfo AlbumInfo `json:"albumInfo"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetAlbumInfoSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetAlbumInfoSuccessResponseStatus The command result. `ok`
type GetAlbumInfoSuccessResponseStatus string

// GetAlbumList2Response A subsonic-response element with a nested albumList2 element on success.
type GetAlbumList2Response struct {
	SubsonicResponse *GetAlbumList2Response_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetAlbumList2Response_SubsonicResponse defines model for GetAlbumList2Response.SubsonicResponse.
type GetAlbumList2Response_SubsonicResponse struct {
	union json.RawMessage
}

// GetAlbumList2SuccessResponse defines model for GetAlbumList2SuccessResponse.
type GetAlbumList2SuccessResponse struct {
	// AlbumList2 Album list.
	AlbumList2 AlbumList `json:"albumList2"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetAlbumList2SuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetAlbumList2SuccessResponseStatus The command result. `ok`
type GetAlbumList2SuccessResponseStatus string

// GetAlbumListResponse A subsonic-response element with a nested albumList element on success.
type GetAlbumListResponse struct {
	SubsonicResponse *GetAlbumListResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetAlbumListResponse_SubsonicResponse defines model for GetAlbumListResponse.SubsonicResponse.
type GetAlbumListResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetAlbumListSuccessResponse defines model for GetAlbumListSuccessResponse.
type GetAlbumListSuccessResponse struct {
	// AlbumList Album list.
	AlbumList AlbumList `json:"albumList"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetAlbumListSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetAlbumListSuccessResponseStatus The command result. `ok`
type GetAlbumListSuccessResponseStatus string

// GetAlbumResponse A subsonic-response element with a nested album element on success.
type GetAlbumResponse struct {
	SubsonicResponse *GetAlbumResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetAlbumResponse_SubsonicResponse defines model for GetAlbumResponse.SubsonicResponse.
type GetAlbumResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetAlbumSuccessResponse defines model for GetAlbumSuccessResponse.
type GetAlbumSuccessResponse struct {
	Album AlbumID3WithSongs `json:"album"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetAlbumSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetAlbumSuccessResponseStatus The command result. `ok`
type GetAlbumSuccessResponseStatus string

// GetArtistInfo2Response A subsonic-response element with a nested artistInfo2 element on success.
type GetArtistInfo2Response struct {
	SubsonicResponse *GetArtistInfo2Response_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetArtistInfo2Response_SubsonicResponse defines model for GetArtistInfo2Response.SubsonicResponse.
type GetArtistInfo2Response_SubsonicResponse struct {
	union json.RawMessage
}

// GetArtistInfo2SuccessResponse defines model for GetArtistInfo2SuccessResponse.
type GetArtistInfo2SuccessResponse struct {
	// ArtistInfo2 Artist info.
	ArtistInfo2 ArtistInfo2 `json:"artistInfo2"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetArtistInfo2SuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetArtistInfo2SuccessResponseStatus The command result. `ok`
type GetArtistInfo2SuccessResponseStatus string

// GetArtistInfoResponse A subsonic-response element with a nested artistInfo element on success.
type GetArtistInfoResponse struct {
	SubsonicResponse *GetArtistInfoResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetArtistInfoResponse_SubsonicResponse defines model for GetArtistInfoResponse.SubsonicResponse.
type GetArtistInfoResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetArtistInfoSuccessResponse defines model for GetArtistInfoSuccessResponse.
type GetArtistInfoSuccessResponse struct {
	// ArtistInfo Artist info.
	ArtistInfo ArtistInfo `json:"artistInfo"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetArtistInfoSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetArtistInfoSuccessResponseStatus The command result. `ok`
type GetArtistInfoSuccessResponseStatus string

// GetArtistResponse A subsonic-response element with a nested artist element on success.
type GetArtistResponse struct {
	SubsonicResponse *GetArtistResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetArtistResponse_SubsonicResponse defines model for GetArtistResponse.SubsonicResponse.
type GetArtistResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetArtistSuccessResponse defines model for GetArtistSuccessResponse.
type GetArtistSuccessResponse struct {
	Artist ArtistWithAlbumsID3 `json:"artist"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetArtistSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetArtistSuccessResponseStatus The command result. `ok`
type GetArtistSuccessResponseStatus string

// GetArtistsResponse A subsonic-response element with a nested artists element on success.
type GetArtistsResponse struct {
	SubsonicResponse *GetArtistsResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetArtistsResponse_SubsonicResponse defines model for GetArtistsResponse.SubsonicResponse.
type GetArtistsResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetArtistsSuccessResponse defines model for GetArtistsSuccessResponse.
type GetArtistsSuccessResponse struct {
	// Artists A list of indexed Artists.
	Artists ArtistsID3 `json:"artists"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetArtistsSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetArtistsSuccessResponseStatus The command result. `ok`
type GetArtistsSuccessResponseStatus string

// GetBookmarksResponse A subsonic-response element with a nested bookmarks element on success.
type GetBookmarksResponse struct {
	SubsonicResponse *GetBookmarksResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetBookmarksResponse_SubsonicResponse defines model for GetBookmarksResponse.SubsonicResponse.
type GetBookmarksResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetBookmarksSuccessResponse defines model for GetBookmarksSuccessResponse.
type GetBookmarksSuccessResponse struct {
	// Bookmarks Bookmarks list.
	Bookmarks Bookmarks `json:"bookmarks"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetBookmarksSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetBookmarksSuccessResponseStatus The command result. `ok`
type GetBookmarksSuccessResponseStatus string

// GetChatMessagesResponse A subsonic-response element with a nested chatMessages element on success.
type GetChatMessagesResponse struct {
	SubsonicResponse *GetChatMessagesResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetChatMessagesResponse_SubsonicResponse defines model for GetChatMessagesResponse.SubsonicResponse.
type GetChatMessagesResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetChatMessagesSuccessResponse defines model for GetChatMessagesSuccessResponse.
type GetChatMessagesSuccessResponse struct {
	// ChatMessages Chat messages list.
	ChatMessages ChatMessages `json:"chatMessages"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetChatMessagesSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetChatMessagesSuccessResponseStatus The command result. `ok`
type GetChatMessagesSuccessResponseStatus string

// GetGenresResponse A subsonic-response element with a nested genres element on success.
type GetGenresResponse struct {
	SubsonicResponse *GetGenresResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetGenresResponse_SubsonicResponse defines model for GetGenresResponse.SubsonicResponse.
type GetGenresResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetGenresSuccessResponse defines model for GetGenresSuccessResponse.
type GetGenresSuccessResponse struct {
	// Genres Genres list.
	Genres Genres `json:"genres"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetGenresSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetGenresSuccessResponseStatus The command result. `ok`
type GetGenresSuccessResponseStatus string

// GetIndexesResponse A subsonic-response element with a nested indexes element on success.
type GetIndexesResponse struct {
	SubsonicResponse *GetIndexesResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetIndexesResponse_SubsonicResponse defines model for GetIndexesResponse.SubsonicResponse.
type GetIndexesResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetIndexesSuccessResponse defines model for GetIndexesSuccessResponse.
type GetIndexesSuccessResponse struct {
	// Indexes Artist list.
	Indexes Indexes `json:"indexes"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetIndexesSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetIndexesSuccessResponseStatus The command result. `ok`
type GetIndexesSuccessResponseStatus string

// GetInternetRadioStationsResponse A subsonic-response element with a nested internetRadioStations element on success.
type GetInternetRadioStationsResponse struct {
	SubsonicResponse *GetInternetRadioStationsResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetInternetRadioStationsResponse_SubsonicResponse defines model for GetInternetRadioStationsResponse.SubsonicResponse.
type GetInternetRadioStationsResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetInternetRadioStationsSuccessResponse defines model for GetInternetRadioStationsSuccessResponse.
type GetInternetRadioStationsSuccessResponse struct {
	// InternetRadioStations internetRadioStations.
	InternetRadioStations InternetRadioStations `json:"internetRadioStations"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetInternetRadioStationsSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetInternetRadioStationsSuccessResponseStatus The command result. `ok`
type GetInternetRadioStationsSuccessResponseStatus string

// GetLicenseResponse A subsonic-response element with a nested license element on success.
type GetLicenseResponse struct {
	SubsonicResponse *GetLicenseResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetLicenseResponse_SubsonicResponse defines model for GetLicenseResponse.SubsonicResponse.
type GetLicenseResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetLicenseSuccessResponse defines model for GetLicenseSuccessResponse.
type GetLicenseSuccessResponse struct {
	// License getLicense result.
	License License `json:"license"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetLicenseSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetLicenseSuccessResponseStatus The command result. `ok`
type GetLicenseSuccessResponseStatus string

// GetLyricsBySongIdResponse A subsonic-response element with a nested lyricsList
type GetLyricsBySongIdResponse struct {
	SubsonicResponse *GetLyricsBySongIdResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetLyricsBySongIdResponse_SubsonicResponse defines model for GetLyricsBySongIdResponse.SubsonicResponse.
type GetLyricsBySongIdResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetLyricsBySongIdSuccessResponse defines model for GetLyricsBySongIdSuccessResponse.
type GetLyricsBySongIdSuccessResponse struct {
	// LyricsList List of structured lyrics
	LyricsList LyricsList `json:"lyricsList"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetLyricsBySongIdSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetLyricsBySongIdSuccessResponseStatus The command result. `ok`
type GetLyricsBySongIdSuccessResponseStatus string

// GetLyricsResponse A subsonic-response element with a nested lyrics element on success.
type GetLyricsResponse struct {
	SubsonicResponse *GetLyricsResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetLyricsResponse_SubsonicResponse defines model for GetLyricsResponse.SubsonicResponse.
type GetLyricsResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetLyricsSuccessResponse defines model for GetLyricsSuccessResponse.
type GetLyricsSuccessResponse struct {
	// Lyrics Lyrics.
	Lyrics Lyrics `json:"lyrics"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetLyricsSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetLyricsSuccessResponseStatus The command result. `ok`
type GetLyricsSuccessResponseStatus string

// GetMusicDirectoryResponse A subsonic-response element with a nested directory element on success.
type GetMusicDirectoryResponse struct {
	SubsonicResponse *GetMusicDirectoryResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetMusicDirectoryResponse_SubsonicResponse defines model for GetMusicDirectoryResponse.SubsonicResponse.
type GetMusicDirectoryResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetMusicDirectorySuccessResponse defines model for GetMusicDirectorySuccessResponse.
type GetMusicDirectorySuccessResponse struct {
	// Directory Directory.
	Directory Directory `json:"directory"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetMusicDirectorySuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetMusicDirectorySuccessResponseStatus The command result. `ok`
type GetMusicDirectorySuccessResponseStatus string

// GetMusicFoldersResponse A subsonic-response element with a nested musicFolders element on success.
type GetMusicFoldersResponse struct {
	SubsonicResponse *GetMusicFoldersResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetMusicFoldersResponse_SubsonicResponse defines model for GetMusicFoldersResponse.SubsonicResponse.
type GetMusicFoldersResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetMusicFoldersSuccessResponse defines model for GetMusicFoldersSuccessResponse.
type GetMusicFoldersSuccessResponse struct {
	// MusicFolders MusicFolders.
	MusicFolders MusicFolders `json:"musicFolders"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetMusicFoldersSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetMusicFoldersSuccessResponseStatus The command result. `ok`
type GetMusicFoldersSuccessResponseStatus string

// GetNewestPodcastsResponse A subsonic-response element with a nested `newestPodcasts` element on success.
type GetNewestPodcastsResponse struct {
	SubsonicResponse *GetNewestPodcastsResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetNewestPodcastsResponse_SubsonicResponse defines model for GetNewestPodcastsResponse.SubsonicResponse.
type GetNewestPodcastsResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetNewestPodcastsSuccessResponse defines model for GetNewestPodcastsSuccessResponse.
type GetNewestPodcastsSuccessResponse struct {
	// NewestPodcasts NewestPodcasts.
	NewestPodcasts NewestPodcasts `json:"newestPodcasts"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetNewestPodcastsSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetNewestPodcastsSuccessResponseStatus The command result. `ok`
type GetNewestPodcastsSuccessResponseStatus string

// GetNowPlayingResponse A subsonic-response element with a nested `nowPlaying` element on success.
type GetNowPlayingResponse struct {
	SubsonicResponse *GetNowPlayingResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetNowPlayingResponse_SubsonicResponse defines model for GetNowPlayingResponse.SubsonicResponse.
type GetNowPlayingResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetNowPlayingSuccessResponse defines model for GetNowPlayingSuccessResponse.
type GetNowPlayingSuccessResponse struct {
	// NowPlaying nowPlaying.
	NowPlaying NowPlaying `json:"nowPlaying"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetNowPlayingSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetNowPlayingSuccessResponseStatus The command result. `ok`
type GetNowPlayingSuccessResponseStatus string

// GetOpenSubsonicExtensionsResponse A subsonic-response element with a nested `openSubsonicExtensions` element on success.
type GetOpenSubsonicExtensionsResponse struct {
	SubsonicResponse *GetOpenSubsonicExtensionsResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetOpenSubsonicExtensionsResponse_SubsonicResponse defines model for GetOpenSubsonicExtensionsResponse.SubsonicResponse.
type GetOpenSubsonicExtensionsResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetOpenSubsonicExtensionsSuccessResponse defines model for GetOpenSubsonicExtensionsSuccessResponse.
type GetOpenSubsonicExtensionsSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic           bool                    `json:"openSubsonic"`
	OpenSubsonicExtensions []OpenSubsonicExtension `json:"openSubsonicExtensions"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetOpenSubsonicExtensionsSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetOpenSubsonicExtensionsSuccessResponseStatus The command result. `ok`
type GetOpenSubsonicExtensionsSuccessResponseStatus string

// GetPlayQueueByIndexResponse A subsonic-response element with a nested `PlayQueueByIndex` element on success.
type GetPlayQueueByIndexResponse struct {
	SubsonicResponse *GetPlayQueueByIndexResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetPlayQueueByIndexResponse_SubsonicResponse defines model for GetPlayQueueByIndexResponse.SubsonicResponse.
type GetPlayQueueByIndexResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetPlayQueueByIndexSuccessResponse defines model for GetPlayQueueByIndexSuccessResponse.
type GetPlayQueueByIndexSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// PlayQueueByIndex NowPlayingEntry with queue index.
	PlayQueueByIndex PlayQueueByIndex `json:"playQueueByIndex"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetPlayQueueByIndexSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetPlayQueueByIndexSuccessResponseStatus The command result. `ok`
type GetPlayQueueByIndexSuccessResponseStatus string

// GetPlayQueueResponse A subsonic-response element with a nested `playQueue` element on success.
type GetPlayQueueResponse struct {
	SubsonicResponse *GetPlayQueueResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetPlayQueueResponse_SubsonicResponse defines model for GetPlayQueueResponse.SubsonicResponse.
type GetPlayQueueResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetPlayQueueSuccessResponse defines model for GetPlayQueueSuccessResponse.
type GetPlayQueueSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// PlayQueue NowPlayingEntry.
	PlayQueue PlayQueue `json:"playQueue"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetPlayQueueSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetPlayQueueSuccessResponseStatus The command result. `ok`
type GetPlayQueueSuccessResponseStatus string

// GetPlaylistResponse A subsonic-response element with a nested playlist element on success.
type GetPlaylistResponse struct {
	SubsonicResponse *GetPlaylistResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetPlaylistResponse_SubsonicResponse defines model for GetPlaylistResponse.SubsonicResponse.
type GetPlaylistResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetPlaylistSuccessResponse defines model for GetPlaylistSuccessResponse.
type GetPlaylistSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool              `json:"openSubsonic"`
	Playlist     PlaylistWithSongs `json:"playlist"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetPlaylistSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetPlaylistSuccessResponseStatus The command result. `ok`
type GetPlaylistSuccessResponseStatus string

// GetPlaylistsResponse A subsonic-response element with a nested `playlists` element on success.
type GetPlaylistsResponse struct {
	SubsonicResponse *GetPlaylistsResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetPlaylistsResponse_SubsonicResponse defines model for GetPlaylistsResponse.SubsonicResponse.
type GetPlaylistsResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetPlaylistsSuccessResponse defines model for GetPlaylistsSuccessResponse.
type GetPlaylistsSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// Playlists Playlists.
	Playlists Playlists `json:"playlists"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetPlaylistsSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetPlaylistsSuccessResponseStatus The command result. `ok`
type GetPlaylistsSuccessResponseStatus string

// GetPodcastEpisodeResponse A subsonic-response element with a nested `podcastEpisode` element on success.
type GetPodcastEpisodeResponse struct {
	SubsonicResponse *GetPodcastEpisodeResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetPodcastEpisodeResponse_SubsonicResponse defines model for GetPodcastEpisodeResponse.SubsonicResponse.
type GetPodcastEpisodeResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetPodcastEpisodeSuccessResponse defines model for GetPodcastEpisodeSuccessResponse.
type GetPodcastEpisodeSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic   bool           `json:"openSubsonic"`
	PodcastEpisode PodcastEpisode `json:"podcastEpisode"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetPodcastEpisodeSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetPodcastEpisodeSuccessResponseStatus The command result. `ok`
type GetPodcastEpisodeSuccessResponseStatus string

// GetPodcastsResponse A subsonic-response element with a nested `podcasts` element on success.
type GetPodcastsResponse struct {
	SubsonicResponse *GetPodcastsResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetPodcastsResponse_SubsonicResponse defines model for GetPodcastsResponse.SubsonicResponse.
type GetPodcastsResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetPodcastsSuccessResponse defines model for GetPodcastsSuccessResponse.
type GetPodcastsSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// Podcasts Podcasts.
	Podcasts Podcasts `json:"podcasts"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetPodcastsSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetPodcastsSuccessResponseStatus The command result. `ok`
type GetPodcastsSuccessResponseStatus string

// GetRandomSongsResponse A subsonic-response element with a nested `randomSongs` element on success.
type GetRandomSongsResponse struct {
	SubsonicResponse *GetRandomSongsResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetRandomSongsResponse_SubsonicResponse defines model for GetRandomSongsResponse.SubsonicResponse.
type GetRandomSongsResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetRandomSongsSuccessResponse defines model for GetRandomSongsSuccessResponse.
type GetRandomSongsSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// RandomSongs Songs list.
	RandomSongs Songs `json:"randomSongs"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetRandomSongsSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetRandomSongsSuccessResponseStatus The command result. `ok`
type GetRandomSongsSuccessResponseStatus string

// GetScanStatusResponse A subsonic-response element with a nested `scanStatus` element on success.
type GetScanStatusResponse struct {
	SubsonicResponse *GetScanStatusResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetScanStatusResponse_SubsonicResponse defines model for GetScanStatusResponse.SubsonicResponse.
type GetScanStatusResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetScanStatusSuccessResponse defines model for GetScanStatusSuccessResponse.
type GetScanStatusSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ScanStatus Scan status information.
	ScanStatus ScanStatus `json:"scanStatus"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetScanStatusSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetScanStatusSuccessResponseStatus The command result. `ok`
type GetScanStatusSuccessResponseStatus string

// GetSharesResponse A subsonic-response element with a nested `shares` element on success.
type GetSharesResponse struct {
	SubsonicResponse *GetSharesResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetSharesResponse_SubsonicResponse defines model for GetSharesResponse.SubsonicResponse.
type GetSharesResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetSharesSuccessResponse defines model for GetSharesSuccessResponse.
type GetSharesSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Shares Shares.
	Shares Shares `json:"shares"`

	// Status The command result. `ok`
	Status GetSharesSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetSharesSuccessResponseStatus The command result. `ok`
type GetSharesSuccessResponseStatus string

// GetSimilarSongs2Response A subsonic-response element with a nested `similarSongs2` element on success.
type GetSimilarSongs2Response struct {
	SubsonicResponse *GetSimilarSongs2Response_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetSimilarSongs2Response_SubsonicResponse defines model for GetSimilarSongs2Response.SubsonicResponse.
type GetSimilarSongs2Response_SubsonicResponse struct {
	union json.RawMessage
}

// GetSimilarSongs2SuccessResponse defines model for GetSimilarSongs2SuccessResponse.
type GetSimilarSongs2SuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// SimilarSongs2 SimilarSongs2 list.
	SimilarSongs2 SimilarSongs2 `json:"similarSongs2"`

	// Status The command result. `ok`
	Status GetSimilarSongs2SuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetSimilarSongs2SuccessResponseStatus The command result. `ok`
type GetSimilarSongs2SuccessResponseStatus string

// GetSimilarSongsResponse A subsonic-response element with a nested `similarSongs` element on success.
type GetSimilarSongsResponse struct {
	SubsonicResponse *GetSimilarSongsResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetSimilarSongsResponse_SubsonicResponse defines model for GetSimilarSongsResponse.SubsonicResponse.
type GetSimilarSongsResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetSimilarSongsSuccessResponse defines model for GetSimilarSongsSuccessResponse.
type GetSimilarSongsSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// SimilarSongs SimilarSongs list.
	SimilarSongs SimilarSongs `json:"similarSongs"`

	// Status The command result. `ok`
	Status GetSimilarSongsSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetSimilarSongsSuccessResponseStatus The command result. `ok`
type GetSimilarSongsSuccessResponseStatus string

// GetSongResponse A subsonic-response element with a nested `song` element on success.
type GetSongResponse struct {
	SubsonicResponse *GetSongResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetSongResponse_SubsonicResponse defines model for GetSongResponse.SubsonicResponse.
type GetSongResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetSongSuccessResponse defines model for GetSongSuccessResponse.
type GetSongSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Song A media.
	Song Child `json:"song"`

	// Status The command result. `ok`
	Status GetSongSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetSongSuccessResponseStatus The command result. `ok`
type GetSongSuccessResponseStatus string

// GetSongsByGenreResponse A subsonic-response element with a nested `songsByGenre` element on success.
type GetSongsByGenreResponse struct {
	SubsonicResponse *GetSongsByGenreResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetSongsByGenreResponse_SubsonicResponse defines model for GetSongsByGenreResponse.SubsonicResponse.
type GetSongsByGenreResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetSongsByGenreSuccessResponse defines model for GetSongsByGenreSuccessResponse.
type GetSongsByGenreSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// SongsByGenre Songs list.
	SongsByGenre Songs `json:"songsByGenre"`

	// Status The command result. `ok`
	Status GetSongsByGenreSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetSongsByGenreSuccessResponseStatus The command result. `ok`
type GetSongsByGenreSuccessResponseStatus string

// GetStarred2Response A subsonic-response element with a nested `starred2` element on success.
type GetStarred2Response struct {
	SubsonicResponse *GetStarred2Response_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetStarred2Response_SubsonicResponse defines model for GetStarred2Response.SubsonicResponse.
type GetStarred2Response_SubsonicResponse struct {
	union json.RawMessage
}

// GetStarred2SuccessResponse defines model for GetStarred2SuccessResponse.
type GetStarred2SuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Starred2 Starred2.
	Starred2 Starred2 `json:"starred2"`

	// Status The command result. `ok`
	Status GetStarred2SuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetStarred2SuccessResponseStatus The command result. `ok`
type GetStarred2SuccessResponseStatus string

// GetStarredResponse A subsonic-response element with a nested `starred` element on success.
type GetStarredResponse struct {
	SubsonicResponse *GetStarredResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetStarredResponse_SubsonicResponse defines model for GetStarredResponse.SubsonicResponse.
type GetStarredResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetStarredSuccessResponse defines model for GetStarredSuccessResponse.
type GetStarredSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Starred starred.
	Starred Starred `json:"starred"`

	// Status The command result. `ok`
	Status GetStarredSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetStarredSuccessResponseStatus The command result. `ok`
type GetStarredSuccessResponseStatus string

// GetTokenInfoResponse A subsonic-response element with a nested tokenInfo on success, or error 44 on invalid token.
type GetTokenInfoResponse struct {
	SubsonicResponse *GetTokenInfoResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetTokenInfoResponse_SubsonicResponse defines model for GetTokenInfoResponse.SubsonicResponse.
type GetTokenInfoResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetTokenInfoSuccessResponse defines model for GetTokenInfoSuccessResponse.
type GetTokenInfoSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetTokenInfoSuccessResponseStatus `json:"status"`

	// TokenInfo Information about an API key
	TokenInfo TokenInfo `json:"tokenInfo"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetTokenInfoSuccessResponseStatus The command result. `ok`
type GetTokenInfoSuccessResponseStatus string

// GetTopSongsResponse A subsonic-response element with a nested `topSongs` element on success.
type GetTopSongsResponse struct {
	SubsonicResponse *GetTopSongsResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetTopSongsResponse_SubsonicResponse defines model for GetTopSongsResponse.SubsonicResponse.
type GetTopSongsResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetTopSongsSuccessResponse defines model for GetTopSongsSuccessResponse.
type GetTopSongsSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetTopSongsSuccessResponseStatus `json:"status"`

	// TopSongs TopSongs list.
	TopSongs TopSongs `json:"topSongs"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetTopSongsSuccessResponseStatus The command result. `ok`
type GetTopSongsSuccessResponseStatus string

// GetUserResponse A subsonic-response element with a nested `user` element on success.
type GetUserResponse struct {
	SubsonicResponse *GetUserResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetUserResponse_SubsonicResponse defines model for GetUserResponse.SubsonicResponse.
type GetUserResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetUserSuccessResponse defines model for GetUserSuccessResponse.
type GetUserSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetUserSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// User user.
	User User `json:"user"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetUserSuccessResponseStatus The command result. `ok`
type GetUserSuccessResponseStatus string

// GetUsersResponse A subsonic-response element with a nested `user` element on success.
type GetUsersResponse struct {
	SubsonicResponse *GetUsersResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetUsersResponse_SubsonicResponse defines model for GetUsersResponse.SubsonicResponse.
type GetUsersResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetUsersSuccessResponse defines model for GetUsersSuccessResponse.
type GetUsersSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetUsersSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Users users.
	Users Users `json:"users"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// GetUsersSuccessResponseStatus The command result. `ok`
type GetUsersSuccessResponseStatus string

// GetVideoInfoResponse A subsonic-response element with a nested `videoInfo` element on success.
type GetVideoInfoResponse struct {
	SubsonicResponse *GetVideoInfoResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetVideoInfoResponse_SubsonicResponse defines model for GetVideoInfoResponse.SubsonicResponse.
type GetVideoInfoResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetVideoInfoSuccessResponse defines model for GetVideoInfoSuccessResponse.
type GetVideoInfoSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetVideoInfoSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`

	// VideoInfo videoInfo. TODO
	VideoInfo VideoInfo `json:"videoInfo"`
}

// GetVideoInfoSuccessResponseStatus The command result. `ok`
type GetVideoInfoSuccessResponseStatus string

// GetVideosResponse A subsonic-response element with a nested `videos` element on success.
type GetVideosResponse struct {
	SubsonicResponse *GetVideosResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// GetVideosResponse_SubsonicResponse defines model for GetVideosResponse.SubsonicResponse.
type GetVideosResponse_SubsonicResponse struct {
	union json.RawMessage
}

// GetVideosSuccessResponse defines model for GetVideosSuccessResponse.
type GetVideosSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status GetVideosSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`

	// Videos videos. TODO
	Videos Videos `json:"videos"`
}

// GetVideosSuccessResponseStatus The command result. `ok`
type GetVideosSuccessResponseStatus string

// Index An indexed artist list.
type Index struct {
	// Artist Artist list
	Artist *[]Artist `json:"artist,omitempty"`

	// Name Index name
	Name string `json:"name"`
}

// Indexes Artist list.
type Indexes struct {
	// Child Array of children
	Child *[]Child `json:"child,omitempty"`

	// IgnoredArticles The ignored articles
	IgnoredArticles string `json:"ignoredArticles"`

	// Index Indexed artists
	Index *[]Index `json:"index,omitempty"`

	// LastModified Last time the index was modified in milliseconds after January 1, 1970 UTC
	LastModified int `json:"lastModified"`

	// Shortcut Shortcut
	Shortcut *[]Artist `json:"shortcut,omitempty"`
}

// InternetRadioStation An internetRadioStation.
type InternetRadioStation struct {
	// HomePageUrl Genre name
	HomePageUrl *string `json:"homePageUrl,omitempty"`

	// Id The Id
	Id string `json:"id"`

	// Name The name
	Name string `json:"name"`

	// StreamUrl The streamUrl
	StreamUrl string `json:"streamUrl"`
}

// InternetRadioStations internetRadioStations.
type InternetRadioStations struct {
	// InternetRadioStation A list of internetRadioStation
	InternetRadioStation *[]InternetRadioStation `json:"internetRadioStation,omitempty"`
}

// ItemDate A date for a media item that may be just a year, or year-month, or full date.
type ItemDate struct {
	// Day The day (1-31)
	Day *int `json:"day,omitempty"`

	// Month The month (1-12)
	Month *int `json:"month,omitempty"`

	// Year The year
	Year *int `json:"year,omitempty"`
}

// ItemGenre A genre returned in list of genres for an item.
type ItemGenre struct {
	// Name Genre name
	Name string `json:"name"`
}

// JukeboxAction JukeBox action.
type JukeboxAction string

// JukeboxControlResponse A subsonic-response element with a nested :
//
// - jukeboxStatus for all actions but get
// - jukeboxPlaylist for get action
type JukeboxControlResponse struct {
	SubsonicResponse *JukeboxControlResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// JukeboxControlResponse_SubsonicResponse defines model for JukeboxControlResponse.SubsonicResponse.
type JukeboxControlResponse_SubsonicResponse struct {
	union json.RawMessage
}

// JukeboxControlSuccessResponse defines model for JukeboxControlSuccessResponse.
type JukeboxControlSuccessResponse struct {
	JukeboxPlaylist *JukeboxPlaylist `json:"jukeboxPlaylist,omitempty"`

	// JukeboxStatus jukeboxStatus.
	JukeboxStatus *JukeboxStatus `json:"jukeboxStatus,omitempty"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status JukeboxControlSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// JukeboxControlSuccessResponseStatus The command result. `ok`
type JukeboxControlSuccessResponseStatus string

// JukeboxPlaylist defines model for JukeboxPlaylist.
type JukeboxPlaylist struct {
	// CurrentIndex The current index of the song being played
	CurrentIndex int `json:"currentIndex"`

	// Entry The songs currently enqueued in the jukebox
	Entry *[]Child `json:"entry,omitempty"`

	// Playing Whether the queue is currently playing
	Playing bool `json:"playing"`

	// Position The current position of the track in seconds
	Position *int `json:"position,omitempty"`

	// Volume Volume, in a range of [0.0, 1.0]
	Volume int `json:"volume"`
}

// JukeboxStatus jukeboxStatus.
type JukeboxStatus struct {
	// CurrentIndex The current index of the song being played
	CurrentIndex int `json:"currentIndex"`

	// Playing Whether the queue is currently playing
	Playing bool `json:"playing"`

	// Position The current position of the track in seconds
	Position *int `json:"position,omitempty"`

	// Volume Volume, in a range of [0.0, 1.0]
	Volume int `json:"volume"`
}

// License getLicense result.
type License struct {
	// Email User email
	Email *string `json:"email,omitempty"`

	// LicenseExpires End of license date. [ISO 8601]
	LicenseExpires *time.Time `json:"licenseExpires,omitempty"`

	// TrialExpires End of trial date. [ISO 8601]
	TrialExpires *time.Time `json:"trialExpires,omitempty"`

	// Valid The status of the license
	Valid bool `json:"valid"`
}

// Limitation defines model for Limitation.
type Limitation struct {
	// Comparison The comparison operator.
	Comparison LimitationComparison `json:"comparison"`

	// Name The name of the limitation.
	Name LimitationName `json:"name"`

	// Required Whether this limitation is required.
	Required bool `json:"required"`

	// Values The values to compare against. For LessThanEqual and GreaterThanEqual only the first value will be used.
	Values []string `json:"values"`
}

// LimitationComparison The comparison operator.
type LimitationComparison string

// LimitationName The name of the limitation.
type LimitationName string

// Line One line of a song lyric
type Line struct {
	// Start The start time of the lyrics, relative to the start time of the track, in milliseconds. If this is not part of synced lyrics, start __must__ be omitted
	Start *float32 `json:"start,omitempty"`

	// Value The actual text of this line
	Value string `json:"value"`
}

// Lyrics Lyrics.
type Lyrics struct {
	// Artist The artist name
	Artist *string `json:"artist,omitempty"`

	// Title The song title
	Title *string `json:"title,omitempty"`

	// Value The lyrics
	Value string `json:"value"`
}

// LyricsList List of structured lyrics
type LyricsList struct {
	// StructuredLyrics Structured lyrics. There can be multiple lyrics of the same type with the same language
	StructuredLyrics *[]StructuredLyrics `json:"structuredLyrics,omitempty"`
}

// MediaType Note: If you support `musicBrainzId` you must support this field to ensure clients knows what the ID refers to.
type MediaType string

// MusicFolder MusicFolder.
type MusicFolder struct {
	// Id The id
	Id int `json:"id"`

	// Name The folder name
	Name *string `json:"name,omitempty"`
}

// MusicFolders MusicFolders.
type MusicFolders struct {
	// MusicFolder The folders
	MusicFolder *[]MusicFolder `json:"musicFolder,omitempty"`
}

// NewestPodcasts NewestPodcasts.
type NewestPodcasts struct {
	Episode *[]PodcastEpisode `json:"episode,omitempty"`
}

// NowPlaying nowPlaying.
type NowPlaying struct {
	// Entry The now playing entries
	Entry []NowPlayingEntry `json:"entry"`
}

// NowPlayingEntry defines model for NowPlayingEntry.
type NowPlayingEntry struct {
	// Album The album name.
	Album *string `json:"album,omitempty"`

	// AlbumArtists The list of all album artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
	AlbumArtists *[]ArtistID3 `json:"albumArtists,omitempty"`

	// AlbumId The corresponding album id
	AlbumId *string `json:"albumId,omitempty"`

	// Artist The artist name.
	Artist *string `json:"artist,omitempty"`

	// ArtistId The corresponding artist id
	ArtistId *string `json:"artistId,omitempty"`

	// Artists The list of all song artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
	Artists *[]ArtistID3 `json:"artists,omitempty"`

	// AverageRating The average rating of the media [1.0-5.0]
	AverageRating *float32 `json:"averageRating,omitempty"`

	// BitDepth The bit depth of the media.
	BitDepth *int `json:"bitDepth,omitempty"`

	// BitRate The bitrate of the media.
	BitRate *int `json:"bitRate,omitempty"`

	// BookmarkPosition The bookmark position in seconds
	BookmarkPosition *int `json:"bookmarkPosition,omitempty"`

	// Bpm The BPM of the song.
	Bpm *int `json:"bpm,omitempty"`

	// ChannelCount The number of channels of the media.
	ChannelCount *int `json:"channelCount,omitempty"`

	// Comment The comment tag of the song.
	Comment *string `json:"comment,omitempty"`

	// ContentType The mimeType of the media.
	ContentType *string `json:"contentType,omitempty"`

	// Contributors The list of all contributor artists of the song.
	Contributors *[]Contributor `json:"contributors,omitempty"`

	// CoverArt The coverArt id.
	CoverArt *string `json:"coverArt,omitempty"`

	// Created Date the media was created. [ISO 8601]
	Created *time.Time `json:"created,omitempty"`

	// DiscNumber The disc number.
	DiscNumber *int `json:"discNumber,omitempty"`

	// DisplayAlbumArtist The single value display album artist.
	DisplayAlbumArtist *string `json:"displayAlbumArtist,omitempty"`

	// DisplayArtist The single value display artist.
	DisplayArtist *string `json:"displayArtist,omitempty"`

	// DisplayComposer The single value display composer.
	DisplayComposer *string `json:"displayComposer,omitempty"`

	// Duration The duration of the media in seconds.
	Duration *int `json:"duration,omitempty"`

	// ExplicitStatus Returns “explicit”, “clean” or “”. (For songs extracted from tags “ITUNESADVISORY”: 1 = explicit, 2 = clean, MP4 “rtng”: 1 or 4 = explicit, 2 = clean. See `albumID3` for albums)
	ExplicitStatus *ExplicitStatus `json:"explicitStatus,omitempty"`

	// Genre The media genre
	Genre *string `json:"genre,omitempty"`

	// Genres The list of all genres of the song.
	Genres *[]ItemGenre `json:"genres,omitempty"`

	// Id The id of the media.
	Id string `json:"id"`

	// IsDir The media is a directory
	IsDir bool `json:"isDir"`

	// IsVideo Media is a video
	IsVideo *bool `json:"isVideo,omitempty"`

	// Isrc The track ISRC(s).
	Isrc *[]string `json:"isrc,omitempty"`

	// MediaType Note: If you support `musicBrainzId` you must support this field to ensure clients knows what the ID refers to.
	MediaType *MediaType `json:"mediaType,omitempty"`

	// MinutesAgo Last update
	MinutesAgo int `json:"minutesAgo"`

	// Moods The list of all moods of the song.
	Moods *[]string `json:"moods,omitempty"`

	// MusicBrainzId The track MusicBrainzID.
	MusicBrainzId *string `json:"musicBrainzId,omitempty"`

	// OriginalHeight The video original Height
	OriginalHeight *int `json:"originalHeight,omitempty"`

	// OriginalWidth The video original Width
	OriginalWidth *int `json:"originalWidth,omitempty"`

	// Parent The id of the parent (folder/album)
	Parent *string `json:"parent,omitempty"`

	// Path The full path of the media.
	Path *string `json:"path,omitempty"`

	// PlayCount The play count.
	PlayCount *int `json:"playCount,omitempty"`

	// Played Date the album was last played. [ISO 8601]
	Played *time.Time `json:"played,omitempty"`

	// PlayerId Player Id
	PlayerId int `json:"playerId"`

	// PlayerName Player name
	PlayerName *string `json:"playerName,omitempty"`

	// ReplayGain The replay gain data of the song.
	ReplayGain *ReplayGain `json:"replayGain,omitempty"`

	// SamplingRate The sampling rate of the media.
	SamplingRate *int `json:"samplingRate,omitempty"`

	// Size A file size of the media.
	Size *int `json:"size,omitempty"`

	// SortName The song sort name.
	SortName *string `json:"sortName,omitempty"`

	// Starred Date the media was starred. [ISO 8601]
	Starred *time.Time `json:"starred,omitempty"`

	// Suffix The file suffix of the media.
	Suffix *string `json:"suffix,omitempty"`

	// Title The media name.
	Title string `json:"title"`

	// Track The track number.
	Track *int `json:"track,omitempty"`

	// TranscodedContentType The transcoded mediaType if transcoding should happen.
	TranscodedContentType *string `json:"transcodedContentType,omitempty"`

	// TranscodedSuffix The file suffix of the transcoded media.
	TranscodedSuffix *string `json:"transcodedSuffix,omitempty"`

	// Type The generic type of media [music/podcast/audiobook/video]
	Type *GenericMediaType `json:"type,omitempty"`

	// UserRating The user rating of the media [1-5]
	UserRating *int `json:"userRating,omitempty"`

	// Username The username
	Username string `json:"username"`

	// Year The media year.
	Year *int `json:"year,omitempty"`
}

// OpenSubsonicExtension A supported OpenSubsonic API extension.
type OpenSubsonicExtension struct {
	// Name The name of the extension.
	Name string `json:"name"`

	// Versions The list of supported versions of the this extension.
	Versions []int `json:"versions"`
}

// PlayQueue NowPlayingEntry.
type PlayQueue struct {
	// Changed Date modified [ISO 8601]
	Changed time.Time `json:"changed"`

	// ChangedBy Name of client app
	ChangedBy string `json:"changedBy"`

	// Current ID of currently playing track. This will be provided if one or more entries exists
	Current *string `json:"current,omitempty"`

	// Entry The list of songs in the queue
	Entry *[]Child `json:"entry,omitempty"`

	// Position Position in milliseconds of currently playing track. If not provided, treat this value as 0
	Position *int `json:"position,omitempty"`

	// Username The user this queue belongs to
	Username string `json:"username"`
}

// PlayQueueByIndex NowPlayingEntry with queue index.
type PlayQueueByIndex struct {
	// Changed Date modified [ISO 8601]
	Changed time.Time `json:"changed"`

	// ChangedBy Name of client app
	ChangedBy string `json:"changedBy"`

	// CurrentIndex Index of currently playing track.  This must be provided if one or more entries exists
	CurrentIndex *int `json:"currentIndex,omitempty"`

	// Entry The list of songs in the queue
	Entry *[]Child `json:"entry,omitempty"`

	// Position Position in milliseconds of currently playing track. If not provided, treat this value as 0
	Position *int `json:"position,omitempty"`

	// Username The user this queue belongs to
	Username string `json:"username"`
}

// Playlist Playlist.
type Playlist struct {
	// AllowedUser A list of allowed usernames
	AllowedUser *[]string `json:"allowedUser,omitempty"`

	// Changed Last changed date [ISO 8601]
	Changed time.Time `json:"changed"`

	// Comment A comment
	Comment *string `json:"comment,omitempty"`

	// CoverArt A cover Art Id
	CoverArt *string `json:"coverArt,omitempty"`

	// Created Creation date [ISO 8601]
	Created time.Time `json:"created"`

	// Duration Playlist duration in seconds
	Duration int `json:"duration"`

	// Id Id of the playlist
	Id string `json:"id"`

	// Name Name of the playlist
	Name string `json:"name"`

	// Owner Owner of the playlist
	Owner *string `json:"owner,omitempty"`

	// Public Is the playlist public
	Public *bool `json:"public,omitempty"`

	// SongCount number of songs
	SongCount int `json:"songCount"`
}

// PlaylistWithSongs defines model for PlaylistWithSongs.
type PlaylistWithSongs struct {
	// AllowedUser A list of allowed usernames
	AllowedUser *[]string `json:"allowedUser,omitempty"`

	// Changed Last changed date [ISO 8601]
	Changed time.Time `json:"changed"`

	// Comment A comment
	Comment *string `json:"comment,omitempty"`

	// CoverArt A cover Art Id
	CoverArt *string `json:"coverArt,omitempty"`

	// Created Creation date [ISO 8601]
	Created time.Time `json:"created"`

	// Duration Playlist duration in seconds
	Duration int `json:"duration"`

	// Entry The list of songs
	Entry *[]Child `json:"entry,omitempty"`

	// Id Id of the playlist
	Id string `json:"id"`

	// Name Name of the playlist
	Name string `json:"name"`

	// Owner Owner of the playlist
	Owner *string `json:"owner,omitempty"`

	// Public Is the playlist public
	Public *bool `json:"public,omitempty"`

	// SongCount number of songs
	SongCount int `json:"songCount"`
}

// Playlists Playlists.
type Playlists struct {
	// Playlist The playlists
	Playlist *[]Playlist `json:"playlist,omitempty"`
}

// PodcastChannel A Podcast channel
type PodcastChannel struct {
	// CoverArt ID used for retrieving cover art
	CoverArt *string `json:"coverArt,omitempty"`

	// Description The channel description
	Description *string `json:"description,omitempty"`

	// Episode Podcast episodes with this channel
	Episode *[]PodcastEpisode `json:"episode,omitempty"`

	// ErrorMessage An error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Id The channel ID
	Id string `json:"id"`

	// OriginalImageUrl URL for original image of podcast channel
	OriginalImageUrl *string `json:"originalImageUrl,omitempty"`

	// Status An enumeration of possible podcast statuses
	Status PodcastStatus `json:"status"`

	// Title The channel title
	Title *string `json:"title,omitempty"`

	// Url Podcast channel URL
	Url string `json:"url"`
}

// PodcastEpisode defines model for PodcastEpisode.
type PodcastEpisode struct {
	// Album The album name.
	Album *string `json:"album,omitempty"`

	// AlbumArtists The list of all album artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
	AlbumArtists *[]ArtistID3 `json:"albumArtists,omitempty"`

	// AlbumId The corresponding album id
	AlbumId *string `json:"albumId,omitempty"`

	// Artist The artist name.
	Artist *string `json:"artist,omitempty"`

	// ArtistId The corresponding artist id
	ArtistId *string `json:"artistId,omitempty"`

	// Artists The list of all song artists of the song. (Note: Only the required `ArtistID3` fields should be returned by default)
	Artists *[]ArtistID3 `json:"artists,omitempty"`

	// AverageRating The average rating of the media [1.0-5.0]
	AverageRating *float32 `json:"averageRating,omitempty"`

	// BitDepth The bit depth of the media.
	BitDepth *int `json:"bitDepth,omitempty"`

	// BitRate The bitrate of the media.
	BitRate *int `json:"bitRate,omitempty"`

	// BookmarkPosition The bookmark position in seconds
	BookmarkPosition *int `json:"bookmarkPosition,omitempty"`

	// Bpm The BPM of the song.
	Bpm *int `json:"bpm,omitempty"`

	// ChannelCount The number of channels of the media.
	ChannelCount *int `json:"channelCount,omitempty"`

	// ChannelId TID of the podcast channel
	ChannelId string `json:"channelId"`

	// Comment The comment tag of the song.
	Comment *string `json:"comment,omitempty"`

	// ContentType The mimeType of the media.
	ContentType *string `json:"contentType,omitempty"`

	// Contributors The list of all contributor artists of the song.
	Contributors *[]Contributor `json:"contributors,omitempty"`

	// CoverArt The coverArt id.
	CoverArt *string `json:"coverArt,omitempty"`

	// Created Date the media was created. [ISO 8601]
	Created *time.Time `json:"created,omitempty"`

	// Description Episode description
	Description *string `json:"description,omitempty"`

	// DiscNumber The disc number.
	DiscNumber *int `json:"discNumber,omitempty"`

	// DisplayAlbumArtist The single value display album artist.
	DisplayAlbumArtist *string `json:"displayAlbumArtist,omitempty"`

	// DisplayArtist The single value display artist.
	DisplayArtist *string `json:"displayArtist,omitempty"`

	// DisplayComposer The single value display composer.
	DisplayComposer *string `json:"displayComposer,omitempty"`

	// Duration The duration of the media in seconds.
	Duration *int `json:"duration,omitempty"`

	// ExplicitStatus Returns “explicit”, “clean” or “”. (For songs extracted from tags “ITUNESADVISORY”: 1 = explicit, 2 = clean, MP4 “rtng”: 1 or 4 = explicit, 2 = clean. See `albumID3` for albums)
	ExplicitStatus *ExplicitStatus `json:"explicitStatus,omitempty"`

	// Genre The media genre
	Genre *string `json:"genre,omitempty"`

	// Genres The list of all genres of the song.
	Genres *[]ItemGenre `json:"genres,omitempty"`

	// Id The id of the media.
	Id string `json:"id"`

	// IsDir The media is a directory
	IsDir bool `json:"isDir"`

	// IsVideo Media is a video
	IsVideo *bool `json:"isVideo,omitempty"`

	// Isrc The track ISRC(s).
	Isrc *[]string `json:"isrc,omitempty"`

	// MediaType Note: If you support `musicBrainzId` you must support this field to ensure clients knows what the ID refers to.
	MediaType *MediaType `json:"mediaType,omitempty"`

	// Moods The list of all moods of the song.
	Moods *[]string `json:"moods,omitempty"`

	// MusicBrainzId The track MusicBrainzID.
	MusicBrainzId *string `json:"musicBrainzId,omitempty"`

	// OriginalHeight The video original Height
	OriginalHeight *int `json:"originalHeight,omitempty"`

	// OriginalWidth The video original Width
	OriginalWidth *int `json:"originalWidth,omitempty"`

	// Parent The id of the parent (folder/album)
	Parent *string `json:"parent,omitempty"`

	// Path The full path of the media.
	Path *string `json:"path,omitempty"`

	// PlayCount The play count.
	PlayCount *int `json:"playCount,omitempty"`

	// Played Date the album was last played. [ISO 8601]
	Played *time.Time `json:"played,omitempty"`

	// PublishDate Date the episode was published [ISO 8601]
	PublishDate *time.Time `json:"publishDate,omitempty"`

	// ReplayGain The replay gain data of the song.
	ReplayGain *ReplayGain `json:"replayGain,omitempty"`

	// SamplingRate The sampling rate of the media.
	SamplingRate *int `json:"samplingRate,omitempty"`

	// Size A file size of the media.
	Size *int `json:"size,omitempty"`

	// SortName The song sort name.
	SortName *string `json:"sortName,omitempty"`

	// Starred Date the media was starred. [ISO 8601]
	Starred *time.Time `json:"starred,omitempty"`

	// Status An enumeration of possible podcast statuses
	Status PodcastStatus `json:"status"`

	// StreamId ID used for streaming podcast
	StreamId *string `json:"streamId,omitempty"`

	// Suffix The file suffix of the media.
	Suffix *string `json:"suffix,omitempty"`

	// Title The media name.
	Title string `json:"title"`

	// Track The track number.
	Track *int `json:"track,omitempty"`

	// TranscodedContentType The transcoded mediaType if transcoding should happen.
	TranscodedContentType *string `json:"transcodedContentType,omitempty"`

	// TranscodedSuffix The file suffix of the transcoded media.
	TranscodedSuffix *string `json:"transcodedSuffix,omitempty"`

	// Type The generic type of media [music/podcast/audiobook/video]
	Type *GenericMediaType `json:"type,omitempty"`

	// UserRating The user rating of the media [1-5]
	UserRating *int `json:"userRating,omitempty"`

	// Year The media year.
	Year *int `json:"year,omitempty"`
}

// PodcastStatus An enumeration of possible podcast statuses
type PodcastStatus string

// Podcasts Podcasts.
type Podcasts struct {
	// Channel Podcast channel(s)
	Channel *[]PodcastChannel `json:"channel,omitempty"`
}

// RecordLabel A record label for an album.
type RecordLabel struct {
	Name string `json:"name"`
}

// ReplayGain The replay gain data of a song. Note: If the data is not present the field must be ommited in the answer. (But the replayGain field on Child must always be present)
type ReplayGain struct {
	// AlbumGain The album replay gain value. (In Db)
	AlbumGain *float32 `json:"albumGain,omitempty"`

	// AlbumPeak The album peak value. (Must be positive)
	AlbumPeak *float32 `json:"albumPeak,omitempty"`

	// BaseGain The base gain value. (In Db) (Ogg Opus Output Gain for example)
	BaseGain *float32 `json:"baseGain,omitempty"`

	// FallbackGain An optional fallback gain that clients should apply when the corresponding gain value is missing. (Can be computed from the tracks or exposed as an user setting.)
	FallbackGain *float32 `json:"fallbackGain,omitempty"`

	// TrackGain The track replay gain value. (In Db)
	TrackGain *float32 `json:"trackGain,omitempty"`

	// TrackPeak The track peak value. (Must be positive)
	TrackPeak *float32 `json:"trackPeak,omitempty"`
}

// ScanStatus Scan status information.
type ScanStatus struct {
	// Count Scanned item count
	Count *int `json:"count,omitempty"`

	// Scanning The status of the scan
	Scanning bool `json:"scanning"`
}

// Search2Response A subsonic-response element with a nested `searchResult2` element on success.
type Search2Response struct {
	SubsonicResponse *Search2Response_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// Search2Response_SubsonicResponse defines model for Search2Response.SubsonicResponse.
type Search2Response_SubsonicResponse struct {
	union json.RawMessage
}

// Search2SuccessResponse defines model for Search2SuccessResponse.
type Search2SuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// SearchResult2 searchResult2
	SearchResult2 SearchResult2 `json:"searchResult2"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status Search2SuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// Search2SuccessResponseStatus The command result. `ok`
type Search2SuccessResponseStatus string

// Search3Response A subsonic-response element with a nested `searchResult3` element on success.
type Search3Response struct {
	SubsonicResponse *Search3Response_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// Search3Response_SubsonicResponse defines model for Search3Response.SubsonicResponse.
type Search3Response_SubsonicResponse struct {
	union json.RawMessage
}

// Search3SuccessResponse defines model for Search3SuccessResponse.
type Search3SuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// SearchResult3 searchResult3
	SearchResult3 SearchResult3 `json:"searchResult3"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status Search3SuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// Search3SuccessResponseStatus The command result. `ok`
type Search3SuccessResponseStatus string

// SearchResponse A subsonic-response element with a nested `searchResult` element on success.
type SearchResponse struct {
	SubsonicResponse *SearchResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// SearchResponse_SubsonicResponse defines model for SearchResponse.SubsonicResponse.
type SearchResponse_SubsonicResponse struct {
	union json.RawMessage
}

// SearchResult searchResult. TODO
type SearchResult = map[string]interface{}

// SearchResult2 searchResult2
type SearchResult2 struct {
	// Album Starred albums
	Album *[]Child `json:"album,omitempty"`

	// Artist Starred artists
	Artist *[]Artist `json:"artist,omitempty"`

	// Song Starred songs
	Song *[]Child `json:"song,omitempty"`
}

// SearchResult3 searchResult3
type SearchResult3 struct {
	// Album Matching albums
	Album *[]AlbumID3 `json:"album,omitempty"`

	// Artist Matching artists
	Artist *[]ArtistID3 `json:"artist,omitempty"`

	// Song Matching songs
	Song *[]Child `json:"song,omitempty"`
}

// SearchSuccessResponse defines model for SearchSuccessResponse.
type SearchSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// SearchResult searchResult. TODO
	SearchResult SearchResult `json:"searchResult"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status SearchSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// SearchSuccessResponseStatus The command result. `ok`
type SearchSuccessResponseStatus string

// Share Share.
type Share struct {
	// Created Creation date [ISO 8601]
	Created time.Time `json:"created"`

	// Description A description
	Description *string `json:"description,omitempty"`

	// Entry A list of share
	Entry *[]Child `json:"entry,omitempty"`

	// Expires Share expiration [ISO 8601]
	Expires *time.Time `json:"expires,omitempty"`

	// Id The share Id
	Id string `json:"id"`

	// LastVisited Last visit [ISO 8601]
	LastVisited *time.Time `json:"lastVisited,omitempty"`

	// Url The share url
	Url string `json:"url"`

	// Username The username
	Username string `json:"username"`

	// VisitCount Visit count
	VisitCount int `json:"visitCount"`
}

// Shares Shares.
type Shares struct {
	// Share A list of share
	Share *[]Share `json:"share,omitempty"`
}

// SimilarSongs SimilarSongs list.
type SimilarSongs struct {
	// Song List of songs
	Song *[]Child `json:"song,omitempty"`
}

// SimilarSongs2 SimilarSongs2 list.
type SimilarSongs2 struct {
	// Song List of songs
	Song *[]Child `json:"song,omitempty"`
}

// Songs Songs list.
type Songs struct {
	// Song List of songs
	Song *[]Child `json:"song,omitempty"`
}

// Starred starred.
type Starred struct {
	// Album Starred albums
	Album *[]Child `json:"album,omitempty"`

	// Artist Starred artists
	Artist *[]Artist `json:"artist,omitempty"`

	// Song Starred songs
	Song *[]Child `json:"song,omitempty"`
}

// Starred2 Starred2.
type Starred2 struct {
	// Album Starred albums
	Album *[]AlbumID3 `json:"album,omitempty"`

	// Artist Starred artists
	Artist *[]ArtistID3 `json:"artist,omitempty"`

	// Song Starred songs
	Song *[]Child `json:"song,omitempty"`
}

// StartScanResponse A subsonic-response element with a nested `scanStatus` element on success.
type StartScanResponse struct {
	SubsonicResponse *StartScanResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// StartScanResponse_SubsonicResponse defines model for StartScanResponse.SubsonicResponse.
type StartScanResponse_SubsonicResponse struct {
	union json.RawMessage
}

// StartScanSuccessResponse defines model for StartScanSuccessResponse.
type StartScanSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ScanStatus Scan status information.
	ScanStatus ScanStatus `json:"scanStatus"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status StartScanSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// StartScanSuccessResponseStatus The command result. `ok`
type StartScanSuccessResponseStatus string

// StreamDetails defines model for StreamDetails.
type StreamDetails struct {
	AudioBitdepth   *int                  `json:"audioBitdepth,omitempty"`
	AudioBitrate    *int                  `json:"audioBitrate,omitempty"`
	AudioChannels   *int                  `json:"audioChannels,omitempty"`
	AudioProfile    *string               `json:"audioProfile,omitempty"`
	AudioSamplerate *int                  `json:"audioSamplerate,omitempty"`
	Codec           string                `json:"codec"`
	Container       string                `json:"container"`
	Protocol        StreamDetailsProtocol `json:"protocol"`
}

// StreamDetailsProtocol defines model for StreamDetails.Protocol.
type StreamDetailsProtocol string

// StructuredLyrics Structured lyrics
type StructuredLyrics struct {
	// DisplayArtist The artist name to display. This could be the localized name, or any other value
	DisplayArtist *string `json:"displayArtist,omitempty"`

	// DisplayTitle The title to display. This could be the song title (localized), or any other value
	DisplayTitle *string `json:"displayTitle,omitempty"`

	// Lang The lyrics language (ideally ISO 639). If the language is unknown (e.g. lrc file), the server must return `und` (ISO standard) or `xxx` (common value for taggers). Ideally, the server will return lang as an ISO 639 (2/3) code. However, tagged files and external lyrics can come with any value as a potential language code, so clients should take care when displaying lang.
	//
	// Furthermore, there is special behavior for the value xxx. While not an ISO code, it is commonly used by taggers and other parsing software. Clients should treat xxx as not having a specified language (equivalent to the und code).
	Lang string `json:"lang"`

	// Line The actual lyrics. Ordered by start time (synced) or appearance order (unsynced)
	Line []Line `json:"line"`

	// Offset The offset to apply to all lyrics, in milliseconds. Positive means lyrics appear sooner, negative means later. If not included, the offset must be assumed to be 0
	Offset *float32 `json:"offset,omitempty"`

	// Synced True if the lyrics are synced, false otherwise
	Synced bool `json:"synced"`
}

// SubsonicBaseResponse defines model for SubsonicBaseResponse.
type SubsonicBaseResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// SubsonicFailureResponse defines model for SubsonicFailureResponse.
type SubsonicFailureResponse struct {
	Error Error `json:"error"`

	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `failed`
	Status SubsonicFailureResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// SubsonicFailureResponseStatus The command result. `failed`
type SubsonicFailureResponseStatus string

// SubsonicResponse Common answer wrapper.
type SubsonicResponse struct {
	SubsonicResponse *SubsonicResponse_SubsonicResponse `json:"subsonic-response,omitempty"`
}

// SubsonicResponse_SubsonicResponse defines model for SubsonicResponse.SubsonicResponse.
type SubsonicResponse_SubsonicResponse struct {
	union json.RawMessage
}

// SubsonicSuccessResponse defines model for SubsonicSuccessResponse.
type SubsonicSuccessResponse struct {
	// OpenSubsonic Must return true if the server support OpenSubsonic API v1
	OpenSubsonic bool `json:"openSubsonic"`

	// ServerVersion The server version.
	ServerVersion string `json:"serverVersion"`

	// Status The command result. `ok`
	Status SubsonicSuccessResponseStatus `json:"status"`

	// Type The server actual name. [Ex: Navidrome or gonic]
	Type string `json:"type"`

	// Version The server supported Subsonic API version.
	Version string `json:"version"`
}

// SubsonicSuccessResponseStatus The command result. `ok`
type SubsonicSuccessResponseStatus string

// TokenInfo Information about an API key
type TokenInfo struct {
	// Username Username associated with token
	Username string `json:"username"`
}

// TopSongs TopSongs list.
type TopSongs struct {
	// Song List of songs
	Song *[]Child `json:"song,omitempty"`
}

// TranscodeDecision defines model for TranscodeDecision.
type TranscodeDecision struct {
	CanDirectPlay   bool           `json:"canDirectPlay"`
	CanTranscode    bool           `json:"canTranscode"`
	ErrorReason     *string        `json:"errorReason,omitempty"`
	SourceStream    *StreamDetails `json:"sourceStream,omitempty"`
	TranscodeParams *string        `json:"transcodeParams,omitempty"`
	TranscodeReason *[]string      `json:"transcodeReason,omitempty"`
	TranscodeStream *StreamDetails `json:"transcodeStream,omitempty"`
}

// TranscodingProfile defines model for TranscodingProfile.
type TranscodingProfile struct {
	AudioCodec       string                     `json:"audioCodec"`
	Container        string                     `json:"container"`
	MaxAudioChannels *int                       `json:"maxAudioChannels,omitempty"`
	Protocol         TranscodingProfileProtocol `json:"protocol"`
}

// TranscodingProfileProtocol defines model for TranscodingProfile.Protocol.
type TranscodingProfileProtocol string

// User user.
type User struct {
	// AdminRole Whether the user is an admin
	AdminRole bool `json:"adminRole"`

	// AvatarLastChanged Last time the avatar was changed [ISO 8601]
	AvatarLastChanged *time.Time `json:"avatarLastChanged,omitempty"`

	// CommentRole Whether the user can create comments
	CommentRole bool `json:"commentRole"`

	// CoverArtRole Whether the user can get cover art
	CoverArtRole bool `json:"coverArtRole"`

	// DownloadRole Whether the user can download
	DownloadRole bool `json:"downloadRole"`

	// Folder Folder ID(s)
	Folder *[]int `json:"folder,omitempty"`

	// JukeboxRole Whether the user can control the jukebox
	JukeboxRole bool `json:"jukeboxRole"`
	MaxBitRate  *int `json:"maxBitRate,omitempty"`

	// PlaylistRole Whether the user can create playlists
	PlaylistRole bool `json:"playlistRole"`

	// PodcastRole Whether the user can create/refresh podcasts
	PodcastRole bool `json:"podcastRole"`

	// ScrobblingEnabled Scrobbling enabled
	ScrobblingEnabled bool `json:"scrobblingEnabled"`

	// SettingsRole Whether the user is can edit settings
	SettingsRole bool `json:"settingsRole"`

	// ShareRole Whether the user can create a stream
	ShareRole bool `json:"shareRole"`

	// StreamRole Whether the user can stream
	StreamRole bool `json:"streamRole"`

	// UploadRole Whether the user can upload
	UploadRole bool `json:"uploadRole"`

	// Username Username
	Username string `json:"username"`

	// VideoConversionRole Whether the user can convert videos
	VideoConversionRole bool `json:"videoConversionRole"`
}

// Users users.
type Users struct {
	// User Array of users
	User *[]User `json:"user,omitempty"`
}

// VideoInfo videoInfo. TODO
type VideoInfo = map[string]interface{}

// Videos videos. TODO
type Videos = map[string]interface{}

// EmptySubsonicResponse Common answer wrapper.
type EmptySubsonicResponse = SubsonicResponse

// TranscodeDecisionResponse defines model for TranscodeDecisionResponse.
type TranscodeDecisionResponse struct {
	TranscodeDecision *TranscodeDecision `json:"transcodeDecision,omitempty"`
}

// GetAddChatMessageParams defines parameters for GetAddChatMessage.
type GetAddChatMessageParams struct {
	// Message The chat message.
	Message string `form:"message" json:"message"`
}

// PostAddChatMessageFormdataBody defines parameters for PostAddChatMessage.
type PostAddChatMessageFormdataBody struct {
	// Message The chat message.
	Message string `form:"message" json:"message"`
}

// ChangePasswordParams defines parameters for ChangePassword.
type ChangePasswordParams struct {
	// Username The name of the user which should change its password.
	Username string `form:"username" json:"username"`

	// Password The new password of the new user, either in clear text of hex-encoded (see above).
	Password string `form:"password" json:"password"`
}

// PostChangePasswordFormdataBody defines parameters for PostChangePassword.
type PostChangePasswordFormdataBody struct {
	// Password The new password of the new user, either in clear text of hex-encoded (see above).
	Password string `form:"password" json:"password"`

	// Username The name of the user which should change its password.
	Username string `form:"username" json:"username"`
}

// CreateBookmarkParams defines parameters for CreateBookmark.
type CreateBookmarkParams struct {
	// Id ID of the media file to bookmark. If a bookmark already exists for this file it will be overwritten.
	Id string `form:"id" json:"id"`

	// Position The position (in milliseconds) within the media file.
	Position int `form:"position" json:"position"`

	// Comment A user-defined comment.
	Comment *string `form:"comment,omitempty" json:"comment,omitempty"`
}

// PostCreateBookmarkFormdataBody defines parameters for PostCreateBookmark.
type PostCreateBookmarkFormdataBody struct {
	// Comment A user-defined comment.
	Comment *string `form:"comment,omitempty" json:"comment,omitempty"`

	// Id ID of the media file to bookmark. If a bookmark already exists for this file it will be overwritten.
	Id string `form:"id" json:"id"`

	// Position The position (in milliseconds) within the media file.
	Position int `form:"position" json:"position"`
}

// CreateInternetRadioStationParams defines parameters for CreateInternetRadioStation.
type CreateInternetRadioStationParams struct {
	// StreamUrl The stream URL for the station.
	StreamUrl string `form:"streamUrl" json:"streamUrl"`

	// Name The station name.
	Name string `form:"name" json:"name"`

	// HomepageUrl The home page URL for the station.
	HomepageUrl *string `form:"homepageUrl,omitempty" json:"homepageUrl,omitempty"`
}

// PostCreateInternetRadioStationFormdataBody defines parameters for PostCreateInternetRadioStation.
type PostCreateInternetRadioStationFormdataBody struct {
	// HomepageUrl The home page URL for the station.
	HomepageUrl *string `form:"homepageUrl,omitempty" json:"homepageUrl,omitempty"`

	// Name The station name.
	Name string `form:"name" json:"name"`

	// StreamUrl The stream URL for the station.
	StreamUrl string `form:"streamUrl" json:"streamUrl"`
}

// CreatePlaylistParams defines parameters for CreatePlaylist.
type CreatePlaylistParams struct {
	// PlaylistId The playlist ID. Required if updating an existing playlist.
	PlaylistId *string `form:"playlistId,omitempty" json:"playlistId,omitempty"`

	// Name The human-readable name of the playlist. Required if creating a new playlist.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// SongId ID of a song in the playlist. Use one `songId` parameter for each song in the playlist.
	SongId *[]string `form:"songId,omitempty" json:"songId,omitempty"`
}

// PostCreatePlaylistFormdataBody defines parameters for PostCreatePlaylist.
type PostCreatePlaylistFormdataBody struct {
	// Name The human-readable name of the playlist. Required if creating a new playlist.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PlaylistId The playlist ID. Required if updating an existing playlist.
	PlaylistId *string `form:"playlistId,omitempty" json:"playlistId,omitempty"`

	// SongId ID of a song in the playlist. Use one `songId` parameter for each song in the playlist.
	SongId *[]string `form:"songId,omitempty" json:"songId,omitempty"`
}

// CreatePodcastChannelParams defines parameters for CreatePodcastChannel.
type CreatePodcastChannelParams struct {
	// Url The URL of the Podcast to add.
	Url string `form:"url" json:"url"`
}

// PostCreatePodcastChannelFormdataBody defines parameters for PostCreatePodcastChannel.
type PostCreatePodcastChannelFormdataBody struct {
	// Url The URL of the Podcast to add.
	Url string `form:"url" json:"url"`
}

// CreateShareParams defines parameters for CreateShare.
type CreateShareParams struct {
	// Id ID of a song, album or video to share. Use one id parameter for each entry to share.
	Id []string `form:"id" json:"id"`

	// Description A user-defined description that will be displayed to people visiting the shared media.
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Expires The time at which the share expires. Given as milliseconds since 1970.
	Expires *int `form:"expires,omitempty" json:"expires,omitempty"`
}

// PostCreateShareFormdataBody defines parameters for PostCreateShare.
type PostCreateShareFormdataBody struct {
	// Description A user-defined description that will be displayed to people visiting the shared media.
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Expires The time at which the share expires. Given as milliseconds since 1970.
	Expires *int `form:"expires,omitempty" json:"expires,omitempty"`

	// Id ID of a song, album or video to share. Use one id parameter for each entry to share.
	Id []string `form:"id" json:"id"`
}

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {
	// Username The name of the new user.
	Username string `form:"username" json:"username"`

	// Password The password of the new user, either in clear text of hex-encoded (see above).
	Password string `form:"password" json:"password"`

	// Email The email address of the new user.
	Email string `form:"email" json:"email"`

	// LdapAuthenticated Whether the user is authenticated in LDAP.
	LdapAuthenticated *bool `form:"ldapAuthenticated,omitempty" json:"ldapAuthenticated,omitempty"`

	// AdminRole Whether the user is administrator.
	AdminRole *bool `form:"adminRole,omitempty" json:"adminRole,omitempty"`

	// SettingsRole Whether the user is allowed to change personal settings and password.
	SettingsRole *bool `form:"settingsRole,omitempty" json:"settingsRole,omitempty"`

	// StreamRole Whether the user is allowed to play files.
	StreamRole *bool `form:"streamRole,omitempty" json:"streamRole,omitempty"`

	// JukeboxRole Whether the user is allowed to play files in jukebox mode.
	JukeboxRole *bool `form:"jukeboxRole,omitempty" json:"jukeboxRole,omitempty"`

	// DownloadRole Whether the user is allowed to download files.
	DownloadRole *bool `form:"downloadRole,omitempty" json:"downloadRole,omitempty"`

	// UploadRole Whether the user is allowed to upload files.
	UploadRole *bool `form:"uploadRole,omitempty" json:"uploadRole,omitempty"`

	// PlaylistRole Whether the user is allowed to create and delete playlists. Since 1.8.0, changing this role has no effect.
	PlaylistRole *bool `form:"playlistRole,omitempty" json:"playlistRole,omitempty"`

	// CoverArtRole Whether the user is allowed to change cover art and tags.
	CoverArtRole *bool `form:"coverArtRole,omitempty" json:"coverArtRole,omitempty"`

	// CommentRole Whether the user is allowed to create and edit comments and ratings.
	CommentRole *bool `form:"commentRole,omitempty" json:"commentRole,omitempty"`

	// PodcastRole Whether the user is allowed to administrate Podcasts.
	PodcastRole *bool `form:"podcastRole,omitempty" json:"podcastRole,omitempty"`

	// ShareRole (Since 1.8.0) Whether the user is allowed to share files with anyone.
	ShareRole *bool `form:"shareRole,omitempty" json:"shareRole,omitempty"`

	// VideoConversionRole (Since 1.15.0) Whether the user is allowed to start video conversions.
	VideoConversionRole *bool `form:"videoConversionRole,omitempty" json:"videoConversionRole,omitempty"`

	// MusicFolderId (Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder. Default all folders.
	MusicFolderId *[]string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostCreateUserFormdataBody defines parameters for PostCreateUser.
type PostCreateUserFormdataBody struct {
	// AdminRole Whether the user is administrator.
	AdminRole *bool `form:"adminRole,omitempty" json:"adminRole,omitempty"`

	// CommentRole Whether the user is allowed to create and edit comments and ratings.
	CommentRole *bool `form:"commentRole,omitempty" json:"commentRole,omitempty"`

	// CoverArtRole Whether the user is allowed to change cover art and tags.
	CoverArtRole *bool `form:"coverArtRole,omitempty" json:"coverArtRole,omitempty"`

	// DownloadRole Whether the user is allowed to download files.
	DownloadRole *bool `form:"downloadRole,omitempty" json:"downloadRole,omitempty"`

	// Email The email address of the new user.
	Email string `form:"email" json:"email"`

	// JukeboxRole Whether the user is allowed to play files in jukebox mode.
	JukeboxRole *bool `form:"jukeboxRole,omitempty" json:"jukeboxRole,omitempty"`

	// LdapAuthenticated Whether the user is authenticated in LDAP.
	LdapAuthenticated *bool `form:"ldapAuthenticated,omitempty" json:"ldapAuthenticated,omitempty"`

	// MusicFolderId (Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder. Default all folders.
	MusicFolderId *[]string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`

	// Password The password of the new user, either in clear text or hex-encoded.
	Password string `form:"password" json:"password"`

	// PlaylistRole Whether the user is allowed to create and delete playlists. Since 1.8.0, changing this role has no effect.
	PlaylistRole *bool `form:"playlistRole,omitempty" json:"playlistRole,omitempty"`

	// PodcastRole Whether the user is allowed to administrate Podcasts.
	PodcastRole *bool `form:"podcastRole,omitempty" json:"podcastRole,omitempty"`

	// SettingsRole Whether the user is allowed to change personal settings and password.
	SettingsRole *bool `form:"settingsRole,omitempty" json:"settingsRole,omitempty"`

	// ShareRole (Since 1.8.0) Whether the user is allowed to share files with anyone.
	ShareRole *bool `form:"shareRole,omitempty" json:"shareRole,omitempty"`

	// StreamRole Whether the user is allowed to play files.
	StreamRole *bool `form:"streamRole,omitempty" json:"streamRole,omitempty"`

	// UploadRole Whether the user is allowed to upload files.
	UploadRole *bool `form:"uploadRole,omitempty" json:"uploadRole,omitempty"`

	// Username The name of the new user.
	Username string `form:"username" json:"username"`

	// VideoConversionRole (Since 1.15.0) Whether the user is allowed to start video conversions.
	VideoConversionRole *bool `form:"videoConversionRole,omitempty" json:"videoConversionRole,omitempty"`
}

// DeleteBookmarkParams defines parameters for DeleteBookmark.
type DeleteBookmarkParams struct {
	// Id ID of the media file for which to delete the bookmark. Other users’ bookmarks are not affected.
	Id string `form:"id" json:"id"`
}

// PostDeleteBookmarkFormdataBody defines parameters for PostDeleteBookmark.
type PostDeleteBookmarkFormdataBody struct {
	// Id ID of the media file for which to delete the bookmark. Other users’ bookmarks are not affected.
	Id string `form:"id" json:"id"`
}

// DeleteInternetRadioStationParams defines parameters for DeleteInternetRadioStation.
type DeleteInternetRadioStationParams struct {
	// Id The ID for the station.
	Id string `form:"id" json:"id"`
}

// PostDeleteInternetRadioStationFormdataBody defines parameters for PostDeleteInternetRadioStation.
type PostDeleteInternetRadioStationFormdataBody struct {
	// Id The ID for the station.
	Id string `form:"id" json:"id"`
}

// DeletePlaylistParams defines parameters for DeletePlaylist.
type DeletePlaylistParams struct {
	// Id ID of the playlist to delete, as obtained by `getPlaylists`.
	Id string `form:"id" json:"id"`
}

// PostDeletePlaylistFormdataBody defines parameters for PostDeletePlaylist.
type PostDeletePlaylistFormdataBody struct {
	// Id ID of the playlist to delete, as obtained by `getPlaylists`.
	Id string `form:"id" json:"id"`
}

// DeletePodcastChannelParams defines parameters for DeletePodcastChannel.
type DeletePodcastChannelParams struct {
	// Id The ID of the Podcast channel to delete.
	Id string `form:"id" json:"id"`
}

// PostDeletePodcastChannelFormdataBody defines parameters for PostDeletePodcastChannel.
type PostDeletePodcastChannelFormdataBody struct {
	// Id The ID of the Podcast channel to delete.
	Id string `form:"id" json:"id"`
}

// DeletePodcastEpisodeParams defines parameters for DeletePodcastEpisode.
type DeletePodcastEpisodeParams struct {
	// Id The ID of the Podcast episode to delete.
	Id string `form:"id" json:"id"`
}

// PostDeletePodcastEpisodeFormdataBody defines parameters for PostDeletePodcastEpisode.
type PostDeletePodcastEpisodeFormdataBody struct {
	// Id The ID of the Podcast episode to delete.
	Id string `form:"id" json:"id"`
}

// DeleteShareParams defines parameters for DeleteShare.
type DeleteShareParams struct {
	// Id ID of the share to delete.
	Id string `form:"id" json:"id"`
}

// PostDeleteShareFormdataBody defines parameters for PostDeleteShare.
type PostDeleteShareFormdataBody struct {
	// Id ID of the share to delete.
	Id string `form:"id" json:"id"`
}

// DeleteUserParams defines parameters for DeleteUser.
type DeleteUserParams struct {
	// Username The name of the user to delete.
	Username string `form:"username" json:"username"`
}

// PostDeleteUserFormdataBody defines parameters for PostDeleteUser.
type PostDeleteUserFormdataBody struct {
	// Username The name of the user to delete.
	Username string `form:"username" json:"username"`
}

// DownloadParams defines parameters for Download.
type DownloadParams struct {
	// Id A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.
	Id string `form:"id" json:"id"`
}

// PostDownloadFormdataBody defines parameters for PostDownload.
type PostDownloadFormdataBody struct {
	// Id A string which uniquely identifies the file to download. Obtained by calls to getMusicDirectory.
	Id string `form:"id" json:"id"`
}

// DownloadPodcastEpisodeParams defines parameters for DownloadPodcastEpisode.
type DownloadPodcastEpisodeParams struct {
	// Id The ID of the Podcast episode to download
	Id string `form:"id" json:"id"`
}

// PostDownloadPodcastEpisodeFormdataBody defines parameters for PostDownloadPodcastEpisode.
type PostDownloadPodcastEpisodeFormdataBody struct {
	// Id The ID of the Podcast episode to download.
	Id string `form:"id" json:"id"`
}

// GetAlbumParams defines parameters for GetAlbum.
type GetAlbumParams struct {
	// Id The album ID.
	Id string `form:"id" json:"id"`
}

// PostGetAlbumFormdataBody defines parameters for PostGetAlbum.
type PostGetAlbumFormdataBody struct {
	// Id The album ID.
	Id string `form:"id" json:"id"`
}

// GetAlbumInfoParams defines parameters for GetAlbumInfo.
type GetAlbumInfoParams struct {
	// Id The album ID or song ID.
	Id string `form:"id" json:"id"`
}

// PostGetAlbumInfoFormdataBody defines parameters for PostGetAlbumInfo.
type PostGetAlbumInfoFormdataBody struct {
	// Id The album ID or song ID.
	Id string `form:"id" json:"id"`
}

// GetAlbumInfo2Params defines parameters for GetAlbumInfo2.
type GetAlbumInfo2Params struct {
	// Id The album ID or song ID.
	Id string `form:"id" json:"id"`
}

// PostGetAlbumInfo2FormdataBody defines parameters for PostGetAlbumInfo2.
type PostGetAlbumInfo2FormdataBody struct {
	// Id The album ID or song ID.
	Id string `form:"id" json:"id"`
}

// GetAlbumListParams defines parameters for GetAlbumList.
type GetAlbumListParams struct {
	Type AlbumListType `form:"type" json:"type"`

	// Size The number of albums to return. Max 500.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset The list offset. Useful if you for example want to page through the list of newest albums.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// FromYear Required if `type=='byYear'`. The first year in the range. If `fromYear` > `toYear` a reverse chronological list is returned.
	FromYear *int `form:"fromYear,omitempty" json:"fromYear,omitempty"`

	// ToYear Required if `type=='byYear'`. The last year in the range.
	ToYear *int `form:"toYear,omitempty" json:"toYear,omitempty"`

	// Genre Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.
	Genre *string `form:"genre,omitempty" json:"genre,omitempty"`

	// MusicFolderId (Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostGetAlbumListFormdataBody defines parameters for PostGetAlbumList.
type PostGetAlbumListFormdataBody struct {
	// FromYear Required if `type=='byYear'`. The first year in the range. If `fromYear` > `toYear` a reverse chronological list is returned.
	FromYear *int `form:"fromYear,omitempty" json:"fromYear,omitempty"`

	// Genre Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.
	Genre *string `form:"genre,omitempty" json:"genre,omitempty"`

	// MusicFolderId (Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`

	// Offset The list offset. Useful if you for example want to page through the list of newest albums.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Size The number of albums to return. Max 500.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// ToYear Required if `type=='byYear'`. The last year in the range.
	ToYear *int `form:"toYear,omitempty" json:"toYear,omitempty"`

	// Type The list type. Must be one of the following: random, newest, highest, frequent, recent. Since 1.8.0 you can also use alphabeticalByName or alphabeticalByArtist to page through all albums alphabetically, and starred to retrieve starred albums. Since 1.10.1 you can use byYear and byGenre to list albums in a given year range or genre.
	Type AlbumListType `form:"type" json:"type"`
}

// GetAlbumList2Params defines parameters for GetAlbumList2.
type GetAlbumList2Params struct {
	Type AlbumListType `form:"type" json:"type"`

	// Size The number of albums to return. Max 500.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Offset The list offset. Useful if you for example want to page through the list of newest albums.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// FromYear Required if `type=='byYear'`. The first year in the range. If `fromYear` > `toYear` a reverse chronological list is returned.
	FromYear *int `form:"fromYear,omitempty" json:"fromYear,omitempty"`

	// ToYear Required if `type=='byYear'`. The last year in the range.
	ToYear *int `form:"toYear,omitempty" json:"toYear,omitempty"`

	// Genre Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.
	Genre *string `form:"genre,omitempty" json:"genre,omitempty"`

	// MusicFolderId (Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostGetAlbumList2FormdataBody defines parameters for PostGetAlbumList2.
type PostGetAlbumList2FormdataBody struct {
	// FromYear Required if `type=='byYear'`. The first year in the range. If `fromYear` > `toYear` a reverse chronological list is returned.
	FromYear *int `form:"fromYear,omitempty" json:"fromYear,omitempty"`

	// Genre Required if `type=='byGenre'`. The name of the genre, e.g., “Rock”.
	Genre *string `form:"genre,omitempty" json:"genre,omitempty"`

	// MusicFolderId (Since 1.11.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`

	// Offset The list offset. Useful if you for example want to page through the list of newest albums.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Size The number of albums to return. Max 500.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// ToYear Required if `type=='byYear'`. The last year in the range.
	ToYear *int `form:"toYear,omitempty" json:"toYear,omitempty"`

	// Type The list type. Must be one of the following: random, newest, highest, frequent, recent. Since 1.8.0 you can also use alphabeticalByName or alphabeticalByArtist to page through all albums alphabetically, and starred to retrieve starred albums. Since 1.10.1 you can use byYear and byGenre to list albums in a given year range or genre.
	Type AlbumListType `form:"type" json:"type"`
}

// GetArtistParams defines parameters for GetArtist.
type GetArtistParams struct {
	// Id The artist ID.
	Id string `form:"id" json:"id"`
}

// PostGetArtistFormdataBody defines parameters for PostGetArtist.
type PostGetArtistFormdataBody struct {
	// Id The artist ID.
	Id string `form:"id" json:"id"`
}

// GetArtistInfoParams defines parameters for GetArtistInfo.
type GetArtistInfoParams struct {
	// Id The artist, album or song ID.
	Id string `form:"id" json:"id"`

	// Count Max number of similar artists to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// IncludeNotPresent Whether to return artists that are not present in the media library.
	IncludeNotPresent *bool `form:"includeNotPresent,omitempty" json:"includeNotPresent,omitempty"`
}

// PostGetArtistInfoFormdataBody defines parameters for PostGetArtistInfo.
type PostGetArtistInfoFormdataBody struct {
	// Count Max number of similar artists to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Id The artist, album or song ID.
	Id string `form:"id" json:"id"`

	// IncludeNotPresent Whether to return artists that are not present in the media library.
	IncludeNotPresent *bool `form:"includeNotPresent,omitempty" json:"includeNotPresent,omitempty"`
}

// GetArtistInfo2Params defines parameters for GetArtistInfo2.
type GetArtistInfo2Params struct {
	// Id The artist, album or song ID.
	Id string `form:"id" json:"id"`

	// Count Max number of similar artists to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// IncludeNotPresent Whether to return artists that are not present in the media library.
	IncludeNotPresent *bool `form:"includeNotPresent,omitempty" json:"includeNotPresent,omitempty"`
}

// PostGetArtistInfo2FormdataBody defines parameters for PostGetArtistInfo2.
type PostGetArtistInfo2FormdataBody struct {
	// Count Max number of similar artists to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Id The artist, album or song ID.
	Id string `form:"id" json:"id"`

	// IncludeNotPresent Whether to return artists that are not present in the media library.
	IncludeNotPresent *bool `form:"includeNotPresent,omitempty" json:"includeNotPresent,omitempty"`
}

// GetArtistsParams defines parameters for GetArtists.
type GetArtistsParams struct {
	// MusicFolderId If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostGetArtistsFormdataBody defines parameters for PostGetArtists.
type PostGetArtistsFormdataBody struct {
	// MusicFolderId If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// GetAvatarParams defines parameters for GetAvatar.
type GetAvatarParams struct {
	Username string `form:"username" json:"username"`
}

// PostGetAvatarFormdataBody defines parameters for PostGetAvatar.
type PostGetAvatarFormdataBody struct {
	// Username The username for which to retrieve the avatar.
	Username string `form:"username" json:"username"`
}

// PostGetBookmarksFormdataBody defines parameters for PostGetBookmarks.
type PostGetBookmarksFormdataBody = struct {
}

// GetCaptionsParams defines parameters for GetCaptions.
type GetCaptionsParams struct {
	// Id The ID of the video.
	Id string `form:"id" json:"id"`

	// Format Preferred captions format (“srt” or “vtt”).
	Format *GetCaptionsParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetCaptionsParamsFormat defines parameters for GetCaptions.
type GetCaptionsParamsFormat string

// PostGetCaptionsFormdataBody defines parameters for PostGetCaptions.
type PostGetCaptionsFormdataBody struct {
	// Format Preferred captions format (“srt” or “vtt”).
	Format *PostGetCaptionsFormdataBodyFormat `form:"format,omitempty" json:"format,omitempty"`

	// Id The ID of the video.
	Id string `form:"id" json:"id"`
}

// PostGetCaptionsFormdataBodyFormat defines parameters for PostGetCaptions.
type PostGetCaptionsFormdataBodyFormat string

// PostGetChatMessagesFormdataBody defines parameters for PostGetChatMessages.
type PostGetChatMessagesFormdataBody = struct {
}

// GetCoverArtParams defines parameters for GetCoverArt.
type GetCoverArtParams struct {
	// Id The coverArt ID. Returned by most entities likes `Child` or `AlbumID3`
	Id string `form:"id" json:"id"`

	// Size If specified, scale image to this size.
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// PostGetCoverArtFormdataBody defines parameters for PostGetCoverArt.
type PostGetCoverArtFormdataBody struct {
	// Id The coverArt ID. Returned by most entities likes `Child` or `AlbumID3`
	Id string `form:"id" json:"id"`

	// Size If specified, scale image to this size.
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// PostGetGenresFormdataBody defines parameters for PostGetGenres.
type PostGetGenresFormdataBody = struct {
}

// GetIndexesParams defines parameters for GetIndexes.
type GetIndexesParams struct {
	// MusicFolderId If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`

	// IfModifiedSince If specified, only return a result if the artist collection has changed since the given time (in milliseconds since 1 Jan 1970).
	IfModifiedSince *int `form:"ifModifiedSince,omitempty" json:"ifModifiedSince,omitempty"`
}

// PostGetIndexesFormdataBody defines parameters for PostGetIndexes.
type PostGetIndexesFormdataBody struct {
	// IfModifiedSince If specified, only return a result if the artist collection has changed since the given time (in milliseconds since 1 Jan 1970).
	IfModifiedSince *int `form:"ifModifiedSince,omitempty" json:"ifModifiedSince,omitempty"`

	// MusicFolderId If specified, only return artists in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostGetInternetRadioStationsFormdataBody defines parameters for PostGetInternetRadioStations.
type PostGetInternetRadioStationsFormdataBody = struct {
}

// PostGetLicenseFormdataBody defines parameters for PostGetLicense.
type PostGetLicenseFormdataBody = struct {
}

// GetLyricsParams defines parameters for GetLyrics.
type GetLyricsParams struct {
	// Artist The artist name.
	Artist *string `form:"artist,omitempty" json:"artist,omitempty"`

	// Title The song title.
	Title *string `form:"title,omitempty" json:"title,omitempty"`
}

// PostGetLyricsFormdataBody defines parameters for PostGetLyrics.
type PostGetLyricsFormdataBody struct {
	// Artist The artist name.
	Artist *string `form:"artist,omitempty" json:"artist,omitempty"`

	// Title The song title.
	Title *string `form:"title,omitempty" json:"title,omitempty"`
}

// GetLyricsBySongIdParams defines parameters for GetLyricsBySongId.
type GetLyricsBySongIdParams struct {
	// Id The track ID.
	Id string `form:"id" json:"id"`
}

// PostGetLyricsBySongIdFormdataBody defines parameters for PostGetLyricsBySongId.
type PostGetLyricsBySongIdFormdataBody struct {
	// Id The track ID.
	Id string `form:"id" json:"id"`
}

// GetMusicDirectoryParams defines parameters for GetMusicDirectory.
type GetMusicDirectoryParams struct {
	// Id A string which uniquely identifies the music folder. Obtained by calls to `getIndexes` or `getMusicDirectory`.
	Id string `form:"id" json:"id"`
}

// PostGetMusicDirectoryFormdataBody defines parameters for PostGetMusicDirectory.
type PostGetMusicDirectoryFormdataBody struct {
	// Id A string which uniquely identifies the music folder. Obtained by calls to `getIndexes` or `getMusicDirectory`.
	Id string `form:"id" json:"id"`
}

// PostGetMusicFoldersFormdataBody defines parameters for PostGetMusicFolders.
type PostGetMusicFoldersFormdataBody = struct {
}

// GetNewestPodcastsParams defines parameters for GetNewestPodcasts.
type GetNewestPodcastsParams struct {
	// Count The maximum number of episodes to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// PostGetNewestPodcastsFormdataBody defines parameters for PostGetNewestPodcasts.
type PostGetNewestPodcastsFormdataBody struct {
	// Count The maximum number of episodes to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// PostGetNowPlayingFormdataBody defines parameters for PostGetNowPlaying.
type PostGetNowPlayingFormdataBody = struct {
}

// PostGetOpenSubsonicExtensionsFormdataBody defines parameters for PostGetOpenSubsonicExtensions.
type PostGetOpenSubsonicExtensionsFormdataBody = struct {
}

// PostGetPlayQueueFormdataBody defines parameters for PostGetPlayQueue.
type PostGetPlayQueueFormdataBody = struct {
}

// PostGetPlayQueueByIndexFormdataBody defines parameters for PostGetPlayQueueByIndex.
type PostGetPlayQueueByIndexFormdataBody = struct {
}

// GetPlaylistParams defines parameters for GetPlaylist.
type GetPlaylistParams struct {
	// Id ID of the playlist to return, as obtained by `getPlaylists`.
	Id string `form:"id" json:"id"`
}

// PostGetPlaylistFormdataBody defines parameters for PostGetPlaylist.
type PostGetPlaylistFormdataBody struct {
	// Id ID of the playlist to return, as obtained by `getPlaylists`.
	Id string `form:"id" json:"id"`
}

// GetPlaylistsParams defines parameters for GetPlaylists.
type GetPlaylistsParams struct {
	// Username (Since 1.8.0) If specified, return playlists for this user rather than for the authenticated user. The authenticated user must have admin role if this parameter is used.
	Username *string `form:"username,omitempty" json:"username,omitempty"`
}

// PostGetPlaylistsFormdataBody defines parameters for PostGetPlaylists.
type PostGetPlaylistsFormdataBody struct {
	// Username (Since 1.8.0) If specified, return playlists for this user rather than for the authenticated user. The authenticated user must have admin role if this parameter is used.
	Username *string `form:"username,omitempty" json:"username,omitempty"`
}

// GetPodcastEpisodeParams defines parameters for GetPodcastEpisode.
type GetPodcastEpisodeParams struct {
	// Id The podcast episode ID.
	Id string `form:"id" json:"id"`
}

// PostGetPodcastEpisodeFormdataBody defines parameters for PostGetPodcastEpisode.
type PostGetPodcastEpisodeFormdataBody struct {
	// Id The podcast episode ID.
	Id string `form:"id" json:"id"`
}

// GetPodcastsParams defines parameters for GetPodcasts.
type GetPodcastsParams struct {
	// Id (Since 1.9.0) If specified, only return the Podcast channel with this ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// IncludeEpisodes (Since 1.9.0) Whether to include Podcast episodes in the returned result.
	IncludeEpisodes *bool `form:"includeEpisodes,omitempty" json:"includeEpisodes,omitempty"`
}

// PostGetPodcastsFormdataBody defines parameters for PostGetPodcasts.
type PostGetPodcastsFormdataBody struct {
	// Id (Since 1.9.0) If specified, only return the Podcast channel with this ID.
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// IncludeEpisodes (Since 1.9.0) Whether to include Podcast episodes in the returned result.
	IncludeEpisodes *bool `form:"includeEpisodes,omitempty" json:"includeEpisodes,omitempty"`
}

// GetRandomSongsParams defines parameters for GetRandomSongs.
type GetRandomSongsParams struct {
	// Size The maximum number of songs to return. Max 500.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Genre Only returns songs belonging to this genre.
	Genre *string `form:"genre,omitempty" json:"genre,omitempty"`

	// FromYear (Since 1.9.0) Only return songs from this year or later.
	FromYear *int `form:"fromYear,omitempty" json:"fromYear,omitempty"`

	// ToYear Only return songs published before or in this year.
	ToYear *int `form:"toYear,omitempty" json:"toYear,omitempty"`

	// MusicFolderId Only return songs in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostGetRandomSongsFormdataBody defines parameters for PostGetRandomSongs.
type PostGetRandomSongsFormdataBody struct {
	// FromYear (Since 1.9.0) Only return songs from this year or later.
	FromYear *int `form:"fromYear,omitempty" json:"fromYear,omitempty"`

	// Genre Only returns songs belonging to this genre.
	Genre *string `form:"genre,omitempty" json:"genre,omitempty"`

	// MusicFolderId Only return songs in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`

	// Size The maximum number of songs to return. Max 500.
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// ToYear Only return songs published before or in this year.
	ToYear *int `form:"toYear,omitempty" json:"toYear,omitempty"`
}

// PostGetScanStatusFormdataBody defines parameters for PostGetScanStatus.
type PostGetScanStatusFormdataBody = struct {
}

// PostGetSharesFormdataBody defines parameters for PostGetShares.
type PostGetSharesFormdataBody = struct {
}

// GetSimilarSongsParams defines parameters for GetSimilarSongs.
type GetSimilarSongsParams struct {
	// Id The artist, album or song ID.
	Id string `form:"id" json:"id"`

	// Count Max number of songs to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// PostGetSimilarSongsFormdataBody defines parameters for PostGetSimilarSongs.
type PostGetSimilarSongsFormdataBody struct {
	// Count Max number of songs to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Id The artist, album or song ID.
	Id string `form:"id" json:"id"`
}

// GetSimilarSongs2Params defines parameters for GetSimilarSongs2.
type GetSimilarSongs2Params struct {
	// Id The artist, album or song ID.
	Id string `form:"id" json:"id"`

	// Count Max number of songs to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// PostGetSimilarSongs2FormdataBody defines parameters for PostGetSimilarSongs2.
type PostGetSimilarSongs2FormdataBody struct {
	// Count Max number of songs to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Id The artist, album or song ID.
	Id string `form:"id" json:"id"`
}

// GetSongParams defines parameters for GetSong.
type GetSongParams struct {
	// Id The song ID.
	Id string `form:"id" json:"id"`
}

// PostGetSongFormdataBody defines parameters for PostGetSong.
type PostGetSongFormdataBody struct {
	// Id The song ID.
	Id string `form:"id" json:"id"`
}

// GetSongsByGenreParams defines parameters for GetSongsByGenre.
type GetSongsByGenreParams struct {
	// Genre The genre, as returned by `getGenres`.
	Genre string `form:"genre" json:"genre"`

	// Count The maximum number of songs to return. Max 500.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Offset The offset. Useful if you want to page through the songs in a genre.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// MusicFolderId (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostGetSongsByGenreFormdataBody defines parameters for PostGetSongsByGenre.
type PostGetSongsByGenreFormdataBody struct {
	// Count The maximum number of songs to return. Max 500.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Genre The genre, as returned by `getGenres`.
	Genre string `form:"genre" json:"genre"`

	// MusicFolderId (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`

	// Offset The offset. Useful if you want to page through the songs in a genre.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetStarredParams defines parameters for GetStarred.
type GetStarredParams struct {
	// MusicFolderId (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostGetStarredFormdataBody defines parameters for PostGetStarred.
type PostGetStarredFormdataBody = struct {
}

// GetStarred2Params defines parameters for GetStarred2.
type GetStarred2Params struct {
	// MusicFolderId (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostGetStarred2FormdataBody defines parameters for PostGetStarred2.
type PostGetStarred2FormdataBody = struct {
}

// GetTopSongsParams defines parameters for GetTopSongs.
type GetTopSongsParams struct {
	// Id The artist name.
	Id string `form:"id" json:"id"`

	// Count The maximum number of songs to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`
}

// PostGetTopSongsFormdataBody defines parameters for PostGetTopSongs.
type PostGetTopSongsFormdataBody struct {
	// Count The maximum number of songs to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Id The artist name.
	Id string `form:"id" json:"id"`
}

// GetTranscodeDecisionParams defines parameters for GetTranscodeDecision.
type GetTranscodeDecisionParams struct {
	// MediaId The ID of the media.
	MediaId string `form:"mediaId" json:"mediaId"`

	// MediaType The type of the media.
	MediaType GetTranscodeDecisionParamsMediaType `form:"mediaType" json:"mediaType"`
}

// GetTranscodeDecisionParamsMediaType defines parameters for GetTranscodeDecision.
type GetTranscodeDecisionParamsMediaType string

// GetTranscodeStreamParams defines parameters for GetTranscodeStream.
type GetTranscodeStreamParams struct {
	// MediaId The ID of the media.
	MediaId string `form:"mediaId" json:"mediaId"`

	// MediaType The type of the media.
	MediaType GetTranscodeStreamParamsMediaType `form:"mediaType" json:"mediaType"`

	// Offset The time offset in seconds from which to start transcoding.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// TranscodeParams Server-specific transcoding parameters. This should be obtained from the `getTranscodeDecision` endpoint.
	TranscodeParams string `form:"transcodeParams" json:"transcodeParams"`
}

// GetTranscodeStreamParamsMediaType defines parameters for GetTranscodeStream.
type GetTranscodeStreamParamsMediaType string

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {
	// Username The name of the user to retrieve. You can only retrieve your own user unless you have admin privileges.
	Username string `form:"username" json:"username"`
}

// PostGetUserFormdataBody defines parameters for PostGetUser.
type PostGetUserFormdataBody struct {
	// Username The name of the user to retrieve. You can only retrieve your own user unless you have admin privileges.
	Username string `form:"username" json:"username"`
}

// PostGetUsersFormdataBody defines parameters for PostGetUsers.
type PostGetUsersFormdataBody = struct {
}

// GetVideoInfoParams defines parameters for GetVideoInfo.
type GetVideoInfoParams struct {
	// Id The video ID.
	Id string `form:"id" json:"id"`
}

// PostGetVideoInfoFormdataBody defines parameters for PostGetVideoInfo.
type PostGetVideoInfoFormdataBody struct {
	// Id The video ID.
	Id string `form:"id" json:"id"`
}

// PostGetVideosFormdataBody defines parameters for PostGetVideos.
type PostGetVideosFormdataBody = struct {
}

// HlsM3u8Params defines parameters for HlsM3u8.
type HlsM3u8Params struct {
	// Id A string which uniquely identifies the media file to stream.
	Id string `form:"id" json:"id"`

	// BitRate If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If this parameter is specified more than once, the server will create a variant playlist, suitable for adaptive bitrate streaming. The playlist will support streaming at all the specified bitrates. The server will automatically choose video dimensions that are suitable for the given bitrates. Since 1.9.0 you may explicitly request a certain width (480) and height (360) like so: bitRate=1000@480x360
	BitRate *int `form:"bitRate,omitempty" json:"bitRate,omitempty"`

	// AudioTrack The ID of the audio track to use. See `getVideoInfo` for how to get the list of available audio tracks for a video.
	AudioTrack *string `form:"audioTrack,omitempty" json:"audioTrack,omitempty"`
}

// PostHlsM3u8FormdataBody defines parameters for PostHlsM3u8.
type PostHlsM3u8FormdataBody struct {
	// AudioTrack The ID of the audio track to use. See `getVideoInfo` for how to get the list of available audio tracks for a video.
	AudioTrack *string `form:"audioTrack,omitempty" json:"audioTrack,omitempty"`

	// BitRate If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.
	BitRate *int `form:"bitRate,omitempty" json:"bitRate,omitempty"`

	// Id A string which uniquely identifies the media file to stream.
	Id string `form:"id" json:"id"`
}

// JukeboxControlParams defines parameters for JukeboxControl.
type JukeboxControlParams struct {
	// Action The operation to perform. Must be one of: get, status (since 1.7.0), set (since 1.7.0), start, stop, skip, add, clear, remove, shuffle, setGain
	Action JukeboxAction `form:"action" json:"action"`

	// Index Used by `skip` and `remove`. Zero-based index of the song to skip to or remove.
	Index *int `form:"index,omitempty" json:"index,omitempty"`

	// Offset (Since 1.7.0) Used by `skip`. Start playing this many seconds into the track.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Id Used by `add` and `set`. ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by a add, but will not change the currently playing track.)
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Gain Used by `setGain` to control the playback volume. A float value between 0.0 and 1.0.
	Gain *float32 `form:"gain,omitempty" json:"gain,omitempty"`
}

// PostJukeboxControlFormdataBody defines parameters for PostJukeboxControl.
type PostJukeboxControlFormdataBody struct {
	union json.RawMessage
}

// PostJukeboxControlFormdataBody0 defines parameters for PostJukeboxControl.
type PostJukeboxControlFormdataBody0 struct {
	// Action The operation to perform. Must be one of: get, status (since 1.7.0), set (since 1.7.0), start, stop, skip, add, clear, remove, shuffle, setGain
	Action interface{} `json:"action"`
}

// PostJukeboxControlFormdataBody1 defines parameters for PostJukeboxControl.
type PostJukeboxControlFormdataBody1 struct {
	// Action 'remove' action.
	Action interface{} `json:"action"`

	// Index Zero-based index of the song to remove.
	Index int `json:"index"`
}

// PostJukeboxControlFormdataBody2 defines parameters for PostJukeboxControl.
type PostJukeboxControlFormdataBody2 struct {
	// Action 'skip' action.
	Action interface{} `json:"action"`

	// Index Zero-based index of the song to skip.
	Index int `json:"index"`

	// Offset (Since 1.7.0) Used by `skip`. Start playing this many seconds into the track.
	Offset *int `json:"offset,omitempty"`
}

// PostJukeboxControlFormdataBody3 defines parameters for PostJukeboxControl.
type PostJukeboxControlFormdataBody3 struct {
	// Action 'add' action.
	Action interface{} `json:"action"`

	// Id ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by an add, but will not change the currently playing track.)
	Id []string `json:"id"`
}

// PostJukeboxControlFormdataBody4 defines parameters for PostJukeboxControl.
type PostJukeboxControlFormdataBody4 struct {
	// Action 'set' action.
	Action interface{} `json:"action"`

	// Id ID of song to add to the jukebox playlist. Use multiple id parameters to add many songs in the same request. (set is similar to a clear followed by an add, but will not change the currently playing track.)
	Id []string `json:"id"`
}

// PostJukeboxControlFormdataBody5 defines parameters for PostJukeboxControl.
type PostJukeboxControlFormdataBody5 struct {
	// Action 'setGain' action.
	Action interface{} `json:"action"`

	// Gain Used by `setGain` to control the playback volume. A float value between 0.0 and 1.0.
	Gain float32 `json:"gain"`
}

// PostPingFormdataBody defines parameters for PostPing.
type PostPingFormdataBody = struct {
}

// PostRefreshPodcastsFormdataBody defines parameters for PostRefreshPodcasts.
type PostRefreshPodcastsFormdataBody = struct {
}

// SavePlayQueueParams defines parameters for SavePlayQueue.
type SavePlayQueueParams struct {
	// Id ID of a song in the play queue. Use one id parameter for each song in the play queue. Specify no IDs to clear
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Current The ID of the current playing song.  This is required if one or more IDs is provided.
	Current *string `form:"current,omitempty" json:"current,omitempty"`

	// Position The position in milliseconds within the currently playing song.
	Position *int `form:"position,omitempty" json:"position,omitempty"`
}

// PostSavePlayQueueFormdataBody defines parameters for PostSavePlayQueue.
type PostSavePlayQueueFormdataBody struct {
	// Current The ID of the current playing song. This is required if one or mode IDs is provided
	Current *string `form:"current,omitempty" json:"current,omitempty"`

	// Id ID of a song in the play queue. Use one id parameter for each song in the play queue. Specify no IDs to clear
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Position The position in milliseconds within the currently playing song.
	Position *int `form:"position,omitempty" json:"position,omitempty"`
}

// SavePlayQueueByIndexParams defines parameters for SavePlayQueueByIndex.
type SavePlayQueueByIndexParams struct {
	// Id ID of a song in the play queue. Use one id parameter for each song in the play queue. Specify no IDs to clear
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// CurrentIndex The index of the current playing song. This is required if one or more IDs is provided.
	CurrentIndex *int `form:"currentIndex,omitempty" json:"currentIndex,omitempty"`

	// Position The position in milliseconds within the currently playing song.
	Position *int `form:"position,omitempty" json:"position,omitempty"`
}

// PostSavePlayQueueByIndexFormdataBody defines parameters for PostSavePlayQueueByIndex.
type PostSavePlayQueueByIndexFormdataBody struct {
	// CurrentIndex The index of the current playing song. This is required if one or more IDs is provided.
	CurrentIndex *string `form:"currentIndex,omitempty" json:"currentIndex,omitempty"`

	// Id ID of a song in the play queue. Use one id parameter for each song in the play queue. Specify no IDs to clear
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Position The position in milliseconds within the currently playing song.
	Position *int `form:"position,omitempty" json:"position,omitempty"`
}

// ScrobbleParams defines parameters for Scrobble.
type ScrobbleParams struct {
	// Id A string which uniquely identifies the file to scrobble.
	Id string `form:"id" json:"id"`

	// Time (Since 1.8.0) The time (in milliseconds since 1 Jan 1970) at which the song was listened to.
	Time *int `form:"time,omitempty" json:"time,omitempty"`

	// Submission Whether this is a “submission” or a “now playing” notification.
	Submission *bool `form:"submission,omitempty" json:"submission,omitempty"`
}

// PostScrobbleFormdataBody defines parameters for PostScrobble.
type PostScrobbleFormdataBody struct {
	// Id A string which uniquely identifies the file to scrobble.
	Id string `form:"id" json:"id"`

	// Submission Whether this is a “submission” or a “now playing” notification.
	Submission *bool `form:"submission,omitempty" json:"submission,omitempty"`

	// Time (Since 1.8.0) The time (in milliseconds since 1 Jan 1970) at which the song was listened to.
	Time *int `form:"time,omitempty" json:"time,omitempty"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	// Artist Artist to search for.
	Artist *string `form:"artist,omitempty" json:"artist,omitempty"`

	// Album Album to search for.
	Album *string `form:"album,omitempty" json:"album,omitempty"`

	// Title Song title to search for.
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// Any Searches all fields.
	Any *bool `form:"any,omitempty" json:"any,omitempty"`

	// Count Maximum number of results to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Offset Search result offset. Used for paging.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// NewerThan Only return matches that are newer than this. Given as milliseconds since 1970.
	NewerThan *int `form:"newerThan,omitempty" json:"newerThan,omitempty"`
}

// PostSearchFormdataBody defines parameters for PostSearch.
type PostSearchFormdataBody struct {
	// Album Album to search for.
	Album *string `form:"album,omitempty" json:"album,omitempty"`

	// Any Searches all fields.
	Any *bool `form:"any,omitempty" json:"any,omitempty"`

	// Artist Artist to search for.
	Artist *string `form:"artist,omitempty" json:"artist,omitempty"`

	// Count Maximum number of results to return.
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// NewerThan Only return matches that are newer than this. Given as milliseconds since 1970.
	NewerThan *int `form:"newerThan,omitempty" json:"newerThan,omitempty"`

	// Offset Search result offset. Used for paging.
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Title Song title to search for.
	Title *string `form:"title,omitempty" json:"title,omitempty"`
}

// Search2Params defines parameters for Search2.
type Search2Params struct {
	// Query Search query.
	Query string `form:"query" json:"query"`

	// ArtistCount Maximum number of artists to return.
	ArtistCount *int `form:"artistCount,omitempty" json:"artistCount,omitempty"`

	// ArtistOffset Search result offset for artists. Used for paging.
	ArtistOffset *int `form:"artistOffset,omitempty" json:"artistOffset,omitempty"`

	// AlbumCount Maximum number of albums to return.
	AlbumCount *int `form:"albumCount,omitempty" json:"albumCount,omitempty"`

	// AlbumOffset Search result offset for albums. Used for paging.
	AlbumOffset *int `form:"albumOffset,omitempty" json:"albumOffset,omitempty"`

	// SongCount Maximum number of songs to return.
	SongCount *int `form:"songCount,omitempty" json:"songCount,omitempty"`

	// SongOffset Search result offset for songs. Used for paging.
	SongOffset *int `form:"songOffset,omitempty" json:"songOffset,omitempty"`

	// MusicFolderId (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostSearch2FormdataBody defines parameters for PostSearch2.
type PostSearch2FormdataBody struct {
	// AlbumCount Maximum number of albums to return.
	AlbumCount *int `form:"albumCount,omitempty" json:"albumCount,omitempty"`

	// AlbumOffset Search result offset for albums. Used for paging.
	AlbumOffset *int `form:"albumOffset,omitempty" json:"albumOffset,omitempty"`

	// ArtistCount Maximum number of artists to return.
	ArtistCount *int `form:"artistCount,omitempty" json:"artistCount,omitempty"`

	// ArtistOffset Search result offset for artists. Used for paging.
	ArtistOffset *int `form:"artistOffset,omitempty" json:"artistOffset,omitempty"`

	// MusicFolderId (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`

	// Query Search query.
	Query string `form:"query" json:"query"`

	// SongCount Maximum number of songs to return.
	SongCount *int `form:"songCount,omitempty" json:"songCount,omitempty"`

	// SongOffset Search result offset for songs. Used for paging.
	SongOffset *int `form:"songOffset,omitempty" json:"songOffset,omitempty"`
}

// Search3Params defines parameters for Search3.
type Search3Params struct {
	// Query Search query. Servers must support an empty query and return all the data to allow clients to properly access all the media information for offline sync.
	Query string `form:"query" json:"query"`

	// ArtistCount Maximum number of artists to return.
	ArtistCount *int `form:"artistCount,omitempty" json:"artistCount,omitempty"`

	// ArtistOffset Search result offset for artists. Used for paging.
	ArtistOffset *int `form:"artistOffset,omitempty" json:"artistOffset,omitempty"`

	// AlbumCount Maximum number of albums to return.
	AlbumCount *int `form:"albumCount,omitempty" json:"albumCount,omitempty"`

	// AlbumOffset Search result offset for albums. Used for paging.
	AlbumOffset *int `form:"albumOffset,omitempty" json:"albumOffset,omitempty"`

	// SongCount Maximum number of songs to return.
	SongCount *int `form:"songCount,omitempty" json:"songCount,omitempty"`

	// SongOffset Search result offset for songs. Used for paging.
	SongOffset *int `form:"songOffset,omitempty" json:"songOffset,omitempty"`

	// MusicFolderId (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`
}

// PostSearch3FormdataBody defines parameters for PostSearch3.
type PostSearch3FormdataBody struct {
	// AlbumCount Maximum number of albums to return.
	AlbumCount *int `form:"albumCount,omitempty" json:"albumCount,omitempty"`

	// AlbumOffset Search result offset for albums. Used for paging.
	AlbumOffset *int `form:"albumOffset,omitempty" json:"albumOffset,omitempty"`

	// ArtistCount Maximum number of artists to return.
	ArtistCount *int `form:"artistCount,omitempty" json:"artistCount,omitempty"`

	// ArtistOffset Search result offset for artists. Used for paging.
	ArtistOffset *int `form:"artistOffset,omitempty" json:"artistOffset,omitempty"`

	// MusicFolderId (Since 1.12.0) Only return albums in the music folder with the given ID. See `getMusicFolders`.
	MusicFolderId *string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`

	// Query Search query. Servers must support an empty query and return all the data to allow clients to properly access all the media information for offline sync.
	Query string `form:"query" json:"query"`

	// SongCount Maximum number of songs to return.
	SongCount *int `form:"songCount,omitempty" json:"songCount,omitempty"`

	// SongOffset Search result offset for songs. Used for paging.
	SongOffset *int `form:"songOffset,omitempty" json:"songOffset,omitempty"`
}

// SetRatingParams defines parameters for SetRating.
type SetRatingParams struct {
	// Id A string which uniquely identifies the file (song) or folder (album/artist) to rate.
	Id string `form:"id" json:"id"`

	// Rating The rating between 1 and 5 (inclusive), or 0 to remove the rating.
	Rating int `form:"rating" json:"rating"`
}

// PostSetRatingFormdataBody defines parameters for PostSetRating.
type PostSetRatingFormdataBody struct {
	// Id A string which uniquely identifies the file (song) or folder (album/artist) to rate.
	Id string `form:"id" json:"id"`

	// Rating The rating between 1 and 5 (inclusive), or 0 to remove the rating.
	Rating int `form:"rating" json:"rating"`
}

// StarParams defines parameters for Star.
type StarParams struct {
	// Id The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// AlbumId The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
	AlbumId *[]string `form:"albumId,omitempty" json:"albumId,omitempty"`

	// ArtistId The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
	ArtistId *[]string `form:"artistId,omitempty" json:"artistId,omitempty"`
}

// PostStarFormdataBody defines parameters for PostStar.
type PostStarFormdataBody struct {
	// AlbumId The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
	AlbumId *[]string `form:"albumId,omitempty" json:"albumId,omitempty"`

	// ArtistId The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
	ArtistId *[]string `form:"artistId,omitempty" json:"artistId,omitempty"`

	// Id The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`
}

// PostStartScanFormdataBody defines parameters for PostStartScan.
type PostStartScanFormdataBody = struct {
}

// StreamParams defines parameters for Stream.
type StreamParams struct {
	// Id A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.
	Id string `form:"id" json:"id"`

	// MaxBitRate (Since 1.2.0) If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.
	MaxBitRate *int `form:"maxBitRate,omitempty" json:"maxBitRate,omitempty"`

	// Format (Since 1.6.0) Specifies the preferred target format (e.g., “mp3” or “flv”) in case there are multiple applicable transcodings. Starting with 1.9.0 you can use the special value “raw” to disable transcoding.
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// TimeOffset By default only applicable to video streaming. If specified, start streaming at the given offset (in seconds) into the media. The `Transcode Offset` extension enables the parameter to music too.
	TimeOffset *int `form:"timeOffset,omitempty" json:"timeOffset,omitempty"`

	// Size (Since 1.6.0) Only applicable to video streaming. Requested video size specified as WxH, for instance “640x480”.
	Size *string `form:"size,omitempty" json:"size,omitempty"`

	// EstimateContentLength (Since 1.8.0). If set to “true”, the Content-Length HTTP header will be set to an estimated value for transcoded or downsampled media.
	EstimateContentLength *bool `form:"estimateContentLength,omitempty" json:"estimateContentLength,omitempty"`

	// Converted (Since 1.14.0) Only applicable to video streaming. Servers can optimize videos for streaming by converting them to MP4. If a conversion exists for the video in question, then setting this parameter to “true” will cause the converted video to be returned instead of the original.
	Converted *bool `form:"converted,omitempty" json:"converted,omitempty"`
}

// PostStreamFormdataBody defines parameters for PostStream.
type PostStreamFormdataBody struct {
	// Converted (Since 1.14.0) Only applicable to video streaming. Servers can optimize videos for streaming by converting them to MP4. If a conversion exists for the video in question, then setting this parameter to “true” will cause the converted video to be returned instead of the original.
	Converted *bool `form:"converted,omitempty" json:"converted,omitempty"`

	// EstimateContentLength (Since 1.8.0). If set to “true”, the Content-Length HTTP header will be set to an estimated value for transcoded or downsampled media.
	EstimateContentLength *bool `form:"estimateContentLength,omitempty" json:"estimateContentLength,omitempty"`

	// Format (Since 1.6.0) Specifies the preferred target format (e.g., “mp3” or “flv”) in case there are multiple applicable transcodings. Starting with 1.9.0 you can use the special value “raw” to disable transcoding.
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id A string which uniquely identifies the file to stream. Obtained by calls to getMusicDirectory.
	Id string `form:"id" json:"id"`

	// MaxBitRate (Since 1.2.0) If specified, the server will attempt to limit the bitrate to this value, in kilobits per second. If set to zero, no limit is imposed.
	MaxBitRate *int `form:"maxBitRate,omitempty" json:"maxBitRate,omitempty"`

	// Size (Since 1.6.0) Only applicable to video streaming. Requested video size specified as WxH, for instance “640x480”.
	Size *string `form:"size,omitempty" json:"size,omitempty"`

	// TimeOffset By default only applicable to video streaming. If specified, start streaming at the given offset (in seconds) into the media. The `Transcode Offset` extension enables the parameter to music too.
	TimeOffset *int `form:"timeOffset,omitempty" json:"timeOffset,omitempty"`
}

// PostTokenInfoFormdataBody defines parameters for PostTokenInfo.
type PostTokenInfoFormdataBody = struct {
}

// UnstarParams defines parameters for Unstar.
type UnstarParams struct {
	// Id The ID of the file (song) or folder (album/artist) to star. Multiple parameters allowed.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// AlbumId The ID of an album to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
	AlbumId *[]string `form:"albumId,omitempty" json:"albumId,omitempty"`

	// ArtistId The ID of an artist to star. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
	ArtistId *[]string `form:"artistId,omitempty" json:"artistId,omitempty"`
}

// PostUnstarFormdataBody defines parameters for PostUnstar.
type PostUnstarFormdataBody struct {
	// AlbumId The ID of an album to unstar. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
	AlbumId interface{} `form:"albumId,omitempty" json:"albumId,omitempty"`

	// ArtistId The ID of an artist to unstar. Use this rather than `id` if the client accesses the media collection according to ID3 tags rather than file structure. Multiple parameters allowed.
	ArtistId interface{} `form:"artistId,omitempty" json:"artistId,omitempty"`

	// Id The ID of the file (song) or folder (album/artist) to unstar. Multiple parameters allowed.
	Id interface{} `form:"id,omitempty" json:"id,omitempty"`
}

// UpdateInternetRadioStationParams defines parameters for UpdateInternetRadioStation.
type UpdateInternetRadioStationParams struct {
	// Id The ID of the station.
	Id string `form:"id" json:"id"`

	// StreamUrl The stream URL for the station.
	StreamUrl string `form:"streamUrl" json:"streamUrl"`

	// Name The user-defined name for the station.
	Name string `form:"name" json:"name"`

	// HomepageUrl The home page URL for the station.
	HomepageUrl *string `form:"homepageUrl,omitempty" json:"homepageUrl,omitempty"`
}

// PostUpdateInternetRadioStationFormdataBody defines parameters for PostUpdateInternetRadioStation.
type PostUpdateInternetRadioStationFormdataBody struct {
	// HomepageUrl The home page URL for the station.
	HomepageUrl *string `form:"homepageUrl,omitempty" json:"homepageUrl,omitempty"`

	// Id The ID of the station.
	Id string `form:"id" json:"id"`

	// Name The user-defined name for the station.
	Name string `form:"name" json:"name"`

	// StreamUrl The stream URL for the station.
	StreamUrl string `form:"streamUrl" json:"streamUrl"`
}

// UpdatePlaylistParams defines parameters for UpdatePlaylist.
type UpdatePlaylistParams struct {
	// PlaylistId The playlist ID.
	PlaylistId string `form:"playlistId" json:"playlistId"`

	// Name The human-readable name of the playlist.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Comment The playlist comment.
	Comment *string `form:"comment,omitempty" json:"comment,omitempty"`

	// Public `true` if the playlist should be visible to all users, `false` otherwise.
	Public *bool `form:"public,omitempty" json:"public,omitempty"`

	// SongIdToAdd Add this song with this ID to the playlist. Multiple parameters allowed.
	SongIdToAdd *[]string `form:"songIdToAdd,omitempty" json:"songIdToAdd,omitempty"`

	// SongIndexToRemove Remove the song at this position in the playlist. Multiple parameters allowed.
	SongIndexToRemove *[]int `form:"songIndexToRemove,omitempty" json:"songIndexToRemove,omitempty"`
}

// PostUpdatePlaylistFormdataBody defines parameters for PostUpdatePlaylist.
type PostUpdatePlaylistFormdataBody struct {
	// Comment The playlist comment.
	Comment *string `form:"comment,omitempty" json:"comment,omitempty"`

	// Name The human-readable name of the playlist.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PlaylistId The playlist ID.
	PlaylistId string `form:"playlistId" json:"playlistId"`

	// Public `true` if the playlist should be visible to all users, `false` otherwise.
	Public *bool `form:"public,omitempty" json:"public,omitempty"`

	// SongIdToAdd Add this song with this ID to the playlist. Multiple parameters allowed.
	SongIdToAdd *[]string `form:"songIdToAdd,omitempty" json:"songIdToAdd,omitempty"`

	// SongIndexToRemove Remove the song at this position in the playlist. Multiple parameters allowed.
	SongIndexToRemove *[]int `form:"songIndexToRemove,omitempty" json:"songIndexToRemove,omitempty"`
}

// UpdateShareParams defines parameters for UpdateShare.
type UpdateShareParams struct {
	// Id ID of the share to update.
	Id string `form:"id" json:"id"`

	// Description A user-defined description that will be displayed to people visiting the shared media.
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Expires The time at which the share expires. Given as milliseconds since 1970, or zero to remove the expiration.
	Expires *int `form:"expires,omitempty" json:"expires,omitempty"`
}

// PostUpdateShareFormdataBody defines parameters for PostUpdateShare.
type PostUpdateShareFormdataBody struct {
	// Description A user-defined description that will be displayed to people visiting the shared media.
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Expires The time at which the share expires. Given as milliseconds since 1970, or zero to remove the expiration.
	Expires *int `form:"expires,omitempty" json:"expires,omitempty"`

	// Id ID of the share to update.
	Id string `form:"id" json:"id"`
}

// UpdateUserParams defines parameters for UpdateUser.
type UpdateUserParams struct {
	// Username The name of the user.
	Username string `form:"username" json:"username"`

	// Password The password of the user, either in clear text of hex-encoded (see above).
	Password string `form:"password" json:"password"`

	// Email The email address of the user.
	Email *string `form:"email,omitempty" json:"email,omitempty"`

	// LdapAuthenticated Whether the user is authenicated in LDAP.
	LdapAuthenticated *bool `form:"ldapAuthenticated,omitempty" json:"ldapAuthenticated,omitempty"`

	// AdminRole Whether the user is administrator.
	AdminRole *bool `form:"adminRole,omitempty" json:"adminRole,omitempty"`

	// SettingsRole Whether the user is allowed to change personal settings and password.
	SettingsRole *bool `form:"settingsRole,omitempty" json:"settingsRole,omitempty"`

	// StreamRole Whether the user is allowed to play files.
	StreamRole *bool `form:"streamRole,omitempty" json:"streamRole,omitempty"`

	// JukeboxRole Whether the user is allowed to play files in jukebox mode.
	JukeboxRole *bool `form:"jukeboxRole,omitempty" json:"jukeboxRole,omitempty"`

	// DownloadRole Whether the user is allowed to download files.
	DownloadRole *bool `form:"downloadRole,omitempty" json:"downloadRole,omitempty"`

	// UploadRole Whether the user is allowed to upload files.
	UploadRole *bool `form:"uploadRole,omitempty" json:"uploadRole,omitempty"`

	// CoverArtRole Whether the user is allowed to change cover art and tags.
	CoverArtRole *bool `form:"coverArtRole,omitempty" json:"coverArtRole,omitempty"`

	// CommentRole Whether the user is allowed to create and edit comments and ratings.
	CommentRole *bool `form:"commentRole,omitempty" json:"commentRole,omitempty"`

	// PodcastRole Whether the user is allowed to administrate Podcasts.
	PodcastRole *bool `form:"podcastRole,omitempty" json:"podcastRole,omitempty"`

	// ShareRole Whether the user is allowed to share files with anyone.
	ShareRole *bool `form:"shareRole,omitempty" json:"shareRole,omitempty"`

	// VideoConversionRole (Since 1.15.0) Whether the user is allowed to start video conversions.
	VideoConversionRole *bool `form:"videoConversionRole,omitempty" json:"videoConversionRole,omitempty"`

	// MusicFolderId (Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder.
	MusicFolderId *[]string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`

	// MaxBitRate (Since 1.13.0) The maximum bit rate (in Kbps) for the user. Audio streams of higher bit rates are automatically downsampled to this bit rate. Legal values: 0 (no limit), 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320.
	MaxBitRate *UpdateUserParamsMaxBitRate `form:"maxBitRate,omitempty" json:"maxBitRate,omitempty"`
}

// UpdateUserParamsMaxBitRate defines parameters for UpdateUser.
type UpdateUserParamsMaxBitRate int

// PostUpdateUserFormdataBody defines parameters for PostUpdateUser.
type PostUpdateUserFormdataBody struct {
	// AdminRole Whether the user is an administrator.
	AdminRole *bool `form:"adminRole,omitempty" json:"adminRole,omitempty"`

	// CommentRole Whether the user is allowed to create and edit comments and ratings.
	CommentRole *bool `form:"commentRole,omitempty" json:"commentRole,omitempty"`

	// CoverArtRole Whether the user is allowed to change cover art and tags.
	CoverArtRole *bool `form:"coverArtRole,omitempty" json:"coverArtRole,omitempty"`

	// DownloadRole Whether the user is allowed to download files.
	DownloadRole *bool `form:"downloadRole,omitempty" json:"downloadRole,omitempty"`

	// Email The email address of the user.
	Email *string `form:"email,omitempty" json:"email,omitempty"`

	// JukeboxRole Whether the user is allowed to play files in jukebox mode.
	JukeboxRole *bool `form:"jukeboxRole,omitempty" json:"jukeboxRole,omitempty"`

	// LdapAuthenticated Whether the user is authenticated in LDAP.
	LdapAuthenticated *bool `form:"ldapAuthenticated,omitempty" json:"ldapAuthenticated,omitempty"`

	// MaxBitRate (Since 1.13.0) The maximum bit rate (in Kbps) for the user. Audio streams of higher bit rates are automatically downsampled to this bit rate. Legal values: 0 (no limit), 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320.
	MaxBitRate *PostUpdateUserFormdataBodyMaxBitRate `form:"maxBitRate,omitempty" json:"maxBitRate,omitempty"`

	// MusicFolderId (Since 1.12.0) IDs of the music folders the user is allowed access to. Include the parameter once for each folder.
	MusicFolderId *[]string `form:"musicFolderId,omitempty" json:"musicFolderId,omitempty"`

	// Password The password of the user, either in clear text or hex-encoded.
	Password string `form:"password" json:"password"`

	// PodcastRole Whether the user is allowed to administrate Podcasts.
	PodcastRole *bool `form:"podcastRole,omitempty" json:"podcastRole,omitempty"`

	// SettingsRole Whether the user is allowed to change personal settings and password.
	SettingsRole *bool `form:"settingsRole,omitempty" json:"settingsRole,omitempty"`

	// ShareRole Whether the user is allowed to share files with anyone.
	ShareRole *bool `form:"shareRole,omitempty" json:"shareRole,omitempty"`

	// StreamRole Whether the user is allowed to play files.
	StreamRole *bool `form:"streamRole,omitempty" json:"streamRole,omitempty"`

	// UploadRole Whether the user is allowed to upload files.
	UploadRole *bool `form:"uploadRole,omitempty" json:"uploadRole,omitempty"`

	// Username The name of the user.
	Username string `form:"username" json:"username"`

	// VideoConversionRole (Since 1.15.0) Whether the user is allowed to start video conversions.
	VideoConversionRole *bool `form:"videoConversionRole,omitempty" json:"videoConversionRole,omitempty"`
}

// PostUpdateUserFormdataBodyMaxBitRate defines parameters for PostUpdateUser.
type PostUpdateUserFormdataBodyMaxBitRate int

// PostAddChatMessageFormdataRequestBody defines body for PostAddChatMessage for application/x-www-form-urlencoded ContentType.
type PostAddChatMessageFormdataRequestBody PostAddChatMessageFormdataBody

// PostChangePasswordFormdataRequestBody defines body for PostChangePassword for application/x-www-form-urlencoded ContentType.
type PostChangePasswordFormdataRequestBody PostChangePasswordFormdataBody

// PostCreateBookmarkFormdataRequestBody defines body for PostCreateBookmark for application/x-www-form-urlencoded ContentType.
type PostCreateBookmarkFormdataRequestBody PostCreateBookmarkFormdataBody

// PostCreateInternetRadioStationFormdataRequestBody defines body for PostCreateInternetRadioStation for application/x-www-form-urlencoded ContentType.
type PostCreateInternetRadioStationFormdataRequestBody PostCreateInternetRadioStationFormdataBody

// PostCreatePlaylistFormdataRequestBody defines body for PostCreatePlaylist for application/x-www-form-urlencoded ContentType.
type PostCreatePlaylistFormdataRequestBody PostCreatePlaylistFormdataBody

// PostCreatePodcastChannelFormdataRequestBody defines body for PostCreatePodcastChannel for application/x-www-form-urlencoded ContentType.
type PostCreatePodcastChannelFormdataRequestBody PostCreatePodcastChannelFormdataBody

// PostCreateShareFormdataRequestBody defines body for PostCreateShare for application/x-www-form-urlencoded ContentType.
type PostCreateShareFormdataRequestBody PostCreateShareFormdataBody

// PostCreateUserFormdataRequestBody defines body for PostCreateUser for application/x-www-form-urlencoded ContentType.
type PostCreateUserFormdataRequestBody PostCreateUserFormdataBody

// PostDeleteBookmarkFormdataRequestBody defines body for PostDeleteBookmark for application/x-www-form-urlencoded ContentType.
type PostDeleteBookmarkFormdataRequestBody PostDeleteBookmarkFormdataBody

// PostDeleteInternetRadioStationFormdataRequestBody defines body for PostDeleteInternetRadioStation for application/x-www-form-urlencoded ContentType.
type PostDeleteInternetRadioStationFormdataRequestBody PostDeleteInternetRadioStationFormdataBody

// PostDeletePlaylistFormdataRequestBody defines body for PostDeletePlaylist for application/x-www-form-urlencoded ContentType.
type PostDeletePlaylistFormdataRequestBody PostDeletePlaylistFormdataBody

// PostDeletePodcastChannelFormdataRequestBody defines body for PostDeletePodcastChannel for application/x-www-form-urlencoded ContentType.
type PostDeletePodcastChannelFormdataRequestBody PostDeletePodcastChannelFormdataBody

// PostDeletePodcastEpisodeFormdataRequestBody defines body for PostDeletePodcastEpisode for application/x-www-form-urlencoded ContentType.
type PostDeletePodcastEpisodeFormdataRequestBody PostDeletePodcastEpisodeFormdataBody

// PostDeleteShareFormdataRequestBody defines body for PostDeleteShare for application/x-www-form-urlencoded ContentType.
type PostDeleteShareFormdataRequestBody PostDeleteShareFormdataBody

// PostDeleteUserFormdataRequestBody defines body for PostDeleteUser for application/x-www-form-urlencoded ContentType.
type PostDeleteUserFormdataRequestBody PostDeleteUserFormdataBody

// PostDownloadFormdataRequestBody defines body for PostDownload for application/x-www-form-urlencoded ContentType.
type PostDownloadFormdataRequestBody PostDownloadFormdataBody

// PostDownloadPodcastEpisodeFormdataRequestBody defines body for PostDownloadPodcastEpisode for application/x-www-form-urlencoded ContentType.
type PostDownloadPodcastEpisodeFormdataRequestBody PostDownloadPodcastEpisodeFormdataBody

// PostGetAlbumFormdataRequestBody defines body for PostGetAlbum for application/x-www-form-urlencoded ContentType.
type PostGetAlbumFormdataRequestBody PostGetAlbumFormdataBody

// PostGetAlbumInfoFormdataRequestBody defines body for PostGetAlbumInfo for application/x-www-form-urlencoded ContentType.
type PostGetAlbumInfoFormdataRequestBody PostGetAlbumInfoFormdataBody

// PostGetAlbumInfo2FormdataRequestBody defines body for PostGetAlbumInfo2 for application/x-www-form-urlencoded ContentType.
type PostGetAlbumInfo2FormdataRequestBody PostGetAlbumInfo2FormdataBody

// PostGetAlbumListFormdataRequestBody defines body for PostGetAlbumList for application/x-www-form-urlencoded ContentType.
type PostGetAlbumListFormdataRequestBody PostGetAlbumListFormdataBody

// PostGetAlbumList2FormdataRequestBody defines body for PostGetAlbumList2 for application/x-www-form-urlencoded ContentType.
type PostGetAlbumList2FormdataRequestBody PostGetAlbumList2FormdataBody

// PostGetArtistFormdataRequestBody defines body for PostGetArtist for application/x-www-form-urlencoded ContentType.
type PostGetArtistFormdataRequestBody PostGetArtistFormdataBody

// PostGetArtistInfoFormdataRequestBody defines body for PostGetArtistInfo for application/x-www-form-urlencoded ContentType.
type PostGetArtistInfoFormdataRequestBody PostGetArtistInfoFormdataBody

// PostGetArtistInfo2FormdataRequestBody defines body for PostGetArtistInfo2 for application/x-www-form-urlencoded ContentType.
type PostGetArtistInfo2FormdataRequestBody PostGetArtistInfo2FormdataBody

// PostGetArtistsFormdataRequestBody defines body for PostGetArtists for application/x-www-form-urlencoded ContentType.
type PostGetArtistsFormdataRequestBody PostGetArtistsFormdataBody

// PostGetAvatarFormdataRequestBody defines body for PostGetAvatar for application/x-www-form-urlencoded ContentType.
type PostGetAvatarFormdataRequestBody PostGetAvatarFormdataBody

// PostGetBookmarksFormdataRequestBody defines body for PostGetBookmarks for application/x-www-form-urlencoded ContentType.
type PostGetBookmarksFormdataRequestBody = PostGetBookmarksFormdataBody

// PostGetCaptionsFormdataRequestBody defines body for PostGetCaptions for application/x-www-form-urlencoded ContentType.
type PostGetCaptionsFormdataRequestBody PostGetCaptionsFormdataBody

// PostGetChatMessagesFormdataRequestBody defines body for PostGetChatMessages for application/x-www-form-urlencoded ContentType.
type PostGetChatMessagesFormdataRequestBody = PostGetChatMessagesFormdataBody

// PostGetCoverArtFormdataRequestBody defines body for PostGetCoverArt for application/x-www-form-urlencoded ContentType.
type PostGetCoverArtFormdataRequestBody PostGetCoverArtFormdataBody

// PostGetGenresFormdataRequestBody defines body for PostGetGenres for application/x-www-form-urlencoded ContentType.
type PostGetGenresFormdataRequestBody = PostGetGenresFormdataBody

// PostGetIndexesFormdataRequestBody defines body for PostGetIndexes for application/x-www-form-urlencoded ContentType.
type PostGetIndexesFormdataRequestBody PostGetIndexesFormdataBody

// PostGetInternetRadioStationsFormdataRequestBody defines body for PostGetInternetRadioStations for application/x-www-form-urlencoded ContentType.
type PostGetInternetRadioStationsFormdataRequestBody = PostGetInternetRadioStationsFormdataBody

// PostGetLicenseFormdataRequestBody defines body for PostGetLicense for application/x-www-form-urlencoded ContentType.
type PostGetLicenseFormdataRequestBody = PostGetLicenseFormdataBody

// PostGetLyricsFormdataRequestBody defines body for PostGetLyrics for application/x-www-form-urlencoded ContentType.
type PostGetLyricsFormdataRequestBody PostGetLyricsFormdataBody

// PostGetLyricsBySongIdFormdataRequestBody defines body for PostGetLyricsBySongId for application/x-www-form-urlencoded ContentType.
type PostGetLyricsBySongIdFormdataRequestBody PostGetLyricsBySongIdFormdataBody

// PostGetMusicDirectoryFormdataRequestBody defines body for PostGetMusicDirectory for application/x-www-form-urlencoded ContentType.
type PostGetMusicDirectoryFormdataRequestBody PostGetMusicDirectoryFormdataBody

// PostGetMusicFoldersFormdataRequestBody defines body for PostGetMusicFolders for application/x-www-form-urlencoded ContentType.
type PostGetMusicFoldersFormdataRequestBody = PostGetMusicFoldersFormdataBody

// PostGetNewestPodcastsFormdataRequestBody defines body for PostGetNewestPodcasts for application/x-www-form-urlencoded ContentType.
type PostGetNewestPodcastsFormdataRequestBody PostGetNewestPodcastsFormdataBody

// PostGetNowPlayingFormdataRequestBody defines body for PostGetNowPlaying for application/x-www-form-urlencoded ContentType.
type PostGetNowPlayingFormdataRequestBody = PostGetNowPlayingFormdataBody

// PostGetOpenSubsonicExtensionsFormdataRequestBody defines body for PostGetOpenSubsonicExtensions for application/x-www-form-urlencoded ContentType.
type PostGetOpenSubsonicExtensionsFormdataRequestBody = PostGetOpenSubsonicExtensionsFormdataBody

// PostGetPlayQueueFormdataRequestBody defines body for PostGetPlayQueue for application/x-www-form-urlencoded ContentType.
type PostGetPlayQueueFormdataRequestBody = PostGetPlayQueueFormdataBody

// PostGetPlayQueueByIndexFormdataRequestBody defines body for PostGetPlayQueueByIndex for application/x-www-form-urlencoded ContentType.
type PostGetPlayQueueByIndexFormdataRequestBody = PostGetPlayQueueByIndexFormdataBody

// PostGetPlaylistFormdataRequestBody defines body for PostGetPlaylist for application/x-www-form-urlencoded ContentType.
type PostGetPlaylistFormdataRequestBody PostGetPlaylistFormdataBody

// PostGetPlaylistsFormdataRequestBody defines body for PostGetPlaylists for application/x-www-form-urlencoded ContentType.
type PostGetPlaylistsFormdataRequestBody PostGetPlaylistsFormdataBody

// PostGetPodcastEpisodeFormdataRequestBody defines body for PostGetPodcastEpisode for application/x-www-form-urlencoded ContentType.
type PostGetPodcastEpisodeFormdataRequestBody PostGetPodcastEpisodeFormdataBody

// PostGetPodcastsFormdataRequestBody defines body for PostGetPodcasts for application/x-www-form-urlencoded ContentType.
type PostGetPodcastsFormdataRequestBody PostGetPodcastsFormdataBody

// PostGetRandomSongsFormdataRequestBody defines body for PostGetRandomSongs for application/x-www-form-urlencoded ContentType.
type PostGetRandomSongsFormdataRequestBody PostGetRandomSongsFormdataBody

// PostGetScanStatusFormdataRequestBody defines body for PostGetScanStatus for application/x-www-form-urlencoded ContentType.
type PostGetScanStatusFormdataRequestBody = PostGetScanStatusFormdataBody

// PostGetSharesFormdataRequestBody defines body for PostGetShares for application/x-www-form-urlencoded ContentType.
type PostGetSharesFormdataRequestBody = PostGetSharesFormdataBody

// PostGetSimilarSongsFormdataRequestBody defines body for PostGetSimilarSongs for application/x-www-form-urlencoded ContentType.
type PostGetSimilarSongsFormdataRequestBody PostGetSimilarSongsFormdataBody

// PostGetSimilarSongs2FormdataRequestBody defines body for PostGetSimilarSongs2 for application/x-www-form-urlencoded ContentType.
type PostGetSimilarSongs2FormdataRequestBody PostGetSimilarSongs2FormdataBody

// PostGetSongFormdataRequestBody defines body for PostGetSong for application/x-www-form-urlencoded ContentType.
type PostGetSongFormdataRequestBody PostGetSongFormdataBody

// PostGetSongsByGenreFormdataRequestBody defines body for PostGetSongsByGenre for application/x-www-form-urlencoded ContentType.
type PostGetSongsByGenreFormdataRequestBody PostGetSongsByGenreFormdataBody

// PostGetStarredFormdataRequestBody defines body for PostGetStarred for application/x-www-form-urlencoded ContentType.
type PostGetStarredFormdataRequestBody = PostGetStarredFormdataBody

// PostGetStarred2FormdataRequestBody defines body for PostGetStarred2 for application/x-www-form-urlencoded ContentType.
type PostGetStarred2FormdataRequestBody = PostGetStarred2FormdataBody

// PostGetTopSongsFormdataRequestBody defines body for PostGetTopSongs for application/x-www-form-urlencoded ContentType.
type PostGetTopSongsFormdataRequestBody PostGetTopSongsFormdataBody

// GetTranscodeDecisionJSONRequestBody defines body for GetTranscodeDecision for application/json ContentType.
type GetTranscodeDecisionJSONRequestBody = ClientInfo

// PostGetUserFormdataRequestBody defines body for PostGetUser for application/x-www-form-urlencoded ContentType.
type PostGetUserFormdataRequestBody PostGetUserFormdataBody

// PostGetUsersFormdataRequestBody defines body for PostGetUsers for application/x-www-form-urlencoded ContentType.
type PostGetUsersFormdataRequestBody = PostGetUsersFormdataBody

// PostGetVideoInfoFormdataRequestBody defines body for PostGetVideoInfo for application/x-www-form-urlencoded ContentType.
type PostGetVideoInfoFormdataRequestBody PostGetVideoInfoFormdataBody

// PostGetVideosFormdataRequestBody defines body for PostGetVideos for application/x-www-form-urlencoded ContentType.
type PostGetVideosFormdataRequestBody = PostGetVideosFormdataBody

// PostHlsM3u8FormdataRequestBody defines body for PostHlsM3u8 for application/x-www-form-urlencoded ContentType.
type PostHlsM3u8FormdataRequestBody PostHlsM3u8FormdataBody

// PostJukeboxControlFormdataRequestBody defines body for PostJukeboxControl for application/x-www-form-urlencoded ContentType.
type PostJukeboxControlFormdataRequestBody PostJukeboxControlFormdataBody

// PostPingFormdataRequestBody defines body for PostPing for application/x-www-form-urlencoded ContentType.
type PostPingFormdataRequestBody = PostPingFormdataBody

// PostRefreshPodcastsFormdataRequestBody defines body for PostRefreshPodcasts for application/x-www-form-urlencoded ContentType.
type PostRefreshPodcastsFormdataRequestBody = PostRefreshPodcastsFormdataBody

// PostSavePlayQueueFormdataRequestBody defines body for PostSavePlayQueue for application/x-www-form-urlencoded ContentType.
type PostSavePlayQueueFormdataRequestBody PostSavePlayQueueFormdataBody

// PostSavePlayQueueByIndexFormdataRequestBody defines body for PostSavePlayQueueByIndex for application/x-www-form-urlencoded ContentType.
type PostSavePlayQueueByIndexFormdataRequestBody PostSavePlayQueueByIndexFormdataBody

// PostScrobbleFormdataRequestBody defines body for PostScrobble for application/x-www-form-urlencoded ContentType.
type PostScrobbleFormdataRequestBody PostScrobbleFormdataBody

// PostSearchFormdataRequestBody defines body for PostSearch for application/x-www-form-urlencoded ContentType.
type PostSearchFormdataRequestBody PostSearchFormdataBody

// PostSearch2FormdataRequestBody defines body for PostSearch2 for application/x-www-form-urlencoded ContentType.
type PostSearch2FormdataRequestBody PostSearch2FormdataBody

// PostSearch3FormdataRequestBody defines body for PostSearch3 for application/x-www-form-urlencoded ContentType.
type PostSearch3FormdataRequestBody PostSearch3FormdataBody

// PostSetRatingFormdataRequestBody defines body for PostSetRating for application/x-www-form-urlencoded ContentType.
type PostSetRatingFormdataRequestBody PostSetRatingFormdataBody

// PostStarFormdataRequestBody defines body for PostStar for application/x-www-form-urlencoded ContentType.
type PostStarFormdataRequestBody PostStarFormdataBody

// PostStartScanFormdataRequestBody defines body for PostStartScan for application/x-www-form-urlencoded ContentType.
type PostStartScanFormdataRequestBody = PostStartScanFormdataBody

// PostStreamFormdataRequestBody defines body for PostStream for application/x-www-form-urlencoded ContentType.
type PostStreamFormdataRequestBody PostStreamFormdataBody

// PostTokenInfoFormdataRequestBody defines body for PostTokenInfo for application/x-www-form-urlencoded ContentType.
type PostTokenInfoFormdataRequestBody = PostTokenInfoFormdataBody

// PostUnstarFormdataRequestBody defines body for PostUnstar for application/x-www-form-urlencoded ContentType.
type PostUnstarFormdataRequestBody PostUnstarFormdataBody

// PostUpdateInternetRadioStationFormdataRequestBody defines body for PostUpdateInternetRadioStation for application/x-www-form-urlencoded ContentType.
type PostUpdateInternetRadioStationFormdataRequestBody PostUpdateInternetRadioStationFormdataBody

// PostUpdatePlaylistFormdataRequestBody defines body for PostUpdatePlaylist for application/x-www-form-urlencoded ContentType.
type PostUpdatePlaylistFormdataRequestBody PostUpdatePlaylistFormdataBody

// PostUpdateShareFormdataRequestBody defines body for PostUpdateShare for application/x-www-form-urlencoded ContentType.
type PostUpdateShareFormdataRequestBody PostUpdateShareFormdataBody

// PostUpdateUserFormdataRequestBody defines body for PostUpdateUser for application/x-www-form-urlencoded ContentType.
type PostUpdateUserFormdataRequestBody PostUpdateUserFormdataBody

// AsCreatePlaylistSuccessResponse returns the union data inside the CreatePlaylistResponse_SubsonicResponse as a CreatePlaylistSuccessResponse
func (t CreatePlaylistResponse_SubsonicResponse) AsCreatePlaylistSuccessResponse() (CreatePlaylistSuccessResponse, error) {
	var body CreatePlaylistSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePlaylistSuccessResponse overwrites any union data inside the CreatePlaylistResponse_SubsonicResponse as the provided CreatePlaylistSuccessResponse
func (t *CreatePlaylistResponse_SubsonicResponse) FromCreatePlaylistSuccessResponse(v CreatePlaylistSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePlaylistSuccessResponse performs a merge with any union data inside the CreatePlaylistResponse_SubsonicResponse, using the provided CreatePlaylistSuccessResponse
func (t *CreatePlaylistResponse_SubsonicResponse) MergeCreatePlaylistSuccessResponse(v CreatePlaylistSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the CreatePlaylistResponse_SubsonicResponse as a SubsonicFailureResponse
func (t CreatePlaylistResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the CreatePlaylistResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *CreatePlaylistResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the CreatePlaylistResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *CreatePlaylistResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePlaylistResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePlaylistResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateSharesSuccessResponse returns the union data inside the CreateSharesResponse_SubsonicResponse as a CreateSharesSuccessResponse
func (t CreateSharesResponse_SubsonicResponse) AsCreateSharesSuccessResponse() (CreateSharesSuccessResponse, error) {
	var body CreateSharesSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSharesSuccessResponse overwrites any union data inside the CreateSharesResponse_SubsonicResponse as the provided CreateSharesSuccessResponse
func (t *CreateSharesResponse_SubsonicResponse) FromCreateSharesSuccessResponse(v CreateSharesSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSharesSuccessResponse performs a merge with any union data inside the CreateSharesResponse_SubsonicResponse, using the provided CreateSharesSuccessResponse
func (t *CreateSharesResponse_SubsonicResponse) MergeCreateSharesSuccessResponse(v CreateSharesSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the CreateSharesResponse_SubsonicResponse as a SubsonicFailureResponse
func (t CreateSharesResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the CreateSharesResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *CreateSharesResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the CreateSharesResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *CreateSharesResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateSharesResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateSharesResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetAlbumInfoSuccessResponse returns the union data inside the GetAlbumInfoResponse_SubsonicResponse as a GetAlbumInfoSuccessResponse
func (t GetAlbumInfoResponse_SubsonicResponse) AsGetAlbumInfoSuccessResponse() (GetAlbumInfoSuccessResponse, error) {
	var body GetAlbumInfoSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetAlbumInfoSuccessResponse overwrites any union data inside the GetAlbumInfoResponse_SubsonicResponse as the provided GetAlbumInfoSuccessResponse
func (t *GetAlbumInfoResponse_SubsonicResponse) FromGetAlbumInfoSuccessResponse(v GetAlbumInfoSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetAlbumInfoSuccessResponse performs a merge with any union data inside the GetAlbumInfoResponse_SubsonicResponse, using the provided GetAlbumInfoSuccessResponse
func (t *GetAlbumInfoResponse_SubsonicResponse) MergeGetAlbumInfoSuccessResponse(v GetAlbumInfoSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetAlbumInfoResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetAlbumInfoResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetAlbumInfoResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetAlbumInfoResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetAlbumInfoResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetAlbumInfoResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetAlbumInfoResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetAlbumInfoResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetAlbumList2SuccessResponse returns the union data inside the GetAlbumList2Response_SubsonicResponse as a GetAlbumList2SuccessResponse
func (t GetAlbumList2Response_SubsonicResponse) AsGetAlbumList2SuccessResponse() (GetAlbumList2SuccessResponse, error) {
	var body GetAlbumList2SuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetAlbumList2SuccessResponse overwrites any union data inside the GetAlbumList2Response_SubsonicResponse as the provided GetAlbumList2SuccessResponse
func (t *GetAlbumList2Response_SubsonicResponse) FromGetAlbumList2SuccessResponse(v GetAlbumList2SuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetAlbumList2SuccessResponse performs a merge with any union data inside the GetAlbumList2Response_SubsonicResponse, using the provided GetAlbumList2SuccessResponse
func (t *GetAlbumList2Response_SubsonicResponse) MergeGetAlbumList2SuccessResponse(v GetAlbumList2SuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetAlbumList2Response_SubsonicResponse as a SubsonicFailureResponse
func (t GetAlbumList2Response_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetAlbumList2Response_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetAlbumList2Response_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetAlbumList2Response_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetAlbumList2Response_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetAlbumList2Response_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetAlbumList2Response_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetAlbumListSuccessResponse returns the union data inside the GetAlbumListResponse_SubsonicResponse as a GetAlbumListSuccessResponse
func (t GetAlbumListResponse_SubsonicResponse) AsGetAlbumListSuccessResponse() (GetAlbumListSuccessResponse, error) {
	var body GetAlbumListSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetAlbumListSuccessResponse overwrites any union data inside the GetAlbumListResponse_SubsonicResponse as the provided GetAlbumListSuccessResponse
func (t *GetAlbumListResponse_SubsonicResponse) FromGetAlbumListSuccessResponse(v GetAlbumListSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetAlbumListSuccessResponse performs a merge with any union data inside the GetAlbumListResponse_SubsonicResponse, using the provided GetAlbumListSuccessResponse
func (t *GetAlbumListResponse_SubsonicResponse) MergeGetAlbumListSuccessResponse(v GetAlbumListSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetAlbumListResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetAlbumListResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetAlbumListResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetAlbumListResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetAlbumListResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetAlbumListResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetAlbumListResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetAlbumListResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetAlbumSuccessResponse returns the union data inside the GetAlbumResponse_SubsonicResponse as a GetAlbumSuccessResponse
func (t GetAlbumResponse_SubsonicResponse) AsGetAlbumSuccessResponse() (GetAlbumSuccessResponse, error) {
	var body GetAlbumSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetAlbumSuccessResponse overwrites any union data inside the GetAlbumResponse_SubsonicResponse as the provided GetAlbumSuccessResponse
func (t *GetAlbumResponse_SubsonicResponse) FromGetAlbumSuccessResponse(v GetAlbumSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetAlbumSuccessResponse performs a merge with any union data inside the GetAlbumResponse_SubsonicResponse, using the provided GetAlbumSuccessResponse
func (t *GetAlbumResponse_SubsonicResponse) MergeGetAlbumSuccessResponse(v GetAlbumSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetAlbumResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetAlbumResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetAlbumResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetAlbumResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetAlbumResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetAlbumResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetAlbumResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetAlbumResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetArtistInfo2SuccessResponse returns the union data inside the GetArtistInfo2Response_SubsonicResponse as a GetArtistInfo2SuccessResponse
func (t GetArtistInfo2Response_SubsonicResponse) AsGetArtistInfo2SuccessResponse() (GetArtistInfo2SuccessResponse, error) {
	var body GetArtistInfo2SuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetArtistInfo2SuccessResponse overwrites any union data inside the GetArtistInfo2Response_SubsonicResponse as the provided GetArtistInfo2SuccessResponse
func (t *GetArtistInfo2Response_SubsonicResponse) FromGetArtistInfo2SuccessResponse(v GetArtistInfo2SuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetArtistInfo2SuccessResponse performs a merge with any union data inside the GetArtistInfo2Response_SubsonicResponse, using the provided GetArtistInfo2SuccessResponse
func (t *GetArtistInfo2Response_SubsonicResponse) MergeGetArtistInfo2SuccessResponse(v GetArtistInfo2SuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetArtistInfo2Response_SubsonicResponse as a SubsonicFailureResponse
func (t GetArtistInfo2Response_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetArtistInfo2Response_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetArtistInfo2Response_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetArtistInfo2Response_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetArtistInfo2Response_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetArtistInfo2Response_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetArtistInfo2Response_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetArtistInfoSuccessResponse returns the union data inside the GetArtistInfoResponse_SubsonicResponse as a GetArtistInfoSuccessResponse
func (t GetArtistInfoResponse_SubsonicResponse) AsGetArtistInfoSuccessResponse() (GetArtistInfoSuccessResponse, error) {
	var body GetArtistInfoSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetArtistInfoSuccessResponse overwrites any union data inside the GetArtistInfoResponse_SubsonicResponse as the provided GetArtistInfoSuccessResponse
func (t *GetArtistInfoResponse_SubsonicResponse) FromGetArtistInfoSuccessResponse(v GetArtistInfoSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetArtistInfoSuccessResponse performs a merge with any union data inside the GetArtistInfoResponse_SubsonicResponse, using the provided GetArtistInfoSuccessResponse
func (t *GetArtistInfoResponse_SubsonicResponse) MergeGetArtistInfoSuccessResponse(v GetArtistInfoSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetArtistInfoResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetArtistInfoResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetArtistInfoResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetArtistInfoResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetArtistInfoResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetArtistInfoResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetArtistInfoResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetArtistInfoResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetArtistSuccessResponse returns the union data inside the GetArtistResponse_SubsonicResponse as a GetArtistSuccessResponse
func (t GetArtistResponse_SubsonicResponse) AsGetArtistSuccessResponse() (GetArtistSuccessResponse, error) {
	var body GetArtistSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetArtistSuccessResponse overwrites any union data inside the GetArtistResponse_SubsonicResponse as the provided GetArtistSuccessResponse
func (t *GetArtistResponse_SubsonicResponse) FromGetArtistSuccessResponse(v GetArtistSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetArtistSuccessResponse performs a merge with any union data inside the GetArtistResponse_SubsonicResponse, using the provided GetArtistSuccessResponse
func (t *GetArtistResponse_SubsonicResponse) MergeGetArtistSuccessResponse(v GetArtistSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetArtistResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetArtistResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetArtistResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetArtistResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetArtistResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetArtistResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetArtistResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetArtistResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetArtistsSuccessResponse returns the union data inside the GetArtistsResponse_SubsonicResponse as a GetArtistsSuccessResponse
func (t GetArtistsResponse_SubsonicResponse) AsGetArtistsSuccessResponse() (GetArtistsSuccessResponse, error) {
	var body GetArtistsSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetArtistsSuccessResponse overwrites any union data inside the GetArtistsResponse_SubsonicResponse as the provided GetArtistsSuccessResponse
func (t *GetArtistsResponse_SubsonicResponse) FromGetArtistsSuccessResponse(v GetArtistsSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetArtistsSuccessResponse performs a merge with any union data inside the GetArtistsResponse_SubsonicResponse, using the provided GetArtistsSuccessResponse
func (t *GetArtistsResponse_SubsonicResponse) MergeGetArtistsSuccessResponse(v GetArtistsSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetArtistsResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetArtistsResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetArtistsResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetArtistsResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetArtistsResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetArtistsResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetArtistsResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetArtistsResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetBookmarksSuccessResponse returns the union data inside the GetBookmarksResponse_SubsonicResponse as a GetBookmarksSuccessResponse
func (t GetBookmarksResponse_SubsonicResponse) AsGetBookmarksSuccessResponse() (GetBookmarksSuccessResponse, error) {
	var body GetBookmarksSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetBookmarksSuccessResponse overwrites any union data inside the GetBookmarksResponse_SubsonicResponse as the provided GetBookmarksSuccessResponse
func (t *GetBookmarksResponse_SubsonicResponse) FromGetBookmarksSuccessResponse(v GetBookmarksSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetBookmarksSuccessResponse performs a merge with any union data inside the GetBookmarksResponse_SubsonicResponse, using the provided GetBookmarksSuccessResponse
func (t *GetBookmarksResponse_SubsonicResponse) MergeGetBookmarksSuccessResponse(v GetBookmarksSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetBookmarksResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetBookmarksResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetBookmarksResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetBookmarksResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetBookmarksResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetBookmarksResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetBookmarksResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetBookmarksResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetChatMessagesSuccessResponse returns the union data inside the GetChatMessagesResponse_SubsonicResponse as a GetChatMessagesSuccessResponse
func (t GetChatMessagesResponse_SubsonicResponse) AsGetChatMessagesSuccessResponse() (GetChatMessagesSuccessResponse, error) {
	var body GetChatMessagesSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetChatMessagesSuccessResponse overwrites any union data inside the GetChatMessagesResponse_SubsonicResponse as the provided GetChatMessagesSuccessResponse
func (t *GetChatMessagesResponse_SubsonicResponse) FromGetChatMessagesSuccessResponse(v GetChatMessagesSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetChatMessagesSuccessResponse performs a merge with any union data inside the GetChatMessagesResponse_SubsonicResponse, using the provided GetChatMessagesSuccessResponse
func (t *GetChatMessagesResponse_SubsonicResponse) MergeGetChatMessagesSuccessResponse(v GetChatMessagesSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetChatMessagesResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetChatMessagesResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetChatMessagesResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetChatMessagesResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetChatMessagesResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetChatMessagesResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetChatMessagesResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetChatMessagesResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetGenresSuccessResponse returns the union data inside the GetGenresResponse_SubsonicResponse as a GetGenresSuccessResponse
func (t GetGenresResponse_SubsonicResponse) AsGetGenresSuccessResponse() (GetGenresSuccessResponse, error) {
	var body GetGenresSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetGenresSuccessResponse overwrites any union data inside the GetGenresResponse_SubsonicResponse as the provided GetGenresSuccessResponse
func (t *GetGenresResponse_SubsonicResponse) FromGetGenresSuccessResponse(v GetGenresSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetGenresSuccessResponse performs a merge with any union data inside the GetGenresResponse_SubsonicResponse, using the provided GetGenresSuccessResponse
func (t *GetGenresResponse_SubsonicResponse) MergeGetGenresSuccessResponse(v GetGenresSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetGenresResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetGenresResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetGenresResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetGenresResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetGenresResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetGenresResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetGenresResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetGenresResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetIndexesSuccessResponse returns the union data inside the GetIndexesResponse_SubsonicResponse as a GetIndexesSuccessResponse
func (t GetIndexesResponse_SubsonicResponse) AsGetIndexesSuccessResponse() (GetIndexesSuccessResponse, error) {
	var body GetIndexesSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetIndexesSuccessResponse overwrites any union data inside the GetIndexesResponse_SubsonicResponse as the provided GetIndexesSuccessResponse
func (t *GetIndexesResponse_SubsonicResponse) FromGetIndexesSuccessResponse(v GetIndexesSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetIndexesSuccessResponse performs a merge with any union data inside the GetIndexesResponse_SubsonicResponse, using the provided GetIndexesSuccessResponse
func (t *GetIndexesResponse_SubsonicResponse) MergeGetIndexesSuccessResponse(v GetIndexesSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetIndexesResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetIndexesResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetIndexesResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetIndexesResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetIndexesResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetIndexesResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetIndexesResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetIndexesResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetInternetRadioStationsSuccessResponse returns the union data inside the GetInternetRadioStationsResponse_SubsonicResponse as a GetInternetRadioStationsSuccessResponse
func (t GetInternetRadioStationsResponse_SubsonicResponse) AsGetInternetRadioStationsSuccessResponse() (GetInternetRadioStationsSuccessResponse, error) {
	var body GetInternetRadioStationsSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetInternetRadioStationsSuccessResponse overwrites any union data inside the GetInternetRadioStationsResponse_SubsonicResponse as the provided GetInternetRadioStationsSuccessResponse
func (t *GetInternetRadioStationsResponse_SubsonicResponse) FromGetInternetRadioStationsSuccessResponse(v GetInternetRadioStationsSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetInternetRadioStationsSuccessResponse performs a merge with any union data inside the GetInternetRadioStationsResponse_SubsonicResponse, using the provided GetInternetRadioStationsSuccessResponse
func (t *GetInternetRadioStationsResponse_SubsonicResponse) MergeGetInternetRadioStationsSuccessResponse(v GetInternetRadioStationsSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetInternetRadioStationsResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetInternetRadioStationsResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetInternetRadioStationsResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetInternetRadioStationsResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetInternetRadioStationsResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetInternetRadioStationsResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetInternetRadioStationsResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetInternetRadioStationsResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetLicenseSuccessResponse returns the union data inside the GetLicenseResponse_SubsonicResponse as a GetLicenseSuccessResponse
func (t GetLicenseResponse_SubsonicResponse) AsGetLicenseSuccessResponse() (GetLicenseSuccessResponse, error) {
	var body GetLicenseSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetLicenseSuccessResponse overwrites any union data inside the GetLicenseResponse_SubsonicResponse as the provided GetLicenseSuccessResponse
func (t *GetLicenseResponse_SubsonicResponse) FromGetLicenseSuccessResponse(v GetLicenseSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetLicenseSuccessResponse performs a merge with any union data inside the GetLicenseResponse_SubsonicResponse, using the provided GetLicenseSuccessResponse
func (t *GetLicenseResponse_SubsonicResponse) MergeGetLicenseSuccessResponse(v GetLicenseSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetLicenseResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetLicenseResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetLicenseResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetLicenseResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetLicenseResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetLicenseResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetLicenseResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetLicenseResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetLyricsBySongIdSuccessResponse returns the union data inside the GetLyricsBySongIdResponse_SubsonicResponse as a GetLyricsBySongIdSuccessResponse
func (t GetLyricsBySongIdResponse_SubsonicResponse) AsGetLyricsBySongIdSuccessResponse() (GetLyricsBySongIdSuccessResponse, error) {
	var body GetLyricsBySongIdSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetLyricsBySongIdSuccessResponse overwrites any union data inside the GetLyricsBySongIdResponse_SubsonicResponse as the provided GetLyricsBySongIdSuccessResponse
func (t *GetLyricsBySongIdResponse_SubsonicResponse) FromGetLyricsBySongIdSuccessResponse(v GetLyricsBySongIdSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetLyricsBySongIdSuccessResponse performs a merge with any union data inside the GetLyricsBySongIdResponse_SubsonicResponse, using the provided GetLyricsBySongIdSuccessResponse
func (t *GetLyricsBySongIdResponse_SubsonicResponse) MergeGetLyricsBySongIdSuccessResponse(v GetLyricsBySongIdSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetLyricsBySongIdResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetLyricsBySongIdResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetLyricsBySongIdResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetLyricsBySongIdResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetLyricsBySongIdResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetLyricsBySongIdResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetLyricsBySongIdResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetLyricsBySongIdResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetLyricsSuccessResponse returns the union data inside the GetLyricsResponse_SubsonicResponse as a GetLyricsSuccessResponse
func (t GetLyricsResponse_SubsonicResponse) AsGetLyricsSuccessResponse() (GetLyricsSuccessResponse, error) {
	var body GetLyricsSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetLyricsSuccessResponse overwrites any union data inside the GetLyricsResponse_SubsonicResponse as the provided GetLyricsSuccessResponse
func (t *GetLyricsResponse_SubsonicResponse) FromGetLyricsSuccessResponse(v GetLyricsSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetLyricsSuccessResponse performs a merge with any union data inside the GetLyricsResponse_SubsonicResponse, using the provided GetLyricsSuccessResponse
func (t *GetLyricsResponse_SubsonicResponse) MergeGetLyricsSuccessResponse(v GetLyricsSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetLyricsResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetLyricsResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetLyricsResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetLyricsResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetLyricsResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetLyricsResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetLyricsResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetLyricsResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetMusicDirectorySuccessResponse returns the union data inside the GetMusicDirectoryResponse_SubsonicResponse as a GetMusicDirectorySuccessResponse
func (t GetMusicDirectoryResponse_SubsonicResponse) AsGetMusicDirectorySuccessResponse() (GetMusicDirectorySuccessResponse, error) {
	var body GetMusicDirectorySuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetMusicDirectorySuccessResponse overwrites any union data inside the GetMusicDirectoryResponse_SubsonicResponse as the provided GetMusicDirectorySuccessResponse
func (t *GetMusicDirectoryResponse_SubsonicResponse) FromGetMusicDirectorySuccessResponse(v GetMusicDirectorySuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetMusicDirectorySuccessResponse performs a merge with any union data inside the GetMusicDirectoryResponse_SubsonicResponse, using the provided GetMusicDirectorySuccessResponse
func (t *GetMusicDirectoryResponse_SubsonicResponse) MergeGetMusicDirectorySuccessResponse(v GetMusicDirectorySuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetMusicDirectoryResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetMusicDirectoryResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetMusicDirectoryResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetMusicDirectoryResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetMusicDirectoryResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetMusicDirectoryResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetMusicDirectoryResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetMusicDirectoryResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetMusicFoldersSuccessResponse returns the union data inside the GetMusicFoldersResponse_SubsonicResponse as a GetMusicFoldersSuccessResponse
func (t GetMusicFoldersResponse_SubsonicResponse) AsGetMusicFoldersSuccessResponse() (GetMusicFoldersSuccessResponse, error) {
	var body GetMusicFoldersSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetMusicFoldersSuccessResponse overwrites any union data inside the GetMusicFoldersResponse_SubsonicResponse as the provided GetMusicFoldersSuccessResponse
func (t *GetMusicFoldersResponse_SubsonicResponse) FromGetMusicFoldersSuccessResponse(v GetMusicFoldersSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetMusicFoldersSuccessResponse performs a merge with any union data inside the GetMusicFoldersResponse_SubsonicResponse, using the provided GetMusicFoldersSuccessResponse
func (t *GetMusicFoldersResponse_SubsonicResponse) MergeGetMusicFoldersSuccessResponse(v GetMusicFoldersSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetMusicFoldersResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetMusicFoldersResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetMusicFoldersResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetMusicFoldersResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetMusicFoldersResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetMusicFoldersResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetMusicFoldersResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetMusicFoldersResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetNewestPodcastsSuccessResponse returns the union data inside the GetNewestPodcastsResponse_SubsonicResponse as a GetNewestPodcastsSuccessResponse
func (t GetNewestPodcastsResponse_SubsonicResponse) AsGetNewestPodcastsSuccessResponse() (GetNewestPodcastsSuccessResponse, error) {
	var body GetNewestPodcastsSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetNewestPodcastsSuccessResponse overwrites any union data inside the GetNewestPodcastsResponse_SubsonicResponse as the provided GetNewestPodcastsSuccessResponse
func (t *GetNewestPodcastsResponse_SubsonicResponse) FromGetNewestPodcastsSuccessResponse(v GetNewestPodcastsSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetNewestPodcastsSuccessResponse performs a merge with any union data inside the GetNewestPodcastsResponse_SubsonicResponse, using the provided GetNewestPodcastsSuccessResponse
func (t *GetNewestPodcastsResponse_SubsonicResponse) MergeGetNewestPodcastsSuccessResponse(v GetNewestPodcastsSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetNewestPodcastsResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetNewestPodcastsResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetNewestPodcastsResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetNewestPodcastsResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetNewestPodcastsResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetNewestPodcastsResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetNewestPodcastsResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetNewestPodcastsResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetNowPlayingSuccessResponse returns the union data inside the GetNowPlayingResponse_SubsonicResponse as a GetNowPlayingSuccessResponse
func (t GetNowPlayingResponse_SubsonicResponse) AsGetNowPlayingSuccessResponse() (GetNowPlayingSuccessResponse, error) {
	var body GetNowPlayingSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetNowPlayingSuccessResponse overwrites any union data inside the GetNowPlayingResponse_SubsonicResponse as the provided GetNowPlayingSuccessResponse
func (t *GetNowPlayingResponse_SubsonicResponse) FromGetNowPlayingSuccessResponse(v GetNowPlayingSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetNowPlayingSuccessResponse performs a merge with any union data inside the GetNowPlayingResponse_SubsonicResponse, using the provided GetNowPlayingSuccessResponse
func (t *GetNowPlayingResponse_SubsonicResponse) MergeGetNowPlayingSuccessResponse(v GetNowPlayingSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetNowPlayingResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetNowPlayingResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetNowPlayingResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetNowPlayingResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetNowPlayingResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetNowPlayingResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetNowPlayingResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetNowPlayingResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetOpenSubsonicExtensionsSuccessResponse returns the union data inside the GetOpenSubsonicExtensionsResponse_SubsonicResponse as a GetOpenSubsonicExtensionsSuccessResponse
func (t GetOpenSubsonicExtensionsResponse_SubsonicResponse) AsGetOpenSubsonicExtensionsSuccessResponse() (GetOpenSubsonicExtensionsSuccessResponse, error) {
	var body GetOpenSubsonicExtensionsSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetOpenSubsonicExtensionsSuccessResponse overwrites any union data inside the GetOpenSubsonicExtensionsResponse_SubsonicResponse as the provided GetOpenSubsonicExtensionsSuccessResponse
func (t *GetOpenSubsonicExtensionsResponse_SubsonicResponse) FromGetOpenSubsonicExtensionsSuccessResponse(v GetOpenSubsonicExtensionsSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetOpenSubsonicExtensionsSuccessResponse performs a merge with any union data inside the GetOpenSubsonicExtensionsResponse_SubsonicResponse, using the provided GetOpenSubsonicExtensionsSuccessResponse
func (t *GetOpenSubsonicExtensionsResponse_SubsonicResponse) MergeGetOpenSubsonicExtensionsSuccessResponse(v GetOpenSubsonicExtensionsSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetOpenSubsonicExtensionsResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetOpenSubsonicExtensionsResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetOpenSubsonicExtensionsResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetOpenSubsonicExtensionsResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetOpenSubsonicExtensionsResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetOpenSubsonicExtensionsResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetOpenSubsonicExtensionsResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetOpenSubsonicExtensionsResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetPlayQueueByIndexSuccessResponse returns the union data inside the GetPlayQueueByIndexResponse_SubsonicResponse as a GetPlayQueueByIndexSuccessResponse
func (t GetPlayQueueByIndexResponse_SubsonicResponse) AsGetPlayQueueByIndexSuccessResponse() (GetPlayQueueByIndexSuccessResponse, error) {
	var body GetPlayQueueByIndexSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetPlayQueueByIndexSuccessResponse overwrites any union data inside the GetPlayQueueByIndexResponse_SubsonicResponse as the provided GetPlayQueueByIndexSuccessResponse
func (t *GetPlayQueueByIndexResponse_SubsonicResponse) FromGetPlayQueueByIndexSuccessResponse(v GetPlayQueueByIndexSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetPlayQueueByIndexSuccessResponse performs a merge with any union data inside the GetPlayQueueByIndexResponse_SubsonicResponse, using the provided GetPlayQueueByIndexSuccessResponse
func (t *GetPlayQueueByIndexResponse_SubsonicResponse) MergeGetPlayQueueByIndexSuccessResponse(v GetPlayQueueByIndexSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetPlayQueueByIndexResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetPlayQueueByIndexResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetPlayQueueByIndexResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetPlayQueueByIndexResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetPlayQueueByIndexResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetPlayQueueByIndexResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlayQueueByIndexResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlayQueueByIndexResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetPlayQueueSuccessResponse returns the union data inside the GetPlayQueueResponse_SubsonicResponse as a GetPlayQueueSuccessResponse
func (t GetPlayQueueResponse_SubsonicResponse) AsGetPlayQueueSuccessResponse() (GetPlayQueueSuccessResponse, error) {
	var body GetPlayQueueSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetPlayQueueSuccessResponse overwrites any union data inside the GetPlayQueueResponse_SubsonicResponse as the provided GetPlayQueueSuccessResponse
func (t *GetPlayQueueResponse_SubsonicResponse) FromGetPlayQueueSuccessResponse(v GetPlayQueueSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetPlayQueueSuccessResponse performs a merge with any union data inside the GetPlayQueueResponse_SubsonicResponse, using the provided GetPlayQueueSuccessResponse
func (t *GetPlayQueueResponse_SubsonicResponse) MergeGetPlayQueueSuccessResponse(v GetPlayQueueSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetPlayQueueResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetPlayQueueResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetPlayQueueResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetPlayQueueResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetPlayQueueResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetPlayQueueResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlayQueueResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlayQueueResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetPlaylistSuccessResponse returns the union data inside the GetPlaylistResponse_SubsonicResponse as a GetPlaylistSuccessResponse
func (t GetPlaylistResponse_SubsonicResponse) AsGetPlaylistSuccessResponse() (GetPlaylistSuccessResponse, error) {
	var body GetPlaylistSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetPlaylistSuccessResponse overwrites any union data inside the GetPlaylistResponse_SubsonicResponse as the provided GetPlaylistSuccessResponse
func (t *GetPlaylistResponse_SubsonicResponse) FromGetPlaylistSuccessResponse(v GetPlaylistSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetPlaylistSuccessResponse performs a merge with any union data inside the GetPlaylistResponse_SubsonicResponse, using the provided GetPlaylistSuccessResponse
func (t *GetPlaylistResponse_SubsonicResponse) MergeGetPlaylistSuccessResponse(v GetPlaylistSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetPlaylistResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetPlaylistResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetPlaylistResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetPlaylistResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetPlaylistResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetPlaylistResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlaylistResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlaylistResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetPlaylistsSuccessResponse returns the union data inside the GetPlaylistsResponse_SubsonicResponse as a GetPlaylistsSuccessResponse
func (t GetPlaylistsResponse_SubsonicResponse) AsGetPlaylistsSuccessResponse() (GetPlaylistsSuccessResponse, error) {
	var body GetPlaylistsSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetPlaylistsSuccessResponse overwrites any union data inside the GetPlaylistsResponse_SubsonicResponse as the provided GetPlaylistsSuccessResponse
func (t *GetPlaylistsResponse_SubsonicResponse) FromGetPlaylistsSuccessResponse(v GetPlaylistsSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetPlaylistsSuccessResponse performs a merge with any union data inside the GetPlaylistsResponse_SubsonicResponse, using the provided GetPlaylistsSuccessResponse
func (t *GetPlaylistsResponse_SubsonicResponse) MergeGetPlaylistsSuccessResponse(v GetPlaylistsSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetPlaylistsResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetPlaylistsResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetPlaylistsResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetPlaylistsResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetPlaylistsResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetPlaylistsResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlaylistsResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlaylistsResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetPodcastEpisodeSuccessResponse returns the union data inside the GetPodcastEpisodeResponse_SubsonicResponse as a GetPodcastEpisodeSuccessResponse
func (t GetPodcastEpisodeResponse_SubsonicResponse) AsGetPodcastEpisodeSuccessResponse() (GetPodcastEpisodeSuccessResponse, error) {
	var body GetPodcastEpisodeSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetPodcastEpisodeSuccessResponse overwrites any union data inside the GetPodcastEpisodeResponse_SubsonicResponse as the provided GetPodcastEpisodeSuccessResponse
func (t *GetPodcastEpisodeResponse_SubsonicResponse) FromGetPodcastEpisodeSuccessResponse(v GetPodcastEpisodeSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetPodcastEpisodeSuccessResponse performs a merge with any union data inside the GetPodcastEpisodeResponse_SubsonicResponse, using the provided GetPodcastEpisodeSuccessResponse
func (t *GetPodcastEpisodeResponse_SubsonicResponse) MergeGetPodcastEpisodeSuccessResponse(v GetPodcastEpisodeSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetPodcastEpisodeResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetPodcastEpisodeResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetPodcastEpisodeResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetPodcastEpisodeResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetPodcastEpisodeResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetPodcastEpisodeResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPodcastEpisodeResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPodcastEpisodeResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetPodcastsSuccessResponse returns the union data inside the GetPodcastsResponse_SubsonicResponse as a GetPodcastsSuccessResponse
func (t GetPodcastsResponse_SubsonicResponse) AsGetPodcastsSuccessResponse() (GetPodcastsSuccessResponse, error) {
	var body GetPodcastsSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetPodcastsSuccessResponse overwrites any union data inside the GetPodcastsResponse_SubsonicResponse as the provided GetPodcastsSuccessResponse
func (t *GetPodcastsResponse_SubsonicResponse) FromGetPodcastsSuccessResponse(v GetPodcastsSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetPodcastsSuccessResponse performs a merge with any union data inside the GetPodcastsResponse_SubsonicResponse, using the provided GetPodcastsSuccessResponse
func (t *GetPodcastsResponse_SubsonicResponse) MergeGetPodcastsSuccessResponse(v GetPodcastsSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetPodcastsResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetPodcastsResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetPodcastsResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetPodcastsResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetPodcastsResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetPodcastsResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPodcastsResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPodcastsResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetRandomSongsSuccessResponse returns the union data inside the GetRandomSongsResponse_SubsonicResponse as a GetRandomSongsSuccessResponse
func (t GetRandomSongsResponse_SubsonicResponse) AsGetRandomSongsSuccessResponse() (GetRandomSongsSuccessResponse, error) {
	var body GetRandomSongsSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetRandomSongsSuccessResponse overwrites any union data inside the GetRandomSongsResponse_SubsonicResponse as the provided GetRandomSongsSuccessResponse
func (t *GetRandomSongsResponse_SubsonicResponse) FromGetRandomSongsSuccessResponse(v GetRandomSongsSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetRandomSongsSuccessResponse performs a merge with any union data inside the GetRandomSongsResponse_SubsonicResponse, using the provided GetRandomSongsSuccessResponse
func (t *GetRandomSongsResponse_SubsonicResponse) MergeGetRandomSongsSuccessResponse(v GetRandomSongsSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetRandomSongsResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetRandomSongsResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetRandomSongsResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetRandomSongsResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetRandomSongsResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetRandomSongsResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetRandomSongsResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetRandomSongsResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetScanStatusSuccessResponse returns the union data inside the GetScanStatusResponse_SubsonicResponse as a GetScanStatusSuccessResponse
func (t GetScanStatusResponse_SubsonicResponse) AsGetScanStatusSuccessResponse() (GetScanStatusSuccessResponse, error) {
	var body GetScanStatusSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetScanStatusSuccessResponse overwrites any union data inside the GetScanStatusResponse_SubsonicResponse as the provided GetScanStatusSuccessResponse
func (t *GetScanStatusResponse_SubsonicResponse) FromGetScanStatusSuccessResponse(v GetScanStatusSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetScanStatusSuccessResponse performs a merge with any union data inside the GetScanStatusResponse_SubsonicResponse, using the provided GetScanStatusSuccessResponse
func (t *GetScanStatusResponse_SubsonicResponse) MergeGetScanStatusSuccessResponse(v GetScanStatusSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetScanStatusResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetScanStatusResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetScanStatusResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetScanStatusResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetScanStatusResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetScanStatusResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetScanStatusResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetScanStatusResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetSharesSuccessResponse returns the union data inside the GetSharesResponse_SubsonicResponse as a GetSharesSuccessResponse
func (t GetSharesResponse_SubsonicResponse) AsGetSharesSuccessResponse() (GetSharesSuccessResponse, error) {
	var body GetSharesSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSharesSuccessResponse overwrites any union data inside the GetSharesResponse_SubsonicResponse as the provided GetSharesSuccessResponse
func (t *GetSharesResponse_SubsonicResponse) FromGetSharesSuccessResponse(v GetSharesSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSharesSuccessResponse performs a merge with any union data inside the GetSharesResponse_SubsonicResponse, using the provided GetSharesSuccessResponse
func (t *GetSharesResponse_SubsonicResponse) MergeGetSharesSuccessResponse(v GetSharesSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetSharesResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetSharesResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetSharesResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetSharesResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetSharesResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetSharesResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetSharesResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetSharesResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetSimilarSongs2SuccessResponse returns the union data inside the GetSimilarSongs2Response_SubsonicResponse as a GetSimilarSongs2SuccessResponse
func (t GetSimilarSongs2Response_SubsonicResponse) AsGetSimilarSongs2SuccessResponse() (GetSimilarSongs2SuccessResponse, error) {
	var body GetSimilarSongs2SuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSimilarSongs2SuccessResponse overwrites any union data inside the GetSimilarSongs2Response_SubsonicResponse as the provided GetSimilarSongs2SuccessResponse
func (t *GetSimilarSongs2Response_SubsonicResponse) FromGetSimilarSongs2SuccessResponse(v GetSimilarSongs2SuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSimilarSongs2SuccessResponse performs a merge with any union data inside the GetSimilarSongs2Response_SubsonicResponse, using the provided GetSimilarSongs2SuccessResponse
func (t *GetSimilarSongs2Response_SubsonicResponse) MergeGetSimilarSongs2SuccessResponse(v GetSimilarSongs2SuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetSimilarSongs2Response_SubsonicResponse as a SubsonicFailureResponse
func (t GetSimilarSongs2Response_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetSimilarSongs2Response_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetSimilarSongs2Response_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetSimilarSongs2Response_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetSimilarSongs2Response_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetSimilarSongs2Response_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetSimilarSongs2Response_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetSimilarSongsSuccessResponse returns the union data inside the GetSimilarSongsResponse_SubsonicResponse as a GetSimilarSongsSuccessResponse
func (t GetSimilarSongsResponse_SubsonicResponse) AsGetSimilarSongsSuccessResponse() (GetSimilarSongsSuccessResponse, error) {
	var body GetSimilarSongsSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSimilarSongsSuccessResponse overwrites any union data inside the GetSimilarSongsResponse_SubsonicResponse as the provided GetSimilarSongsSuccessResponse
func (t *GetSimilarSongsResponse_SubsonicResponse) FromGetSimilarSongsSuccessResponse(v GetSimilarSongsSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSimilarSongsSuccessResponse performs a merge with any union data inside the GetSimilarSongsResponse_SubsonicResponse, using the provided GetSimilarSongsSuccessResponse
func (t *GetSimilarSongsResponse_SubsonicResponse) MergeGetSimilarSongsSuccessResponse(v GetSimilarSongsSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetSimilarSongsResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetSimilarSongsResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetSimilarSongsResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetSimilarSongsResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetSimilarSongsResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetSimilarSongsResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetSimilarSongsResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetSimilarSongsResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetSongSuccessResponse returns the union data inside the GetSongResponse_SubsonicResponse as a GetSongSuccessResponse
func (t GetSongResponse_SubsonicResponse) AsGetSongSuccessResponse() (GetSongSuccessResponse, error) {
	var body GetSongSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSongSuccessResponse overwrites any union data inside the GetSongResponse_SubsonicResponse as the provided GetSongSuccessResponse
func (t *GetSongResponse_SubsonicResponse) FromGetSongSuccessResponse(v GetSongSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSongSuccessResponse performs a merge with any union data inside the GetSongResponse_SubsonicResponse, using the provided GetSongSuccessResponse
func (t *GetSongResponse_SubsonicResponse) MergeGetSongSuccessResponse(v GetSongSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetSongResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetSongResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetSongResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetSongResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetSongResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetSongResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetSongResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetSongResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetSongsByGenreSuccessResponse returns the union data inside the GetSongsByGenreResponse_SubsonicResponse as a GetSongsByGenreSuccessResponse
func (t GetSongsByGenreResponse_SubsonicResponse) AsGetSongsByGenreSuccessResponse() (GetSongsByGenreSuccessResponse, error) {
	var body GetSongsByGenreSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSongsByGenreSuccessResponse overwrites any union data inside the GetSongsByGenreResponse_SubsonicResponse as the provided GetSongsByGenreSuccessResponse
func (t *GetSongsByGenreResponse_SubsonicResponse) FromGetSongsByGenreSuccessResponse(v GetSongsByGenreSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSongsByGenreSuccessResponse performs a merge with any union data inside the GetSongsByGenreResponse_SubsonicResponse, using the provided GetSongsByGenreSuccessResponse
func (t *GetSongsByGenreResponse_SubsonicResponse) MergeGetSongsByGenreSuccessResponse(v GetSongsByGenreSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetSongsByGenreResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetSongsByGenreResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetSongsByGenreResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetSongsByGenreResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetSongsByGenreResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetSongsByGenreResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetSongsByGenreResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetSongsByGenreResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetStarred2SuccessResponse returns the union data inside the GetStarred2Response_SubsonicResponse as a GetStarred2SuccessResponse
func (t GetStarred2Response_SubsonicResponse) AsGetStarred2SuccessResponse() (GetStarred2SuccessResponse, error) {
	var body GetStarred2SuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetStarred2SuccessResponse overwrites any union data inside the GetStarred2Response_SubsonicResponse as the provided GetStarred2SuccessResponse
func (t *GetStarred2Response_SubsonicResponse) FromGetStarred2SuccessResponse(v GetStarred2SuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetStarred2SuccessResponse performs a merge with any union data inside the GetStarred2Response_SubsonicResponse, using the provided GetStarred2SuccessResponse
func (t *GetStarred2Response_SubsonicResponse) MergeGetStarred2SuccessResponse(v GetStarred2SuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetStarred2Response_SubsonicResponse as a SubsonicFailureResponse
func (t GetStarred2Response_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetStarred2Response_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetStarred2Response_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetStarred2Response_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetStarred2Response_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetStarred2Response_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetStarred2Response_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetStarredSuccessResponse returns the union data inside the GetStarredResponse_SubsonicResponse as a GetStarredSuccessResponse
func (t GetStarredResponse_SubsonicResponse) AsGetStarredSuccessResponse() (GetStarredSuccessResponse, error) {
	var body GetStarredSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetStarredSuccessResponse overwrites any union data inside the GetStarredResponse_SubsonicResponse as the provided GetStarredSuccessResponse
func (t *GetStarredResponse_SubsonicResponse) FromGetStarredSuccessResponse(v GetStarredSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetStarredSuccessResponse performs a merge with any union data inside the GetStarredResponse_SubsonicResponse, using the provided GetStarredSuccessResponse
func (t *GetStarredResponse_SubsonicResponse) MergeGetStarredSuccessResponse(v GetStarredSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetStarredResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetStarredResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetStarredResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetStarredResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetStarredResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetStarredResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetStarredResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetStarredResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetTokenInfoSuccessResponse returns the union data inside the GetTokenInfoResponse_SubsonicResponse as a GetTokenInfoSuccessResponse
func (t GetTokenInfoResponse_SubsonicResponse) AsGetTokenInfoSuccessResponse() (GetTokenInfoSuccessResponse, error) {
	var body GetTokenInfoSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetTokenInfoSuccessResponse overwrites any union data inside the GetTokenInfoResponse_SubsonicResponse as the provided GetTokenInfoSuccessResponse
func (t *GetTokenInfoResponse_SubsonicResponse) FromGetTokenInfoSuccessResponse(v GetTokenInfoSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetTokenInfoSuccessResponse performs a merge with any union data inside the GetTokenInfoResponse_SubsonicResponse, using the provided GetTokenInfoSuccessResponse
func (t *GetTokenInfoResponse_SubsonicResponse) MergeGetTokenInfoSuccessResponse(v GetTokenInfoSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetTokenInfoResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetTokenInfoResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetTokenInfoResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetTokenInfoResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetTokenInfoResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetTokenInfoResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetTokenInfoResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetTokenInfoResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetTopSongsSuccessResponse returns the union data inside the GetTopSongsResponse_SubsonicResponse as a GetTopSongsSuccessResponse
func (t GetTopSongsResponse_SubsonicResponse) AsGetTopSongsSuccessResponse() (GetTopSongsSuccessResponse, error) {
	var body GetTopSongsSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetTopSongsSuccessResponse overwrites any union data inside the GetTopSongsResponse_SubsonicResponse as the provided GetTopSongsSuccessResponse
func (t *GetTopSongsResponse_SubsonicResponse) FromGetTopSongsSuccessResponse(v GetTopSongsSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetTopSongsSuccessResponse performs a merge with any union data inside the GetTopSongsResponse_SubsonicResponse, using the provided GetTopSongsSuccessResponse
func (t *GetTopSongsResponse_SubsonicResponse) MergeGetTopSongsSuccessResponse(v GetTopSongsSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetTopSongsResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetTopSongsResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetTopSongsResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetTopSongsResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetTopSongsResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetTopSongsResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetTopSongsResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetTopSongsResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetUserSuccessResponse returns the union data inside the GetUserResponse_SubsonicResponse as a GetUserSuccessResponse
func (t GetUserResponse_SubsonicResponse) AsGetUserSuccessResponse() (GetUserSuccessResponse, error) {
	var body GetUserSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetUserSuccessResponse overwrites any union data inside the GetUserResponse_SubsonicResponse as the provided GetUserSuccessResponse
func (t *GetUserResponse_SubsonicResponse) FromGetUserSuccessResponse(v GetUserSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetUserSuccessResponse performs a merge with any union data inside the GetUserResponse_SubsonicResponse, using the provided GetUserSuccessResponse
func (t *GetUserResponse_SubsonicResponse) MergeGetUserSuccessResponse(v GetUserSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetUserResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetUserResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetUserResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetUserResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetUserResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetUserResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetUserResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetUserResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetUsersSuccessResponse returns the union data inside the GetUsersResponse_SubsonicResponse as a GetUsersSuccessResponse
func (t GetUsersResponse_SubsonicResponse) AsGetUsersSuccessResponse() (GetUsersSuccessResponse, error) {
	var body GetUsersSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetUsersSuccessResponse overwrites any union data inside the GetUsersResponse_SubsonicResponse as the provided GetUsersSuccessResponse
func (t *GetUsersResponse_SubsonicResponse) FromGetUsersSuccessResponse(v GetUsersSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetUsersSuccessResponse performs a merge with any union data inside the GetUsersResponse_SubsonicResponse, using the provided GetUsersSuccessResponse
func (t *GetUsersResponse_SubsonicResponse) MergeGetUsersSuccessResponse(v GetUsersSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetUsersResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetUsersResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetUsersResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetUsersResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetUsersResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetUsersResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetUsersResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetUsersResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetVideoInfoSuccessResponse returns the union data inside the GetVideoInfoResponse_SubsonicResponse as a GetVideoInfoSuccessResponse
func (t GetVideoInfoResponse_SubsonicResponse) AsGetVideoInfoSuccessResponse() (GetVideoInfoSuccessResponse, error) {
	var body GetVideoInfoSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetVideoInfoSuccessResponse overwrites any union data inside the GetVideoInfoResponse_SubsonicResponse as the provided GetVideoInfoSuccessResponse
func (t *GetVideoInfoResponse_SubsonicResponse) FromGetVideoInfoSuccessResponse(v GetVideoInfoSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetVideoInfoSuccessResponse performs a merge with any union data inside the GetVideoInfoResponse_SubsonicResponse, using the provided GetVideoInfoSuccessResponse
func (t *GetVideoInfoResponse_SubsonicResponse) MergeGetVideoInfoSuccessResponse(v GetVideoInfoSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetVideoInfoResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetVideoInfoResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetVideoInfoResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetVideoInfoResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetVideoInfoResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetVideoInfoResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetVideoInfoResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetVideoInfoResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetVideosSuccessResponse returns the union data inside the GetVideosResponse_SubsonicResponse as a GetVideosSuccessResponse
func (t GetVideosResponse_SubsonicResponse) AsGetVideosSuccessResponse() (GetVideosSuccessResponse, error) {
	var body GetVideosSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetVideosSuccessResponse overwrites any union data inside the GetVideosResponse_SubsonicResponse as the provided GetVideosSuccessResponse
func (t *GetVideosResponse_SubsonicResponse) FromGetVideosSuccessResponse(v GetVideosSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetVideosSuccessResponse performs a merge with any union data inside the GetVideosResponse_SubsonicResponse, using the provided GetVideosSuccessResponse
func (t *GetVideosResponse_SubsonicResponse) MergeGetVideosSuccessResponse(v GetVideosSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the GetVideosResponse_SubsonicResponse as a SubsonicFailureResponse
func (t GetVideosResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the GetVideosResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *GetVideosResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the GetVideosResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *GetVideosResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetVideosResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetVideosResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJukeboxControlSuccessResponse returns the union data inside the JukeboxControlResponse_SubsonicResponse as a JukeboxControlSuccessResponse
func (t JukeboxControlResponse_SubsonicResponse) AsJukeboxControlSuccessResponse() (JukeboxControlSuccessResponse, error) {
	var body JukeboxControlSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJukeboxControlSuccessResponse overwrites any union data inside the JukeboxControlResponse_SubsonicResponse as the provided JukeboxControlSuccessResponse
func (t *JukeboxControlResponse_SubsonicResponse) FromJukeboxControlSuccessResponse(v JukeboxControlSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJukeboxControlSuccessResponse performs a merge with any union data inside the JukeboxControlResponse_SubsonicResponse, using the provided JukeboxControlSuccessResponse
func (t *JukeboxControlResponse_SubsonicResponse) MergeJukeboxControlSuccessResponse(v JukeboxControlSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the JukeboxControlResponse_SubsonicResponse as a SubsonicFailureResponse
func (t JukeboxControlResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the JukeboxControlResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *JukeboxControlResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the JukeboxControlResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *JukeboxControlResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JukeboxControlResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JukeboxControlResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSearch2SuccessResponse returns the union data inside the Search2Response_SubsonicResponse as a Search2SuccessResponse
func (t Search2Response_SubsonicResponse) AsSearch2SuccessResponse() (Search2SuccessResponse, error) {
	var body Search2SuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearch2SuccessResponse overwrites any union data inside the Search2Response_SubsonicResponse as the provided Search2SuccessResponse
func (t *Search2Response_SubsonicResponse) FromSearch2SuccessResponse(v Search2SuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearch2SuccessResponse performs a merge with any union data inside the Search2Response_SubsonicResponse, using the provided Search2SuccessResponse
func (t *Search2Response_SubsonicResponse) MergeSearch2SuccessResponse(v Search2SuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the Search2Response_SubsonicResponse as a SubsonicFailureResponse
func (t Search2Response_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the Search2Response_SubsonicResponse as the provided SubsonicFailureResponse
func (t *Search2Response_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the Search2Response_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *Search2Response_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Search2Response_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Search2Response_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSearch3SuccessResponse returns the union data inside the Search3Response_SubsonicResponse as a Search3SuccessResponse
func (t Search3Response_SubsonicResponse) AsSearch3SuccessResponse() (Search3SuccessResponse, error) {
	var body Search3SuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearch3SuccessResponse overwrites any union data inside the Search3Response_SubsonicResponse as the provided Search3SuccessResponse
func (t *Search3Response_SubsonicResponse) FromSearch3SuccessResponse(v Search3SuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearch3SuccessResponse performs a merge with any union data inside the Search3Response_SubsonicResponse, using the provided Search3SuccessResponse
func (t *Search3Response_SubsonicResponse) MergeSearch3SuccessResponse(v Search3SuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the Search3Response_SubsonicResponse as a SubsonicFailureResponse
func (t Search3Response_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the Search3Response_SubsonicResponse as the provided SubsonicFailureResponse
func (t *Search3Response_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the Search3Response_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *Search3Response_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Search3Response_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Search3Response_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSearchSuccessResponse returns the union data inside the SearchResponse_SubsonicResponse as a SearchSuccessResponse
func (t SearchResponse_SubsonicResponse) AsSearchSuccessResponse() (SearchSuccessResponse, error) {
	var body SearchSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchSuccessResponse overwrites any union data inside the SearchResponse_SubsonicResponse as the provided SearchSuccessResponse
func (t *SearchResponse_SubsonicResponse) FromSearchSuccessResponse(v SearchSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchSuccessResponse performs a merge with any union data inside the SearchResponse_SubsonicResponse, using the provided SearchSuccessResponse
func (t *SearchResponse_SubsonicResponse) MergeSearchSuccessResponse(v SearchSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the SearchResponse_SubsonicResponse as a SubsonicFailureResponse
func (t SearchResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the SearchResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *SearchResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the SearchResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *SearchResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SearchResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStartScanSuccessResponse returns the union data inside the StartScanResponse_SubsonicResponse as a StartScanSuccessResponse
func (t StartScanResponse_SubsonicResponse) AsStartScanSuccessResponse() (StartScanSuccessResponse, error) {
	var body StartScanSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStartScanSuccessResponse overwrites any union data inside the StartScanResponse_SubsonicResponse as the provided StartScanSuccessResponse
func (t *StartScanResponse_SubsonicResponse) FromStartScanSuccessResponse(v StartScanSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStartScanSuccessResponse performs a merge with any union data inside the StartScanResponse_SubsonicResponse, using the provided StartScanSuccessResponse
func (t *StartScanResponse_SubsonicResponse) MergeStartScanSuccessResponse(v StartScanSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the StartScanResponse_SubsonicResponse as a SubsonicFailureResponse
func (t StartScanResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the StartScanResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *StartScanResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the StartScanResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *StartScanResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StartScanResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StartScanResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSubsonicSuccessResponse returns the union data inside the SubsonicResponse_SubsonicResponse as a SubsonicSuccessResponse
func (t SubsonicResponse_SubsonicResponse) AsSubsonicSuccessResponse() (SubsonicSuccessResponse, error) {
	var body SubsonicSuccessResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicSuccessResponse overwrites any union data inside the SubsonicResponse_SubsonicResponse as the provided SubsonicSuccessResponse
func (t *SubsonicResponse_SubsonicResponse) FromSubsonicSuccessResponse(v SubsonicSuccessResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicSuccessResponse performs a merge with any union data inside the SubsonicResponse_SubsonicResponse, using the provided SubsonicSuccessResponse
func (t *SubsonicResponse_SubsonicResponse) MergeSubsonicSuccessResponse(v SubsonicSuccessResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSubsonicFailureResponse returns the union data inside the SubsonicResponse_SubsonicResponse as a SubsonicFailureResponse
func (t SubsonicResponse_SubsonicResponse) AsSubsonicFailureResponse() (SubsonicFailureResponse, error) {
	var body SubsonicFailureResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSubsonicFailureResponse overwrites any union data inside the SubsonicResponse_SubsonicResponse as the provided SubsonicFailureResponse
func (t *SubsonicResponse_SubsonicResponse) FromSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSubsonicFailureResponse performs a merge with any union data inside the SubsonicResponse_SubsonicResponse, using the provided SubsonicFailureResponse
func (t *SubsonicResponse_SubsonicResponse) MergeSubsonicFailureResponse(v SubsonicFailureResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SubsonicResponse_SubsonicResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SubsonicResponse_SubsonicResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Adds a message to the chat log.
	// (GET /rest/addChatMessage)
	GetAddChatMessage(w http.ResponseWriter, r *http.Request, params GetAddChatMessageParams)
	// Adds a message to the chat log.
	// (POST /rest/addChatMessage)
	PostAddChatMessage(w http.ResponseWriter, r *http.Request)
	// Changes the password of an existing user on the server.
	// (GET /rest/changePassword)
	ChangePassword(w http.ResponseWriter, r *http.Request, params ChangePasswordParams)
	// Changes the password of an existing user on the server.
	// (POST /rest/changePassword)
	PostChangePassword(w http.ResponseWriter, r *http.Request)
	// Creates or updates a bookmark.
	// (GET /rest/createBookmark)
	CreateBookmark(w http.ResponseWriter, r *http.Request, params CreateBookmarkParams)
	// Creates or updates a bookmark.
	// (POST /rest/createBookmark)
	PostCreateBookmark(w http.ResponseWriter, r *http.Request)
	// Adds a new internet radio station.
	// (GET /rest/createInternetRadioStation)
	CreateInternetRadioStation(w http.ResponseWriter, r *http.Request, params CreateInternetRadioStationParams)
	// Adds a new internet radio station.
	// (POST /rest/createInternetRadioStation)
	PostCreateInternetRadioStation(w http.ResponseWriter, r *http.Request)
	// Creates (or updates) a playlist.
	// (GET /rest/createPlaylist)
	CreatePlaylist(w http.ResponseWriter, r *http.Request, params CreatePlaylistParams)
	// Creates (or updates) a playlist.
	// (POST /rest/createPlaylist)
	PostCreatePlaylist(w http.ResponseWriter, r *http.Request)
	// Adds a new Podcast channel.
	// (GET /rest/createPodcastChannel)
	CreatePodcastChannel(w http.ResponseWriter, r *http.Request, params CreatePodcastChannelParams)
	// Adds a new Podcast channel.
	// (POST /rest/createPodcastChannel)
	PostCreatePodcastChannel(w http.ResponseWriter, r *http.Request)
	// Creates a public URL that can be used by anyone to stream music or video from the server.
	// (GET /rest/createShare)
	CreateShare(w http.ResponseWriter, r *http.Request, params CreateShareParams)
	// Creates a public URL that can be used by anyone to stream music or video from the server.
	// (POST /rest/createShare)
	PostCreateShare(w http.ResponseWriter, r *http.Request)
	// Creates a new user on the server.
	// (GET /rest/createUser)
	CreateUser(w http.ResponseWriter, r *http.Request, params CreateUserParams)
	// Creates a new user on the server.
	// (POST /rest/createUser)
	PostCreateUser(w http.ResponseWriter, r *http.Request)
	// Deletes a bookmark.
	// (GET /rest/deleteBookmark)
	DeleteBookmark(w http.ResponseWriter, r *http.Request, params DeleteBookmarkParams)
	// Deletes a bookmark.
	// (POST /rest/deleteBookmark)
	PostDeleteBookmark(w http.ResponseWriter, r *http.Request)
	// Deletes an existing internet radio station.
	// (GET /rest/deleteInternetRadioStation)
	DeleteInternetRadioStation(w http.ResponseWriter, r *http.Request, params DeleteInternetRadioStationParams)
	// Deletes an existing internet radio station.
	// (POST /rest/deleteInternetRadioStation)
	PostDeleteInternetRadioStation(w http.ResponseWriter, r *http.Request)
	// Deletes a saved playlist.
	// (GET /rest/deletePlaylist)
	DeletePlaylist(w http.ResponseWriter, r *http.Request, params DeletePlaylistParams)
	// Deletes a saved playlist.
	// (POST /rest/deletePlaylist)
	PostDeletePlaylist(w http.ResponseWriter, r *http.Request)
	// Deletes a Podcast channel.
	// (GET /rest/deletePodcastChannel)
	DeletePodcastChannel(w http.ResponseWriter, r *http.Request, params DeletePodcastChannelParams)
	// Deletes a Podcast channel.
	// (POST /rest/deletePodcastChannel)
	PostDeletePodcastChannel(w http.ResponseWriter, r *http.Request)
	// Deletes a Podcast episode.
	// (GET /rest/deletePodcastEpisode)
	DeletePodcastEpisode(w http.ResponseWriter, r *http.Request, params DeletePodcastEpisodeParams)
	// Deletes a Podcast episode.
	// (POST /rest/deletePodcastEpisode)
	PostDeletePodcastEpisode(w http.ResponseWriter, r *http.Request)
	// Deletes an existing share.
	// (GET /rest/deleteShare)
	DeleteShare(w http.ResponseWriter, r *http.Request, params DeleteShareParams)
	// Deletes an existing share.
	// (POST /rest/deleteShare)
	PostDeleteShare(w http.ResponseWriter, r *http.Request)
	// Deletes an existing user on the server.
	// (GET /rest/deleteUser)
	DeleteUser(w http.ResponseWriter, r *http.Request, params DeleteUserParams)
	// Deletes an existing user on the server.
	// (POST /rest/deleteUser)
	PostDeleteUser(w http.ResponseWriter, r *http.Request)
	// Downloads a given media file.
	// (GET /rest/download)
	Download(w http.ResponseWriter, r *http.Request, params DownloadParams)
	// Downloads a given media file.
	// (POST /rest/download)
	PostDownload(w http.ResponseWriter, r *http.Request)
	// Request the server to start downloading a given Podcast episode.
	// (GET /rest/downloadPodcastEpisode)
	DownloadPodcastEpisode(w http.ResponseWriter, r *http.Request, params DownloadPodcastEpisodeParams)
	// Request the server to start downloading a given Podcast episode.
	// (POST /rest/downloadPodcastEpisode)
	PostDownloadPodcastEpisode(w http.ResponseWriter, r *http.Request)
	// Returns details for an album.
	// (GET /rest/getAlbum)
	GetAlbum(w http.ResponseWriter, r *http.Request, params GetAlbumParams)
	// Returns details for an album.
	// (POST /rest/getAlbum)
	PostGetAlbum(w http.ResponseWriter, r *http.Request)
	// Returns album info.
	// (GET /rest/getAlbumInfo)
	GetAlbumInfo(w http.ResponseWriter, r *http.Request, params GetAlbumInfoParams)
	// Returns album info.
	// (POST /rest/getAlbumInfo)
	PostGetAlbumInfo(w http.ResponseWriter, r *http.Request)
	// Returns album info (v2).
	// (GET /rest/getAlbumInfo2)
	GetAlbumInfo2(w http.ResponseWriter, r *http.Request, params GetAlbumInfo2Params)
	// Returns album info (v2).
	// (POST /rest/getAlbumInfo2)
	PostGetAlbumInfo2(w http.ResponseWriter, r *http.Request)
	// Returns a list of random, newest, highest rated etc. albums.
	// (GET /rest/getAlbumList)
	GetAlbumList(w http.ResponseWriter, r *http.Request, params GetAlbumListParams)
	// Returns a list of random, newest, highest rated etc. albums.
	// (POST /rest/getAlbumList)
	PostGetAlbumList(w http.ResponseWriter, r *http.Request)
	// Returns a list of random, newest, highest rated etc. albums (v2).
	// (GET /rest/getAlbumList2)
	GetAlbumList2(w http.ResponseWriter, r *http.Request, params GetAlbumList2Params)
	// Returns a list of random, newest, highest rated etc. albums (v2).
	// (POST /rest/getAlbumList2)
	PostGetAlbumList2(w http.ResponseWriter, r *http.Request)
	// Returns details for an artist.
	// (GET /rest/getArtist)
	GetArtist(w http.ResponseWriter, r *http.Request, params GetArtistParams)
	// Returns details for an artist.
	// (POST /rest/getArtist)
	PostGetArtist(w http.ResponseWriter, r *http.Request)
	// Returns artist info.
	// (GET /rest/getArtistInfo)
	GetArtistInfo(w http.ResponseWriter, r *http.Request, params GetArtistInfoParams)
	// Returns artist info.
	// (POST /rest/getArtistInfo)
	PostGetArtistInfo(w http.ResponseWriter, r *http.Request)
	// Returns artist info (v2).
	// (GET /rest/getArtistInfo2)
	GetArtistInfo2(w http.ResponseWriter, r *http.Request, params GetArtistInfo2Params)
	// Returns artist info (v2).
	// (POST /rest/getArtistInfo2)
	PostGetArtistInfo2(w http.ResponseWriter, r *http.Request)
	// Returns all artists.
	// (GET /rest/getArtists)
	GetArtists(w http.ResponseWriter, r *http.Request, params GetArtistsParams)
	// Returns all artists.
	// (POST /rest/getArtists)
	PostGetArtists(w http.ResponseWriter, r *http.Request)
	// Returns the avatar (personal image) for a user.
	// (GET /rest/getAvatar)
	GetAvatar(w http.ResponseWriter, r *http.Request, params GetAvatarParams)
	// Returns the avatar (personal image) for a user.
	// (POST /rest/getAvatar)
	PostGetAvatar(w http.ResponseWriter, r *http.Request)
	// Returns all bookmarks for this user.
	// (GET /rest/getBookmarks)
	GetBookmarks(w http.ResponseWriter, r *http.Request)
	// Returns all bookmarks for this user.
	// (POST /rest/getBookmarks)
	PostGetBookmarks(w http.ResponseWriter, r *http.Request)
	// Returns captions (subtitles) for a video.
	// (GET /rest/getCaptions)
	GetCaptions(w http.ResponseWriter, r *http.Request, params GetCaptionsParams)
	// Returns captions (subtitles) for a video.
	// (POST /rest/getCaptions)
	PostGetCaptions(w http.ResponseWriter, r *http.Request)
	// Returns the current visible (non-expired) chat messages.
	// (GET /rest/getChatMessages)
	GetChatMessages(w http.ResponseWriter, r *http.Request)
	// Returns the current visible (non-expired) chat messages.
	// (POST /rest/getChatMessages)
	PostGetChatMessages(w http.ResponseWriter, r *http.Request)
	// Returns a cover art image.
	// (GET /rest/getCoverArt)
	GetCoverArt(w http.ResponseWriter, r *http.Request, params GetCoverArtParams)
	// Returns a cover art image.
	// (POST /rest/getCoverArt)
	PostGetCoverArt(w http.ResponseWriter, r *http.Request)
	// Returns all genres.
	// (GET /rest/getGenres)
	GetGenres(w http.ResponseWriter, r *http.Request)
	// Returns all genres.
	// (POST /rest/getGenres)
	PostGetGenres(w http.ResponseWriter, r *http.Request)
	// Returns an indexed structure of all artists.
	// (GET /rest/getIndexes)
	GetIndexes(w http.ResponseWriter, r *http.Request, params GetIndexesParams)
	// Returns an indexed structure of all artists.
	// (POST /rest/getIndexes)
	PostGetIndexes(w http.ResponseWriter, r *http.Request)
	// Returns all internet radio stations.
	// (GET /rest/getInternetRadioStations)
	GetInternetRadioStations(w http.ResponseWriter, r *http.Request)
	// Returns all internet radio stations.
	// (POST /rest/getInternetRadioStations)
	PostGetInternetRadioStations(w http.ResponseWriter, r *http.Request)
	// Get details about the software license.
	// (GET /rest/getLicense)
	GetLicense(w http.ResponseWriter, r *http.Request)
	// Get details about the software license.
	// (POST /rest/getLicense)
	PostGetLicense(w http.ResponseWriter, r *http.Request)
	// Searches for and returns lyrics for a given song.
	// (GET /rest/getLyrics)
	GetLyrics(w http.ResponseWriter, r *http.Request, params GetLyricsParams)
	// Searches for and returns lyrics for a given song.
	// (POST /rest/getLyrics)
	PostGetLyrics(w http.ResponseWriter, r *http.Request)
	// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
	// (GET /rest/getLyricsBySongId)
	GetLyricsBySongId(w http.ResponseWriter, r *http.Request, params GetLyricsBySongIdParams)
	// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
	// (POST /rest/getLyricsBySongId)
	PostGetLyricsBySongId(w http.ResponseWriter, r *http.Request)
	// Returns a listing of all files in a music directory.
	// (GET /rest/getMusicDirectory)
	GetMusicDirectory(w http.ResponseWriter, r *http.Request, params GetMusicDirectoryParams)
	// Returns a listing of all files in a music directory.
	// (POST /rest/getMusicDirectory)
	PostGetMusicDirectory(w http.ResponseWriter, r *http.Request)
	// Returns all configured top-level music folders.
	// (GET /rest/getMusicFolders)
	GetMusicFolders(w http.ResponseWriter, r *http.Request)
	// Returns all configured top-level music folders.
	// (POST /rest/getMusicFolders)
	PostGetMusicFolders(w http.ResponseWriter, r *http.Request)
	// Returns the most recently published Podcast episodes.
	// (GET /rest/getNewestPodcasts)
	GetNewestPodcasts(w http.ResponseWriter, r *http.Request, params GetNewestPodcastsParams)
	// Returns the most recently published Podcast episodes.
	// (POST /rest/getNewestPodcasts)
	PostGetNewestPodcasts(w http.ResponseWriter, r *http.Request)
	// Returns what is currently being played by all users.
	// (GET /rest/getNowPlaying)
	GetNowPlaying(w http.ResponseWriter, r *http.Request)
	// Returns what is currently being played by all users.
	// (POST /rest/getNowPlaying)
	PostGetNowPlaying(w http.ResponseWriter, r *http.Request)
	// List the OpenSubsonic extensions supported by this server.
	// (GET /rest/getOpenSubsonicExtensions)
	GetOpenSubsonicExtensions(w http.ResponseWriter, r *http.Request)
	// List the OpenSubsonic extensions supported by this server.
	// (POST /rest/getOpenSubsonicExtensions)
	PostGetOpenSubsonicExtensions(w http.ResponseWriter, r *http.Request)
	// Returns the state of the play queue for this user.
	// (GET /rest/getPlayQueue)
	GetPlayQueue(w http.ResponseWriter, r *http.Request)
	// Returns the state of the play queue for this user.
	// (POST /rest/getPlayQueue)
	PostGetPlayQueue(w http.ResponseWriter, r *http.Request)
	// Returns the state of the play queue for this user, using queue index.
	// (GET /rest/getPlayQueueByIndex)
	GetPlayQueueByIndex(w http.ResponseWriter, r *http.Request)
	// Returns the state of the play queue for this user.
	// (POST /rest/getPlayQueueByIndex)
	PostGetPlayQueueByIndex(w http.ResponseWriter, r *http.Request)
	// Returns a listing of files in a saved playlist.
	// (GET /rest/getPlaylist)
	GetPlaylist(w http.ResponseWriter, r *http.Request, params GetPlaylistParams)
	// Returns a listing of files in a saved playlist.
	// (POST /rest/getPlaylist)
	PostGetPlaylist(w http.ResponseWriter, r *http.Request)
	// Returns all playlists a user is allowed to play.
	// (GET /rest/getPlaylists)
	GetPlaylists(w http.ResponseWriter, r *http.Request, params GetPlaylistsParams)
	// Returns all playlists a user is allowed to play.
	// (POST /rest/getPlaylists)
	PostGetPlaylists(w http.ResponseWriter, r *http.Request)
	// Returns details for a podcast episode.
	// (GET /rest/getPodcastEpisode)
	GetPodcastEpisode(w http.ResponseWriter, r *http.Request, params GetPodcastEpisodeParams)
	// Returns details for a podcast episode.
	// (POST /rest/getPodcastEpisode)
	PostGetPodcastEpisode(w http.ResponseWriter, r *http.Request)
	// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
	// (GET /rest/getPodcasts)
	GetPodcasts(w http.ResponseWriter, r *http.Request, params GetPodcastsParams)
	// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
	// (POST /rest/getPodcasts)
	PostGetPodcasts(w http.ResponseWriter, r *http.Request)
	// Returns random songs matching the given criteria.
	// (GET /rest/getRandomSongs)
	GetRandomSongs(w http.ResponseWriter, r *http.Request, params GetRandomSongsParams)
	// Returns random songs matching the given criteria.
	// (POST /rest/getRandomSongs)
	PostGetRandomSongs(w http.ResponseWriter, r *http.Request)
	// Returns the current status for media library scanning.
	// (GET /rest/getScanStatus)
	GetScanStatus(w http.ResponseWriter, r *http.Request)
	// Returns the current status for media library scanning.
	// (POST /rest/getScanStatus)
	PostGetScanStatus(w http.ResponseWriter, r *http.Request)
	// Returns information about shared media this user is allowed to manage.
	// (GET /rest/getShares)
	GetShares(w http.ResponseWriter, r *http.Request)
	// Returns information about shared media this user is allowed to manage.
	// (POST /rest/getShares)
	PostGetShares(w http.ResponseWriter, r *http.Request)
	// Returns a random collection of songs from the given artist and similar artists.
	// (GET /rest/getSimilarSongs)
	GetSimilarSongs(w http.ResponseWriter, r *http.Request, params GetSimilarSongsParams)
	// Returns a random collection of songs from the given artist and similar artists.
	// (POST /rest/getSimilarSongs)
	PostGetSimilarSongs(w http.ResponseWriter, r *http.Request)
	// Returns a random collection of songs from the given artist and similar artists (v2).
	// (GET /rest/getSimilarSongs2)
	GetSimilarSongs2(w http.ResponseWriter, r *http.Request, params GetSimilarSongs2Params)
	// Returns a random collection of songs from the given artist and similar artists (v2).
	// (POST /rest/getSimilarSongs2)
	PostGetSimilarSongs2(w http.ResponseWriter, r *http.Request)
	// Returns details for a song.
	// (GET /rest/getSong)
	GetSong(w http.ResponseWriter, r *http.Request, params GetSongParams)
	// Returns details for a song.
	// (POST /rest/getSong)
	PostGetSong(w http.ResponseWriter, r *http.Request)
	// Returns songs in a given genre.
	// (GET /rest/getSongsByGenre)
	GetSongsByGenre(w http.ResponseWriter, r *http.Request, params GetSongsByGenreParams)
	// Returns songs in a given genre.
	// (POST /rest/getSongsByGenre)
	PostGetSongsByGenre(w http.ResponseWriter, r *http.Request)
	// Returns starred songs, albums and artists.
	// (GET /rest/getStarred)
	GetStarred(w http.ResponseWriter, r *http.Request, params GetStarredParams)
	// Returns starred songs, albums and artists.
	// (POST /rest/getStarred)
	PostGetStarred(w http.ResponseWriter, r *http.Request)
	// Returns starred songs, albums and artists.
	// (GET /rest/getStarred2)
	GetStarred2(w http.ResponseWriter, r *http.Request, params GetStarred2Params)
	// Returns starred songs, albums and artists.
	// (POST /rest/getStarred2)
	PostGetStarred2(w http.ResponseWriter, r *http.Request)
	// Returns top songs for the given artist.
	// (GET /rest/getTopSongs)
	GetTopSongs(w http.ResponseWriter, r *http.Request, params GetTopSongsParams)
	// Returns top songs for the given artist.
	// (POST /rest/getTopSongs)
	PostGetTopSongs(w http.ResponseWriter, r *http.Request)
	// Get Transcode Decision
	// (POST /rest/getTranscodeDecision)
	GetTranscodeDecision(w http.ResponseWriter, r *http.Request, params GetTranscodeDecisionParams)
	// Get Transcoded Stream
	// (GET /rest/getTranscodeStream)
	GetTranscodeStream(w http.ResponseWriter, r *http.Request, params GetTranscodeStreamParams)
	// Get details about a given user, including which authorization roles and folder access it has.
	// (GET /rest/getUser)
	GetUser(w http.ResponseWriter, r *http.Request, params GetUserParams)
	// Get details about a given user, including which authorization roles and folder access it has.
	// (POST /rest/getUser)
	PostGetUser(w http.ResponseWriter, r *http.Request)
	// Get details about all users, including which authorization roles and folder access they have
	// (GET /rest/getUsers)
	GetUsers(w http.ResponseWriter, r *http.Request)
	// Get details about all users, including which authorization roles and folder access they have
	// (POST /rest/getUsers)
	PostGetUsers(w http.ResponseWriter, r *http.Request)
	// Returns details for a video.
	// (GET /rest/getVideoInfo)
	GetVideoInfo(w http.ResponseWriter, r *http.Request, params GetVideoInfoParams)
	// Returns details for a video.
	// (POST /rest/getVideoInfo)
	PostGetVideoInfo(w http.ResponseWriter, r *http.Request)
	// Returns all video files.
	// (GET /rest/getVideos)
	GetVideos(w http.ResponseWriter, r *http.Request)
	// Returns all video files.
	// (POST /rest/getVideos)
	PostGetVideos(w http.ResponseWriter, r *http.Request)
	// Downloads a given media file (HLS).
	// (GET /rest/hls.m3u8)
	HlsM3u8(w http.ResponseWriter, r *http.Request, params HlsM3u8Params)
	// Downloads a given media file (HLS).
	// (POST /rest/hls.m3u8)
	PostHlsM3u8(w http.ResponseWriter, r *http.Request)
	// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
	// (GET /rest/jukeboxControl)
	JukeboxControl(w http.ResponseWriter, r *http.Request, params JukeboxControlParams)
	// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
	// (POST /rest/jukeboxControl)
	PostJukeboxControl(w http.ResponseWriter, r *http.Request)
	// Used to test connectivity with the server.
	// (GET /rest/ping)
	Ping(w http.ResponseWriter, r *http.Request)
	// Used to test connectivity with the server.
	// (POST /rest/ping)
	PostPing(w http.ResponseWriter, r *http.Request)
	// Requests the server to check for new Podcast episodes.
	// (GET /rest/refreshPodcasts)
	RefreshPodcasts(w http.ResponseWriter, r *http.Request)
	// Requests the server to check for new Podcast episodes.
	// (POST /rest/refreshPodcasts)
	PostRefreshPodcasts(w http.ResponseWriter, r *http.Request)
	// Saves the state of the play queue for this user.
	// (GET /rest/savePlayQueue)
	SavePlayQueue(w http.ResponseWriter, r *http.Request, params SavePlayQueueParams)
	// Saves the state of the play queue for this user.
	// (POST /rest/savePlayQueue)
	PostSavePlayQueue(w http.ResponseWriter, r *http.Request)
	// Saves the state of the play queue for this user, using queue index.
	// (GET /rest/savePlayQueueByIndex)
	SavePlayQueueByIndex(w http.ResponseWriter, r *http.Request, params SavePlayQueueByIndexParams)
	// Saves the state of the play queue for this user.
	// (POST /rest/savePlayQueueByIndex)
	PostSavePlayQueueByIndex(w http.ResponseWriter, r *http.Request)
	// Registers the local playback of one or more media files.
	// (GET /rest/scrobble)
	Scrobble(w http.ResponseWriter, r *http.Request, params ScrobbleParams)
	// Registers the local playback of one or more media files.
	// (POST /rest/scrobble)
	PostScrobble(w http.ResponseWriter, r *http.Request)
	// Returns a listing of files matching the given search criteria. Supports paging through the result.
	// (GET /rest/search)
	Search(w http.ResponseWriter, r *http.Request, params SearchParams)
	// Returns a listing of files matching the given search criteria. Supports paging through the result.
	// (POST /rest/search)
	PostSearch(w http.ResponseWriter, r *http.Request)
	// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
	// (GET /rest/search2)
	Search2(w http.ResponseWriter, r *http.Request, params Search2Params)
	// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
	// (POST /rest/search2)
	PostSearch2(w http.ResponseWriter, r *http.Request)
	// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
	// (GET /rest/search3)
	Search3(w http.ResponseWriter, r *http.Request, params Search3Params)
	// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
	// (POST /rest/search3)
	PostSearch3(w http.ResponseWriter, r *http.Request)
	// Sets the rating for a music file.
	// (GET /rest/setRating)
	SetRating(w http.ResponseWriter, r *http.Request, params SetRatingParams)
	// Sets the rating for a music file.
	// (POST /rest/setRating)
	PostSetRating(w http.ResponseWriter, r *http.Request)
	// Attaches a star to a song, album or artist.
	// (GET /rest/star)
	Star(w http.ResponseWriter, r *http.Request, params StarParams)
	// Attaches a star to a song, album or artist.
	// (POST /rest/star)
	PostStar(w http.ResponseWriter, r *http.Request)
	// Initiates a rescan of the media libraries.
	// (GET /rest/startScan)
	StartScan(w http.ResponseWriter, r *http.Request)
	// Initiates a rescan of the media libraries.
	// (POST /rest/startScan)
	PostStartScan(w http.ResponseWriter, r *http.Request)
	// Streams a given media file.
	// (GET /rest/stream)
	Stream(w http.ResponseWriter, r *http.Request, params StreamParams)
	// Streams a given media file.
	// (POST /rest/stream)
	PostStream(w http.ResponseWriter, r *http.Request)
	// Returns information about an API key
	// (GET /rest/tokenInfo)
	TokenInfo(w http.ResponseWriter, r *http.Request)
	// Returns information about an API key
	// (POST /rest/tokenInfo)
	PostTokenInfo(w http.ResponseWriter, r *http.Request)
	// Removes a star to a song, album or artist.
	// (GET /rest/unstar)
	Unstar(w http.ResponseWriter, r *http.Request, params UnstarParams)
	// Removes a star to a song, album or artist.
	// (POST /rest/unstar)
	PostUnstar(w http.ResponseWriter, r *http.Request)
	// Updates an existing internet radio station.
	// (GET /rest/updateInternetRadioStation)
	UpdateInternetRadioStation(w http.ResponseWriter, r *http.Request, params UpdateInternetRadioStationParams)
	// Updates an existing internet radio station.
	// (POST /rest/updateInternetRadioStation)
	PostUpdateInternetRadioStation(w http.ResponseWriter, r *http.Request)
	// Updates a playlist. Only the owner of a playlist is allowed to update it.
	// (GET /rest/updatePlaylist)
	UpdatePlaylist(w http.ResponseWriter, r *http.Request, params UpdatePlaylistParams)
	// Updates a playlist. Only the owner of a playlist is allowed to update it.
	// (POST /rest/updatePlaylist)
	PostUpdatePlaylist(w http.ResponseWriter, r *http.Request)
	// Updates the description and/or expiration date for an existing share.
	// (GET /rest/updateShare)
	UpdateShare(w http.ResponseWriter, r *http.Request, params UpdateShareParams)
	// Updates the description and/or expiration date for an existing share.
	// (POST /rest/updateShare)
	PostUpdateShare(w http.ResponseWriter, r *http.Request)
	// Modifies an existing user on the server.
	// (GET /rest/updateUser)
	UpdateUser(w http.ResponseWriter, r *http.Request, params UpdateUserParams)
	// Modifies an existing user on the server.
	// (POST /rest/updateUser)
	PostUpdateUser(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetAddChatMessage operation middleware
func (siw *ServerInterfaceWrapper) GetAddChatMessage(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAddChatMessageParams

	// ------------- Required query parameter "message" -------------

	if paramValue := r.URL.Query().Get("message"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "message"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "message", r.URL.Query(), &params.Message)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "message", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAddChatMessage(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostAddChatMessage operation middleware
func (siw *ServerInterfaceWrapper) PostAddChatMessage(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostAddChatMessage(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ChangePassword operation middleware
func (siw *ServerInterfaceWrapper) ChangePassword(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ChangePasswordParams

	// ------------- Required query parameter "username" -------------

	if paramValue := r.URL.Query().Get("username"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "username"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", r.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	// ------------- Required query parameter "password" -------------

	if paramValue := r.URL.Query().Get("password"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "password"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "password", r.URL.Query(), &params.Password)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "password", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ChangePassword(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostChangePassword operation middleware
func (siw *ServerInterfaceWrapper) PostChangePassword(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostChangePassword(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateBookmark operation middleware
func (siw *ServerInterfaceWrapper) CreateBookmark(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateBookmarkParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Required query parameter "position" -------------

	if paramValue := r.URL.Query().Get("position"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "position"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "position", r.URL.Query(), &params.Position)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "position", Err: err})
		return
	}

	// ------------- Optional query parameter "comment" -------------

	err = runtime.BindQueryParameter("form", true, false, "comment", r.URL.Query(), &params.Comment)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "comment", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBookmark(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostCreateBookmark operation middleware
func (siw *ServerInterfaceWrapper) PostCreateBookmark(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostCreateBookmark(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateInternetRadioStation operation middleware
func (siw *ServerInterfaceWrapper) CreateInternetRadioStation(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateInternetRadioStationParams

	// ------------- Required query parameter "streamUrl" -------------

	if paramValue := r.URL.Query().Get("streamUrl"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "streamUrl"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "streamUrl", r.URL.Query(), &params.StreamUrl)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "streamUrl", Err: err})
		return
	}

	// ------------- Required query parameter "name" -------------

	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "homepageUrl" -------------

	err = runtime.BindQueryParameter("form", true, false, "homepageUrl", r.URL.Query(), &params.HomepageUrl)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "homepageUrl", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateInternetRadioStation(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostCreateInternetRadioStation operation middleware
func (siw *ServerInterfaceWrapper) PostCreateInternetRadioStation(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostCreateInternetRadioStation(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePlaylist operation middleware
func (siw *ServerInterfaceWrapper) CreatePlaylist(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePlaylistParams

	// ------------- Optional query parameter "playlistId" -------------

	err = runtime.BindQueryParameter("form", true, false, "playlistId", r.URL.Query(), &params.PlaylistId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "playlistId", Err: err})
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "songId" -------------

	err = runtime.BindQueryParameter("form", true, false, "songId", r.URL.Query(), &params.SongId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "songId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePlaylist(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostCreatePlaylist operation middleware
func (siw *ServerInterfaceWrapper) PostCreatePlaylist(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostCreatePlaylist(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreatePodcastChannel operation middleware
func (siw *ServerInterfaceWrapper) CreatePodcastChannel(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePodcastChannelParams

	// ------------- Required query parameter "url" -------------

	if paramValue := r.URL.Query().Get("url"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "url"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "url", r.URL.Query(), &params.Url)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "url", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePodcastChannel(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostCreatePodcastChannel operation middleware
func (siw *ServerInterfaceWrapper) PostCreatePodcastChannel(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostCreatePodcastChannel(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateShare operation middleware
func (siw *ServerInterfaceWrapper) CreateShare(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateShareParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", r.URL.Query(), &params.Description)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "description", Err: err})
		return
	}

	// ------------- Optional query parameter "expires" -------------

	err = runtime.BindQueryParameter("form", true, false, "expires", r.URL.Query(), &params.Expires)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expires", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateShare(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostCreateShare operation middleware
func (siw *ServerInterfaceWrapper) PostCreateShare(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostCreateShare(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateUserParams

	// ------------- Required query parameter "username" -------------

	if paramValue := r.URL.Query().Get("username"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "username"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", r.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	// ------------- Required query parameter "password" -------------

	if paramValue := r.URL.Query().Get("password"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "password"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "password", r.URL.Query(), &params.Password)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "password", Err: err})
		return
	}

	// ------------- Required query parameter "email" -------------

	if paramValue := r.URL.Query().Get("email"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "email"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "email", r.URL.Query(), &params.Email)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "email", Err: err})
		return
	}

	// ------------- Optional query parameter "ldapAuthenticated" -------------

	err = runtime.BindQueryParameter("form", true, false, "ldapAuthenticated", r.URL.Query(), &params.LdapAuthenticated)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ldapAuthenticated", Err: err})
		return
	}

	// ------------- Optional query parameter "adminRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "adminRole", r.URL.Query(), &params.AdminRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "adminRole", Err: err})
		return
	}

	// ------------- Optional query parameter "settingsRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "settingsRole", r.URL.Query(), &params.SettingsRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "settingsRole", Err: err})
		return
	}

	// ------------- Optional query parameter "streamRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "streamRole", r.URL.Query(), &params.StreamRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "streamRole", Err: err})
		return
	}

	// ------------- Optional query parameter "jukeboxRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "jukeboxRole", r.URL.Query(), &params.JukeboxRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jukeboxRole", Err: err})
		return
	}

	// ------------- Optional query parameter "downloadRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "downloadRole", r.URL.Query(), &params.DownloadRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "downloadRole", Err: err})
		return
	}

	// ------------- Optional query parameter "uploadRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "uploadRole", r.URL.Query(), &params.UploadRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uploadRole", Err: err})
		return
	}

	// ------------- Optional query parameter "playlistRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "playlistRole", r.URL.Query(), &params.PlaylistRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "playlistRole", Err: err})
		return
	}

	// ------------- Optional query parameter "coverArtRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "coverArtRole", r.URL.Query(), &params.CoverArtRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "coverArtRole", Err: err})
		return
	}

	// ------------- Optional query parameter "commentRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "commentRole", r.URL.Query(), &params.CommentRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "commentRole", Err: err})
		return
	}

	// ------------- Optional query parameter "podcastRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "podcastRole", r.URL.Query(), &params.PodcastRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "podcastRole", Err: err})
		return
	}

	// ------------- Optional query parameter "shareRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "shareRole", r.URL.Query(), &params.ShareRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "shareRole", Err: err})
		return
	}

	// ------------- Optional query parameter "videoConversionRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "videoConversionRole", r.URL.Query(), &params.VideoConversionRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "videoConversionRole", Err: err})
		return
	}

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostCreateUser operation middleware
func (siw *ServerInterfaceWrapper) PostCreateUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostCreateUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteBookmark operation middleware
func (siw *ServerInterfaceWrapper) DeleteBookmark(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteBookmarkParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBookmark(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDeleteBookmark operation middleware
func (siw *ServerInterfaceWrapper) PostDeleteBookmark(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDeleteBookmark(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteInternetRadioStation operation middleware
func (siw *ServerInterfaceWrapper) DeleteInternetRadioStation(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteInternetRadioStationParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteInternetRadioStation(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDeleteInternetRadioStation operation middleware
func (siw *ServerInterfaceWrapper) PostDeleteInternetRadioStation(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDeleteInternetRadioStation(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePlaylist operation middleware
func (siw *ServerInterfaceWrapper) DeletePlaylist(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeletePlaylistParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePlaylist(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDeletePlaylist operation middleware
func (siw *ServerInterfaceWrapper) PostDeletePlaylist(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDeletePlaylist(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePodcastChannel operation middleware
func (siw *ServerInterfaceWrapper) DeletePodcastChannel(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeletePodcastChannelParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePodcastChannel(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDeletePodcastChannel operation middleware
func (siw *ServerInterfaceWrapper) PostDeletePodcastChannel(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDeletePodcastChannel(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeletePodcastEpisode operation middleware
func (siw *ServerInterfaceWrapper) DeletePodcastEpisode(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeletePodcastEpisodeParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePodcastEpisode(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDeletePodcastEpisode operation middleware
func (siw *ServerInterfaceWrapper) PostDeletePodcastEpisode(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDeletePodcastEpisode(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteShare operation middleware
func (siw *ServerInterfaceWrapper) DeleteShare(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteShareParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteShare(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDeleteShare operation middleware
func (siw *ServerInterfaceWrapper) PostDeleteShare(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDeleteShare(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteUserParams

	// ------------- Required query parameter "username" -------------

	if paramValue := r.URL.Query().Get("username"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "username"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", r.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDeleteUser operation middleware
func (siw *ServerInterfaceWrapper) PostDeleteUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDeleteUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Download operation middleware
func (siw *ServerInterfaceWrapper) Download(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Download(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDownload operation middleware
func (siw *ServerInterfaceWrapper) PostDownload(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDownload(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadPodcastEpisode operation middleware
func (siw *ServerInterfaceWrapper) DownloadPodcastEpisode(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadPodcastEpisodeParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadPodcastEpisode(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostDownloadPodcastEpisode operation middleware
func (siw *ServerInterfaceWrapper) PostDownloadPodcastEpisode(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostDownloadPodcastEpisode(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAlbum operation middleware
func (siw *ServerInterfaceWrapper) GetAlbum(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAlbumParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAlbum(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetAlbum operation middleware
func (siw *ServerInterfaceWrapper) PostGetAlbum(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetAlbum(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAlbumInfo operation middleware
func (siw *ServerInterfaceWrapper) GetAlbumInfo(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAlbumInfoParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAlbumInfo(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetAlbumInfo operation middleware
func (siw *ServerInterfaceWrapper) PostGetAlbumInfo(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetAlbumInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAlbumInfo2 operation middleware
func (siw *ServerInterfaceWrapper) GetAlbumInfo2(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAlbumInfo2Params

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAlbumInfo2(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetAlbumInfo2 operation middleware
func (siw *ServerInterfaceWrapper) PostGetAlbumInfo2(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetAlbumInfo2(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAlbumList operation middleware
func (siw *ServerInterfaceWrapper) GetAlbumList(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAlbumListParams

	// ------------- Required query parameter "type" -------------

	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "type"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "fromYear" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromYear", r.URL.Query(), &params.FromYear)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromYear", Err: err})
		return
	}

	// ------------- Optional query parameter "toYear" -------------

	err = runtime.BindQueryParameter("form", true, false, "toYear", r.URL.Query(), &params.ToYear)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toYear", Err: err})
		return
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", r.URL.Query(), &params.Genre)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "genre", Err: err})
		return
	}

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAlbumList(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetAlbumList operation middleware
func (siw *ServerInterfaceWrapper) PostGetAlbumList(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetAlbumList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAlbumList2 operation middleware
func (siw *ServerInterfaceWrapper) GetAlbumList2(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAlbumList2Params

	// ------------- Required query parameter "type" -------------

	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "type"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "fromYear" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromYear", r.URL.Query(), &params.FromYear)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromYear", Err: err})
		return
	}

	// ------------- Optional query parameter "toYear" -------------

	err = runtime.BindQueryParameter("form", true, false, "toYear", r.URL.Query(), &params.ToYear)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toYear", Err: err})
		return
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", r.URL.Query(), &params.Genre)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "genre", Err: err})
		return
	}

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAlbumList2(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetAlbumList2 operation middleware
func (siw *ServerInterfaceWrapper) PostGetAlbumList2(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetAlbumList2(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetArtist operation middleware
func (siw *ServerInterfaceWrapper) GetArtist(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArtistParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetArtist(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetArtist operation middleware
func (siw *ServerInterfaceWrapper) PostGetArtist(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetArtist(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetArtistInfo operation middleware
func (siw *ServerInterfaceWrapper) GetArtistInfo(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArtistInfoParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count", Err: err})
		return
	}

	// ------------- Optional query parameter "includeNotPresent" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeNotPresent", r.URL.Query(), &params.IncludeNotPresent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeNotPresent", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetArtistInfo(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetArtistInfo operation middleware
func (siw *ServerInterfaceWrapper) PostGetArtistInfo(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetArtistInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetArtistInfo2 operation middleware
func (siw *ServerInterfaceWrapper) GetArtistInfo2(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArtistInfo2Params

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count", Err: err})
		return
	}

	// ------------- Optional query parameter "includeNotPresent" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeNotPresent", r.URL.Query(), &params.IncludeNotPresent)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeNotPresent", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetArtistInfo2(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetArtistInfo2 operation middleware
func (siw *ServerInterfaceWrapper) PostGetArtistInfo2(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetArtistInfo2(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetArtists operation middleware
func (siw *ServerInterfaceWrapper) GetArtists(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArtistsParams

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetArtists(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetArtists operation middleware
func (siw *ServerInterfaceWrapper) PostGetArtists(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetArtists(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAvatar operation middleware
func (siw *ServerInterfaceWrapper) GetAvatar(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAvatarParams

	// ------------- Required query parameter "username" -------------

	if paramValue := r.URL.Query().Get("username"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "username"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", r.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAvatar(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetAvatar operation middleware
func (siw *ServerInterfaceWrapper) PostGetAvatar(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetAvatar(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetBookmarks operation middleware
func (siw *ServerInterfaceWrapper) GetBookmarks(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBookmarks(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetBookmarks operation middleware
func (siw *ServerInterfaceWrapper) PostGetBookmarks(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetBookmarks(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCaptions operation middleware
func (siw *ServerInterfaceWrapper) GetCaptions(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCaptionsParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCaptions(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetCaptions operation middleware
func (siw *ServerInterfaceWrapper) PostGetCaptions(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetCaptions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetChatMessages operation middleware
func (siw *ServerInterfaceWrapper) GetChatMessages(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetChatMessages(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetChatMessages operation middleware
func (siw *ServerInterfaceWrapper) PostGetChatMessages(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetChatMessages(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCoverArt operation middleware
func (siw *ServerInterfaceWrapper) GetCoverArt(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCoverArtParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCoverArt(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetCoverArt operation middleware
func (siw *ServerInterfaceWrapper) PostGetCoverArt(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetCoverArt(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGenres operation middleware
func (siw *ServerInterfaceWrapper) GetGenres(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGenres(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetGenres operation middleware
func (siw *ServerInterfaceWrapper) PostGetGenres(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetGenres(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetIndexes operation middleware
func (siw *ServerInterfaceWrapper) GetIndexes(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIndexesParams

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	// ------------- Optional query parameter "ifModifiedSince" -------------

	err = runtime.BindQueryParameter("form", true, false, "ifModifiedSince", r.URL.Query(), &params.IfModifiedSince)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ifModifiedSince", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetIndexes(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetIndexes operation middleware
func (siw *ServerInterfaceWrapper) PostGetIndexes(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetIndexes(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetInternetRadioStations operation middleware
func (siw *ServerInterfaceWrapper) GetInternetRadioStations(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInternetRadioStations(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetInternetRadioStations operation middleware
func (siw *ServerInterfaceWrapper) PostGetInternetRadioStations(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetInternetRadioStations(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetLicense operation middleware
func (siw *ServerInterfaceWrapper) GetLicense(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLicense(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetLicense operation middleware
func (siw *ServerInterfaceWrapper) PostGetLicense(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetLicense(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetLyrics operation middleware
func (siw *ServerInterfaceWrapper) GetLyrics(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLyricsParams

	// ------------- Optional query parameter "artist" -------------

	err = runtime.BindQueryParameter("form", true, false, "artist", r.URL.Query(), &params.Artist)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "artist", Err: err})
		return
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", r.URL.Query(), &params.Title)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "title", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLyrics(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetLyrics operation middleware
func (siw *ServerInterfaceWrapper) PostGetLyrics(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetLyrics(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetLyricsBySongId operation middleware
func (siw *ServerInterfaceWrapper) GetLyricsBySongId(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLyricsBySongIdParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLyricsBySongId(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetLyricsBySongId operation middleware
func (siw *ServerInterfaceWrapper) PostGetLyricsBySongId(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetLyricsBySongId(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMusicDirectory operation middleware
func (siw *ServerInterfaceWrapper) GetMusicDirectory(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMusicDirectoryParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMusicDirectory(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetMusicDirectory operation middleware
func (siw *ServerInterfaceWrapper) PostGetMusicDirectory(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetMusicDirectory(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMusicFolders operation middleware
func (siw *ServerInterfaceWrapper) GetMusicFolders(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMusicFolders(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetMusicFolders operation middleware
func (siw *ServerInterfaceWrapper) PostGetMusicFolders(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetMusicFolders(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNewestPodcasts operation middleware
func (siw *ServerInterfaceWrapper) GetNewestPodcasts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNewestPodcastsParams

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNewestPodcasts(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetNewestPodcasts operation middleware
func (siw *ServerInterfaceWrapper) PostGetNewestPodcasts(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetNewestPodcasts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNowPlaying operation middleware
func (siw *ServerInterfaceWrapper) GetNowPlaying(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNowPlaying(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetNowPlaying operation middleware
func (siw *ServerInterfaceWrapper) PostGetNowPlaying(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetNowPlaying(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOpenSubsonicExtensions operation middleware
func (siw *ServerInterfaceWrapper) GetOpenSubsonicExtensions(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOpenSubsonicExtensions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetOpenSubsonicExtensions operation middleware
func (siw *ServerInterfaceWrapper) PostGetOpenSubsonicExtensions(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetOpenSubsonicExtensions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPlayQueue operation middleware
func (siw *ServerInterfaceWrapper) GetPlayQueue(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPlayQueue(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetPlayQueue operation middleware
func (siw *ServerInterfaceWrapper) PostGetPlayQueue(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetPlayQueue(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPlayQueueByIndex operation middleware
func (siw *ServerInterfaceWrapper) GetPlayQueueByIndex(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPlayQueueByIndex(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetPlayQueueByIndex operation middleware
func (siw *ServerInterfaceWrapper) PostGetPlayQueueByIndex(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetPlayQueueByIndex(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPlaylist operation middleware
func (siw *ServerInterfaceWrapper) GetPlaylist(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPlaylistParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPlaylist(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetPlaylist operation middleware
func (siw *ServerInterfaceWrapper) PostGetPlaylist(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetPlaylist(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPlaylists operation middleware
func (siw *ServerInterfaceWrapper) GetPlaylists(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPlaylistsParams

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", r.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPlaylists(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetPlaylists operation middleware
func (siw *ServerInterfaceWrapper) PostGetPlaylists(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetPlaylists(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPodcastEpisode operation middleware
func (siw *ServerInterfaceWrapper) GetPodcastEpisode(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPodcastEpisodeParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPodcastEpisode(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetPodcastEpisode operation middleware
func (siw *ServerInterfaceWrapper) PostGetPodcastEpisode(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetPodcastEpisode(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPodcasts operation middleware
func (siw *ServerInterfaceWrapper) GetPodcasts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPodcastsParams

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "includeEpisodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeEpisodes", r.URL.Query(), &params.IncludeEpisodes)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "includeEpisodes", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPodcasts(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetPodcasts operation middleware
func (siw *ServerInterfaceWrapper) PostGetPodcasts(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetPodcasts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRandomSongs operation middleware
func (siw *ServerInterfaceWrapper) GetRandomSongs(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRandomSongsParams

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", r.URL.Query(), &params.Genre)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "genre", Err: err})
		return
	}

	// ------------- Optional query parameter "fromYear" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromYear", r.URL.Query(), &params.FromYear)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromYear", Err: err})
		return
	}

	// ------------- Optional query parameter "toYear" -------------

	err = runtime.BindQueryParameter("form", true, false, "toYear", r.URL.Query(), &params.ToYear)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toYear", Err: err})
		return
	}

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRandomSongs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetRandomSongs operation middleware
func (siw *ServerInterfaceWrapper) PostGetRandomSongs(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetRandomSongs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetScanStatus operation middleware
func (siw *ServerInterfaceWrapper) GetScanStatus(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetScanStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetScanStatus operation middleware
func (siw *ServerInterfaceWrapper) PostGetScanStatus(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetScanStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetShares operation middleware
func (siw *ServerInterfaceWrapper) GetShares(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetShares(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetShares operation middleware
func (siw *ServerInterfaceWrapper) PostGetShares(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetShares(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSimilarSongs operation middleware
func (siw *ServerInterfaceWrapper) GetSimilarSongs(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSimilarSongsParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSimilarSongs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetSimilarSongs operation middleware
func (siw *ServerInterfaceWrapper) PostGetSimilarSongs(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetSimilarSongs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSimilarSongs2 operation middleware
func (siw *ServerInterfaceWrapper) GetSimilarSongs2(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSimilarSongs2Params

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSimilarSongs2(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetSimilarSongs2 operation middleware
func (siw *ServerInterfaceWrapper) PostGetSimilarSongs2(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetSimilarSongs2(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSong operation middleware
func (siw *ServerInterfaceWrapper) GetSong(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSongParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSong(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetSong operation middleware
func (siw *ServerInterfaceWrapper) PostGetSong(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetSong(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSongsByGenre operation middleware
func (siw *ServerInterfaceWrapper) GetSongsByGenre(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSongsByGenreParams

	// ------------- Required query parameter "genre" -------------

	if paramValue := r.URL.Query().Get("genre"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "genre"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "genre", r.URL.Query(), &params.Genre)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "genre", Err: err})
		return
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSongsByGenre(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetSongsByGenre operation middleware
func (siw *ServerInterfaceWrapper) PostGetSongsByGenre(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetSongsByGenre(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetStarred operation middleware
func (siw *ServerInterfaceWrapper) GetStarred(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStarredParams

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStarred(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetStarred operation middleware
func (siw *ServerInterfaceWrapper) PostGetStarred(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetStarred(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetStarred2 operation middleware
func (siw *ServerInterfaceWrapper) GetStarred2(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStarred2Params

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStarred2(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetStarred2 operation middleware
func (siw *ServerInterfaceWrapper) PostGetStarred2(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetStarred2(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTopSongs operation middleware
func (siw *ServerInterfaceWrapper) GetTopSongs(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTopSongsParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTopSongs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetTopSongs operation middleware
func (siw *ServerInterfaceWrapper) PostGetTopSongs(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetTopSongs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTranscodeDecision operation middleware
func (siw *ServerInterfaceWrapper) GetTranscodeDecision(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTranscodeDecisionParams

	// ------------- Required query parameter "mediaId" -------------

	if paramValue := r.URL.Query().Get("mediaId"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "mediaId"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "mediaId", r.URL.Query(), &params.MediaId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mediaId", Err: err})
		return
	}

	// ------------- Required query parameter "mediaType" -------------

	if paramValue := r.URL.Query().Get("mediaType"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "mediaType"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "mediaType", r.URL.Query(), &params.MediaType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mediaType", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTranscodeDecision(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTranscodeStream operation middleware
func (siw *ServerInterfaceWrapper) GetTranscodeStream(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTranscodeStreamParams

	// ------------- Required query parameter "mediaId" -------------

	if paramValue := r.URL.Query().Get("mediaId"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "mediaId"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "mediaId", r.URL.Query(), &params.MediaId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mediaId", Err: err})
		return
	}

	// ------------- Required query parameter "mediaType" -------------

	if paramValue := r.URL.Query().Get("mediaType"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "mediaType"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "mediaType", r.URL.Query(), &params.MediaType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mediaType", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Required query parameter "transcodeParams" -------------

	if paramValue := r.URL.Query().Get("transcodeParams"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "transcodeParams"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "transcodeParams", r.URL.Query(), &params.TranscodeParams)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "transcodeParams", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTranscodeStream(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserParams

	// ------------- Required query parameter "username" -------------

	if paramValue := r.URL.Query().Get("username"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "username"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", r.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetUser operation middleware
func (siw *ServerInterfaceWrapper) PostGetUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUsers operation middleware
func (siw *ServerInterfaceWrapper) GetUsers(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUsers(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetUsers operation middleware
func (siw *ServerInterfaceWrapper) PostGetUsers(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetUsers(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetVideoInfo operation middleware
func (siw *ServerInterfaceWrapper) GetVideoInfo(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVideoInfoParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVideoInfo(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetVideoInfo operation middleware
func (siw *ServerInterfaceWrapper) PostGetVideoInfo(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetVideoInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetVideos operation middleware
func (siw *ServerInterfaceWrapper) GetVideos(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetVideos(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostGetVideos operation middleware
func (siw *ServerInterfaceWrapper) PostGetVideos(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostGetVideos(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HlsM3u8 operation middleware
func (siw *ServerInterfaceWrapper) HlsM3u8(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HlsM3u8Params

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "bitRate" -------------

	err = runtime.BindQueryParameter("form", true, false, "bitRate", r.URL.Query(), &params.BitRate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bitRate", Err: err})
		return
	}

	// ------------- Optional query parameter "audioTrack" -------------

	err = runtime.BindQueryParameter("form", true, false, "audioTrack", r.URL.Query(), &params.AudioTrack)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "audioTrack", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HlsM3u8(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostHlsM3u8 operation middleware
func (siw *ServerInterfaceWrapper) PostHlsM3u8(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostHlsM3u8(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// JukeboxControl operation middleware
func (siw *ServerInterfaceWrapper) JukeboxControl(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params JukeboxControlParams

	// ------------- Required query parameter "action" -------------

	if paramValue := r.URL.Query().Get("action"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "action"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "action", r.URL.Query(), &params.Action)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "action", Err: err})
		return
	}

	// ------------- Optional query parameter "index" -------------

	err = runtime.BindQueryParameter("form", true, false, "index", r.URL.Query(), &params.Index)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "index", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "gain" -------------

	err = runtime.BindQueryParameter("form", true, false, "gain", r.URL.Query(), &params.Gain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "gain", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.JukeboxControl(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostJukeboxControl operation middleware
func (siw *ServerInterfaceWrapper) PostJukeboxControl(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostJukeboxControl(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Ping operation middleware
func (siw *ServerInterfaceWrapper) Ping(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Ping(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostPing operation middleware
func (siw *ServerInterfaceWrapper) PostPing(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostPing(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RefreshPodcasts operation middleware
func (siw *ServerInterfaceWrapper) RefreshPodcasts(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RefreshPodcasts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostRefreshPodcasts operation middleware
func (siw *ServerInterfaceWrapper) PostRefreshPodcasts(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostRefreshPodcasts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SavePlayQueue operation middleware
func (siw *ServerInterfaceWrapper) SavePlayQueue(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SavePlayQueueParams

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "current" -------------

	err = runtime.BindQueryParameter("form", true, false, "current", r.URL.Query(), &params.Current)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "current", Err: err})
		return
	}

	// ------------- Optional query parameter "position" -------------

	err = runtime.BindQueryParameter("form", true, false, "position", r.URL.Query(), &params.Position)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "position", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SavePlayQueue(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostSavePlayQueue operation middleware
func (siw *ServerInterfaceWrapper) PostSavePlayQueue(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSavePlayQueue(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SavePlayQueueByIndex operation middleware
func (siw *ServerInterfaceWrapper) SavePlayQueueByIndex(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SavePlayQueueByIndexParams

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "currentIndex" -------------

	err = runtime.BindQueryParameter("form", true, false, "currentIndex", r.URL.Query(), &params.CurrentIndex)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "currentIndex", Err: err})
		return
	}

	// ------------- Optional query parameter "position" -------------

	err = runtime.BindQueryParameter("form", true, false, "position", r.URL.Query(), &params.Position)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "position", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SavePlayQueueByIndex(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostSavePlayQueueByIndex operation middleware
func (siw *ServerInterfaceWrapper) PostSavePlayQueueByIndex(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSavePlayQueueByIndex(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Scrobble operation middleware
func (siw *ServerInterfaceWrapper) Scrobble(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ScrobbleParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "time" -------------

	err = runtime.BindQueryParameter("form", true, false, "time", r.URL.Query(), &params.Time)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time", Err: err})
		return
	}

	// ------------- Optional query parameter "submission" -------------

	err = runtime.BindQueryParameter("form", true, false, "submission", r.URL.Query(), &params.Submission)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "submission", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Scrobble(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostScrobble operation middleware
func (siw *ServerInterfaceWrapper) PostScrobble(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostScrobble(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Search operation middleware
func (siw *ServerInterfaceWrapper) Search(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams

	// ------------- Optional query parameter "artist" -------------

	err = runtime.BindQueryParameter("form", true, false, "artist", r.URL.Query(), &params.Artist)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "artist", Err: err})
		return
	}

	// ------------- Optional query parameter "album" -------------

	err = runtime.BindQueryParameter("form", true, false, "album", r.URL.Query(), &params.Album)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "album", Err: err})
		return
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", r.URL.Query(), &params.Title)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "title", Err: err})
		return
	}

	// ------------- Optional query parameter "any" -------------

	err = runtime.BindQueryParameter("form", true, false, "any", r.URL.Query(), &params.Any)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "any", Err: err})
		return
	}

	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", r.URL.Query(), &params.Count)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "count", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "newerThan" -------------

	err = runtime.BindQueryParameter("form", true, false, "newerThan", r.URL.Query(), &params.NewerThan)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "newerThan", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Search(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostSearch operation middleware
func (siw *ServerInterfaceWrapper) PostSearch(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSearch(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Search2 operation middleware
func (siw *ServerInterfaceWrapper) Search2(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params Search2Params

	// ------------- Required query parameter "query" -------------

	if paramValue := r.URL.Query().Get("query"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "query"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "query", r.URL.Query(), &params.Query)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "query", Err: err})
		return
	}

	// ------------- Optional query parameter "artistCount" -------------

	err = runtime.BindQueryParameter("form", true, false, "artistCount", r.URL.Query(), &params.ArtistCount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "artistCount", Err: err})
		return
	}

	// ------------- Optional query parameter "artistOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "artistOffset", r.URL.Query(), &params.ArtistOffset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "artistOffset", Err: err})
		return
	}

	// ------------- Optional query parameter "albumCount" -------------

	err = runtime.BindQueryParameter("form", true, false, "albumCount", r.URL.Query(), &params.AlbumCount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "albumCount", Err: err})
		return
	}

	// ------------- Optional query parameter "albumOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "albumOffset", r.URL.Query(), &params.AlbumOffset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "albumOffset", Err: err})
		return
	}

	// ------------- Optional query parameter "songCount" -------------

	err = runtime.BindQueryParameter("form", true, false, "songCount", r.URL.Query(), &params.SongCount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "songCount", Err: err})
		return
	}

	// ------------- Optional query parameter "songOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "songOffset", r.URL.Query(), &params.SongOffset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "songOffset", Err: err})
		return
	}

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Search2(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostSearch2 operation middleware
func (siw *ServerInterfaceWrapper) PostSearch2(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSearch2(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Search3 operation middleware
func (siw *ServerInterfaceWrapper) Search3(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params Search3Params

	// ------------- Required query parameter "query" -------------

	if paramValue := r.URL.Query().Get("query"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "query"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "query", r.URL.Query(), &params.Query)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "query", Err: err})
		return
	}

	// ------------- Optional query parameter "artistCount" -------------

	err = runtime.BindQueryParameter("form", true, false, "artistCount", r.URL.Query(), &params.ArtistCount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "artistCount", Err: err})
		return
	}

	// ------------- Optional query parameter "artistOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "artistOffset", r.URL.Query(), &params.ArtistOffset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "artistOffset", Err: err})
		return
	}

	// ------------- Optional query parameter "albumCount" -------------

	err = runtime.BindQueryParameter("form", true, false, "albumCount", r.URL.Query(), &params.AlbumCount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "albumCount", Err: err})
		return
	}

	// ------------- Optional query parameter "albumOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "albumOffset", r.URL.Query(), &params.AlbumOffset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "albumOffset", Err: err})
		return
	}

	// ------------- Optional query parameter "songCount" -------------

	err = runtime.BindQueryParameter("form", true, false, "songCount", r.URL.Query(), &params.SongCount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "songCount", Err: err})
		return
	}

	// ------------- Optional query parameter "songOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "songOffset", r.URL.Query(), &params.SongOffset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "songOffset", Err: err})
		return
	}

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Search3(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostSearch3 operation middleware
func (siw *ServerInterfaceWrapper) PostSearch3(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSearch3(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetRating operation middleware
func (siw *ServerInterfaceWrapper) SetRating(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SetRatingParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Required query parameter "rating" -------------

	if paramValue := r.URL.Query().Get("rating"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "rating"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rating", r.URL.Query(), &params.Rating)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rating", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRating(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostSetRating operation middleware
func (siw *ServerInterfaceWrapper) PostSetRating(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSetRating(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Star operation middleware
func (siw *ServerInterfaceWrapper) Star(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params StarParams

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "albumId" -------------

	err = runtime.BindQueryParameter("form", true, false, "albumId", r.URL.Query(), &params.AlbumId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "albumId", Err: err})
		return
	}

	// ------------- Optional query parameter "artistId" -------------

	err = runtime.BindQueryParameter("form", true, false, "artistId", r.URL.Query(), &params.ArtistId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "artistId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Star(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostStar operation middleware
func (siw *ServerInterfaceWrapper) PostStar(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStar(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StartScan operation middleware
func (siw *ServerInterfaceWrapper) StartScan(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StartScan(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostStartScan operation middleware
func (siw *ServerInterfaceWrapper) PostStartScan(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStartScan(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Stream operation middleware
func (siw *ServerInterfaceWrapper) Stream(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params StreamParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "maxBitRate" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxBitRate", r.URL.Query(), &params.MaxBitRate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "maxBitRate", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "timeOffset" -------------

	err = runtime.BindQueryParameter("form", true, false, "timeOffset", r.URL.Query(), &params.TimeOffset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "timeOffset", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "estimateContentLength" -------------

	err = runtime.BindQueryParameter("form", true, false, "estimateContentLength", r.URL.Query(), &params.EstimateContentLength)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "estimateContentLength", Err: err})
		return
	}

	// ------------- Optional query parameter "converted" -------------

	err = runtime.BindQueryParameter("form", true, false, "converted", r.URL.Query(), &params.Converted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "converted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Stream(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostStream operation middleware
func (siw *ServerInterfaceWrapper) PostStream(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStream(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenInfo operation middleware
func (siw *ServerInterfaceWrapper) TokenInfo(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostTokenInfo operation middleware
func (siw *ServerInterfaceWrapper) PostTokenInfo(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostTokenInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Unstar operation middleware
func (siw *ServerInterfaceWrapper) Unstar(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UnstarParams

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "albumId" -------------

	err = runtime.BindQueryParameter("form", true, false, "albumId", r.URL.Query(), &params.AlbumId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "albumId", Err: err})
		return
	}

	// ------------- Optional query parameter "artistId" -------------

	err = runtime.BindQueryParameter("form", true, false, "artistId", r.URL.Query(), &params.ArtistId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "artistId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Unstar(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostUnstar operation middleware
func (siw *ServerInterfaceWrapper) PostUnstar(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUnstar(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateInternetRadioStation operation middleware
func (siw *ServerInterfaceWrapper) UpdateInternetRadioStation(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateInternetRadioStationParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Required query parameter "streamUrl" -------------

	if paramValue := r.URL.Query().Get("streamUrl"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "streamUrl"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "streamUrl", r.URL.Query(), &params.StreamUrl)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "streamUrl", Err: err})
		return
	}

	// ------------- Required query parameter "name" -------------

	if paramValue := r.URL.Query().Get("name"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "name"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "homepageUrl" -------------

	err = runtime.BindQueryParameter("form", true, false, "homepageUrl", r.URL.Query(), &params.HomepageUrl)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "homepageUrl", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateInternetRadioStation(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostUpdateInternetRadioStation operation middleware
func (siw *ServerInterfaceWrapper) PostUpdateInternetRadioStation(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUpdateInternetRadioStation(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdatePlaylist operation middleware
func (siw *ServerInterfaceWrapper) UpdatePlaylist(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdatePlaylistParams

	// ------------- Required query parameter "playlistId" -------------

	if paramValue := r.URL.Query().Get("playlistId"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "playlistId"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "playlistId", r.URL.Query(), &params.PlaylistId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "playlistId", Err: err})
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "comment" -------------

	err = runtime.BindQueryParameter("form", true, false, "comment", r.URL.Query(), &params.Comment)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "comment", Err: err})
		return
	}

	// ------------- Optional query parameter "public" -------------

	err = runtime.BindQueryParameter("form", true, false, "public", r.URL.Query(), &params.Public)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "public", Err: err})
		return
	}

	// ------------- Optional query parameter "songIdToAdd" -------------

	err = runtime.BindQueryParameter("form", true, false, "songIdToAdd", r.URL.Query(), &params.SongIdToAdd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "songIdToAdd", Err: err})
		return
	}

	// ------------- Optional query parameter "songIndexToRemove" -------------

	err = runtime.BindQueryParameter("form", true, false, "songIndexToRemove", r.URL.Query(), &params.SongIndexToRemove)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "songIndexToRemove", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePlaylist(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostUpdatePlaylist operation middleware
func (siw *ServerInterfaceWrapper) PostUpdatePlaylist(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUpdatePlaylist(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateShare operation middleware
func (siw *ServerInterfaceWrapper) UpdateShare(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateShareParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", r.URL.Query(), &params.Description)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "description", Err: err})
		return
	}

	// ------------- Optional query parameter "expires" -------------

	err = runtime.BindQueryParameter("form", true, false, "expires", r.URL.Query(), &params.Expires)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "expires", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateShare(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostUpdateShare operation middleware
func (siw *ServerInterfaceWrapper) PostUpdateShare(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUpdateShare(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateUserParams

	// ------------- Required query parameter "username" -------------

	if paramValue := r.URL.Query().Get("username"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "username"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", r.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	// ------------- Required query parameter "password" -------------

	if paramValue := r.URL.Query().Get("password"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "password"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "password", r.URL.Query(), &params.Password)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "password", Err: err})
		return
	}

	// ------------- Optional query parameter "email" -------------

	err = runtime.BindQueryParameter("form", true, false, "email", r.URL.Query(), &params.Email)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "email", Err: err})
		return
	}

	// ------------- Optional query parameter "ldapAuthenticated" -------------

	err = runtime.BindQueryParameter("form", true, false, "ldapAuthenticated", r.URL.Query(), &params.LdapAuthenticated)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ldapAuthenticated", Err: err})
		return
	}

	// ------------- Optional query parameter "adminRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "adminRole", r.URL.Query(), &params.AdminRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "adminRole", Err: err})
		return
	}

	// ------------- Optional query parameter "settingsRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "settingsRole", r.URL.Query(), &params.SettingsRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "settingsRole", Err: err})
		return
	}

	// ------------- Optional query parameter "streamRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "streamRole", r.URL.Query(), &params.StreamRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "streamRole", Err: err})
		return
	}

	// ------------- Optional query parameter "jukeboxRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "jukeboxRole", r.URL.Query(), &params.JukeboxRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jukeboxRole", Err: err})
		return
	}

	// ------------- Optional query parameter "downloadRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "downloadRole", r.URL.Query(), &params.DownloadRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "downloadRole", Err: err})
		return
	}

	// ------------- Optional query parameter "uploadRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "uploadRole", r.URL.Query(), &params.UploadRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uploadRole", Err: err})
		return
	}

	// ------------- Optional query parameter "coverArtRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "coverArtRole", r.URL.Query(), &params.CoverArtRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "coverArtRole", Err: err})
		return
	}

	// ------------- Optional query parameter "commentRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "commentRole", r.URL.Query(), &params.CommentRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "commentRole", Err: err})
		return
	}

	// ------------- Optional query parameter "podcastRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "podcastRole", r.URL.Query(), &params.PodcastRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "podcastRole", Err: err})
		return
	}

	// ------------- Optional query parameter "shareRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "shareRole", r.URL.Query(), &params.ShareRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "shareRole", Err: err})
		return
	}

	// ------------- Optional query parameter "videoConversionRole" -------------

	err = runtime.BindQueryParameter("form", true, false, "videoConversionRole", r.URL.Query(), &params.VideoConversionRole)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "videoConversionRole", Err: err})
		return
	}

	// ------------- Optional query parameter "musicFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "musicFolderId", r.URL.Query(), &params.MusicFolderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "musicFolderId", Err: err})
		return
	}

	// ------------- Optional query parameter "maxBitRate" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxBitRate", r.URL.Query(), &params.MaxBitRate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "maxBitRate", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostUpdateUser operation middleware
func (siw *ServerInterfaceWrapper) PostUpdateUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, ApiKeyAuthScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, LegacyPasswordScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	ctx = context.WithValue(ctx, ClientNameScopes, []string{})

	ctx = context.WithValue(ctx, FormatScopes, []string{})

	ctx = context.WithValue(ctx, ProtocolVersionScopes, []string{})

	ctx = context.WithValue(ctx, SaltScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UsernameScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostUpdateUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/rest/addChatMessage", wrapper.GetAddChatMessage)
	m.HandleFunc("POST "+options.BaseURL+"/rest/addChatMessage", wrapper.PostAddChatMessage)
	m.HandleFunc("GET "+options.BaseURL+"/rest/changePassword", wrapper.ChangePassword)
	m.HandleFunc("POST "+options.BaseURL+"/rest/changePassword", wrapper.PostChangePassword)
	m.HandleFunc("GET "+options.BaseURL+"/rest/createBookmark", wrapper.CreateBookmark)
	m.HandleFunc("POST "+options.BaseURL+"/rest/createBookmark", wrapper.PostCreateBookmark)
	m.HandleFunc("GET "+options.BaseURL+"/rest/createInternetRadioStation", wrapper.CreateInternetRadioStation)
	m.HandleFunc("POST "+options.BaseURL+"/rest/createInternetRadioStation", wrapper.PostCreateInternetRadioStation)
	m.HandleFunc("GET "+options.BaseURL+"/rest/createPlaylist", wrapper.CreatePlaylist)
	m.HandleFunc("POST "+options.BaseURL+"/rest/createPlaylist", wrapper.PostCreatePlaylist)
	m.HandleFunc("GET "+options.BaseURL+"/rest/createPodcastChannel", wrapper.CreatePodcastChannel)
	m.HandleFunc("POST "+options.BaseURL+"/rest/createPodcastChannel", wrapper.PostCreatePodcastChannel)
	m.HandleFunc("GET "+options.BaseURL+"/rest/createShare", wrapper.CreateShare)
	m.HandleFunc("POST "+options.BaseURL+"/rest/createShare", wrapper.PostCreateShare)
	m.HandleFunc("GET "+options.BaseURL+"/rest/createUser", wrapper.CreateUser)
	m.HandleFunc("POST "+options.BaseURL+"/rest/createUser", wrapper.PostCreateUser)
	m.HandleFunc("GET "+options.BaseURL+"/rest/deleteBookmark", wrapper.DeleteBookmark)
	m.HandleFunc("POST "+options.BaseURL+"/rest/deleteBookmark", wrapper.PostDeleteBookmark)
	m.HandleFunc("GET "+options.BaseURL+"/rest/deleteInternetRadioStation", wrapper.DeleteInternetRadioStation)
	m.HandleFunc("POST "+options.BaseURL+"/rest/deleteInternetRadioStation", wrapper.PostDeleteInternetRadioStation)
	m.HandleFunc("GET "+options.BaseURL+"/rest/deletePlaylist", wrapper.DeletePlaylist)
	m.HandleFunc("POST "+options.BaseURL+"/rest/deletePlaylist", wrapper.PostDeletePlaylist)
	m.HandleFunc("GET "+options.BaseURL+"/rest/deletePodcastChannel", wrapper.DeletePodcastChannel)
	m.HandleFunc("POST "+options.BaseURL+"/rest/deletePodcastChannel", wrapper.PostDeletePodcastChannel)
	m.HandleFunc("GET "+options.BaseURL+"/rest/deletePodcastEpisode", wrapper.DeletePodcastEpisode)
	m.HandleFunc("POST "+options.BaseURL+"/rest/deletePodcastEpisode", wrapper.PostDeletePodcastEpisode)
	m.HandleFunc("GET "+options.BaseURL+"/rest/deleteShare", wrapper.DeleteShare)
	m.HandleFunc("POST "+options.BaseURL+"/rest/deleteShare", wrapper.PostDeleteShare)
	m.HandleFunc("GET "+options.BaseURL+"/rest/deleteUser", wrapper.DeleteUser)
	m.HandleFunc("POST "+options.BaseURL+"/rest/deleteUser", wrapper.PostDeleteUser)
	m.HandleFunc("GET "+options.BaseURL+"/rest/download", wrapper.Download)
	m.HandleFunc("POST "+options.BaseURL+"/rest/download", wrapper.PostDownload)
	m.HandleFunc("GET "+options.BaseURL+"/rest/downloadPodcastEpisode", wrapper.DownloadPodcastEpisode)
	m.HandleFunc("POST "+options.BaseURL+"/rest/downloadPodcastEpisode", wrapper.PostDownloadPodcastEpisode)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getAlbum", wrapper.GetAlbum)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getAlbum", wrapper.PostGetAlbum)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getAlbumInfo", wrapper.GetAlbumInfo)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getAlbumInfo", wrapper.PostGetAlbumInfo)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getAlbumInfo2", wrapper.GetAlbumInfo2)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getAlbumInfo2", wrapper.PostGetAlbumInfo2)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getAlbumList", wrapper.GetAlbumList)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getAlbumList", wrapper.PostGetAlbumList)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getAlbumList2", wrapper.GetAlbumList2)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getAlbumList2", wrapper.PostGetAlbumList2)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getArtist", wrapper.GetArtist)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getArtist", wrapper.PostGetArtist)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getArtistInfo", wrapper.GetArtistInfo)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getArtistInfo", wrapper.PostGetArtistInfo)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getArtistInfo2", wrapper.GetArtistInfo2)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getArtistInfo2", wrapper.PostGetArtistInfo2)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getArtists", wrapper.GetArtists)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getArtists", wrapper.PostGetArtists)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getAvatar", wrapper.GetAvatar)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getAvatar", wrapper.PostGetAvatar)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getBookmarks", wrapper.GetBookmarks)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getBookmarks", wrapper.PostGetBookmarks)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getCaptions", wrapper.GetCaptions)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getCaptions", wrapper.PostGetCaptions)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getChatMessages", wrapper.GetChatMessages)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getChatMessages", wrapper.PostGetChatMessages)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getCoverArt", wrapper.GetCoverArt)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getCoverArt", wrapper.PostGetCoverArt)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getGenres", wrapper.GetGenres)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getGenres", wrapper.PostGetGenres)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getIndexes", wrapper.GetIndexes)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getIndexes", wrapper.PostGetIndexes)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getInternetRadioStations", wrapper.GetInternetRadioStations)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getInternetRadioStations", wrapper.PostGetInternetRadioStations)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getLicense", wrapper.GetLicense)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getLicense", wrapper.PostGetLicense)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getLyrics", wrapper.GetLyrics)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getLyrics", wrapper.PostGetLyrics)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getLyricsBySongId", wrapper.GetLyricsBySongId)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getLyricsBySongId", wrapper.PostGetLyricsBySongId)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getMusicDirectory", wrapper.GetMusicDirectory)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getMusicDirectory", wrapper.PostGetMusicDirectory)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getMusicFolders", wrapper.GetMusicFolders)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getMusicFolders", wrapper.PostGetMusicFolders)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getNewestPodcasts", wrapper.GetNewestPodcasts)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getNewestPodcasts", wrapper.PostGetNewestPodcasts)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getNowPlaying", wrapper.GetNowPlaying)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getNowPlaying", wrapper.PostGetNowPlaying)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getOpenSubsonicExtensions", wrapper.GetOpenSubsonicExtensions)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getOpenSubsonicExtensions", wrapper.PostGetOpenSubsonicExtensions)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getPlayQueue", wrapper.GetPlayQueue)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getPlayQueue", wrapper.PostGetPlayQueue)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getPlayQueueByIndex", wrapper.GetPlayQueueByIndex)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getPlayQueueByIndex", wrapper.PostGetPlayQueueByIndex)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getPlaylist", wrapper.GetPlaylist)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getPlaylist", wrapper.PostGetPlaylist)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getPlaylists", wrapper.GetPlaylists)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getPlaylists", wrapper.PostGetPlaylists)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getPodcastEpisode", wrapper.GetPodcastEpisode)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getPodcastEpisode", wrapper.PostGetPodcastEpisode)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getPodcasts", wrapper.GetPodcasts)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getPodcasts", wrapper.PostGetPodcasts)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getRandomSongs", wrapper.GetRandomSongs)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getRandomSongs", wrapper.PostGetRandomSongs)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getScanStatus", wrapper.GetScanStatus)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getScanStatus", wrapper.PostGetScanStatus)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getShares", wrapper.GetShares)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getShares", wrapper.PostGetShares)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getSimilarSongs", wrapper.GetSimilarSongs)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getSimilarSongs", wrapper.PostGetSimilarSongs)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getSimilarSongs2", wrapper.GetSimilarSongs2)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getSimilarSongs2", wrapper.PostGetSimilarSongs2)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getSong", wrapper.GetSong)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getSong", wrapper.PostGetSong)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getSongsByGenre", wrapper.GetSongsByGenre)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getSongsByGenre", wrapper.PostGetSongsByGenre)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getStarred", wrapper.GetStarred)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getStarred", wrapper.PostGetStarred)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getStarred2", wrapper.GetStarred2)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getStarred2", wrapper.PostGetStarred2)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getTopSongs", wrapper.GetTopSongs)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getTopSongs", wrapper.PostGetTopSongs)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getTranscodeDecision", wrapper.GetTranscodeDecision)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getTranscodeStream", wrapper.GetTranscodeStream)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getUser", wrapper.GetUser)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getUser", wrapper.PostGetUser)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getUsers", wrapper.GetUsers)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getUsers", wrapper.PostGetUsers)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getVideoInfo", wrapper.GetVideoInfo)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getVideoInfo", wrapper.PostGetVideoInfo)
	m.HandleFunc("GET "+options.BaseURL+"/rest/getVideos", wrapper.GetVideos)
	m.HandleFunc("POST "+options.BaseURL+"/rest/getVideos", wrapper.PostGetVideos)
	m.HandleFunc("GET "+options.BaseURL+"/rest/hls.m3u8", wrapper.HlsM3u8)
	m.HandleFunc("POST "+options.BaseURL+"/rest/hls.m3u8", wrapper.PostHlsM3u8)
	m.HandleFunc("GET "+options.BaseURL+"/rest/jukeboxControl", wrapper.JukeboxControl)
	m.HandleFunc("POST "+options.BaseURL+"/rest/jukeboxControl", wrapper.PostJukeboxControl)
	m.HandleFunc("GET "+options.BaseURL+"/rest/ping", wrapper.Ping)
	m.HandleFunc("POST "+options.BaseURL+"/rest/ping", wrapper.PostPing)
	m.HandleFunc("GET "+options.BaseURL+"/rest/refreshPodcasts", wrapper.RefreshPodcasts)
	m.HandleFunc("POST "+options.BaseURL+"/rest/refreshPodcasts", wrapper.PostRefreshPodcasts)
	m.HandleFunc("GET "+options.BaseURL+"/rest/savePlayQueue", wrapper.SavePlayQueue)
	m.HandleFunc("POST "+options.BaseURL+"/rest/savePlayQueue", wrapper.PostSavePlayQueue)
	m.HandleFunc("GET "+options.BaseURL+"/rest/savePlayQueueByIndex", wrapper.SavePlayQueueByIndex)
	m.HandleFunc("POST "+options.BaseURL+"/rest/savePlayQueueByIndex", wrapper.PostSavePlayQueueByIndex)
	m.HandleFunc("GET "+options.BaseURL+"/rest/scrobble", wrapper.Scrobble)
	m.HandleFunc("POST "+options.BaseURL+"/rest/scrobble", wrapper.PostScrobble)
	m.HandleFunc("GET "+options.BaseURL+"/rest/search", wrapper.Search)
	m.HandleFunc("POST "+options.BaseURL+"/rest/search", wrapper.PostSearch)
	m.HandleFunc("GET "+options.BaseURL+"/rest/search2", wrapper.Search2)
	m.HandleFunc("POST "+options.BaseURL+"/rest/search2", wrapper.PostSearch2)
	m.HandleFunc("GET "+options.BaseURL+"/rest/search3", wrapper.Search3)
	m.HandleFunc("POST "+options.BaseURL+"/rest/search3", wrapper.PostSearch3)
	m.HandleFunc("GET "+options.BaseURL+"/rest/setRating", wrapper.SetRating)
	m.HandleFunc("POST "+options.BaseURL+"/rest/setRating", wrapper.PostSetRating)
	m.HandleFunc("GET "+options.BaseURL+"/rest/star", wrapper.Star)
	m.HandleFunc("POST "+options.BaseURL+"/rest/star", wrapper.PostStar)
	m.HandleFunc("GET "+options.BaseURL+"/rest/startScan", wrapper.StartScan)
	m.HandleFunc("POST "+options.BaseURL+"/rest/startScan", wrapper.PostStartScan)
	m.HandleFunc("GET "+options.BaseURL+"/rest/stream", wrapper.Stream)
	m.HandleFunc("POST "+options.BaseURL+"/rest/stream", wrapper.PostStream)
	m.HandleFunc("GET "+options.BaseURL+"/rest/tokenInfo", wrapper.TokenInfo)
	m.HandleFunc("POST "+options.BaseURL+"/rest/tokenInfo", wrapper.PostTokenInfo)
	m.HandleFunc("GET "+options.BaseURL+"/rest/unstar", wrapper.Unstar)
	m.HandleFunc("POST "+options.BaseURL+"/rest/unstar", wrapper.PostUnstar)
	m.HandleFunc("GET "+options.BaseURL+"/rest/updateInternetRadioStation", wrapper.UpdateInternetRadioStation)
	m.HandleFunc("POST "+options.BaseURL+"/rest/updateInternetRadioStation", wrapper.PostUpdateInternetRadioStation)
	m.HandleFunc("GET "+options.BaseURL+"/rest/updatePlaylist", wrapper.UpdatePlaylist)
	m.HandleFunc("POST "+options.BaseURL+"/rest/updatePlaylist", wrapper.PostUpdatePlaylist)
	m.HandleFunc("GET "+options.BaseURL+"/rest/updateShare", wrapper.UpdateShare)
	m.HandleFunc("POST "+options.BaseURL+"/rest/updateShare", wrapper.PostUpdateShare)
	m.HandleFunc("GET "+options.BaseURL+"/rest/updateUser", wrapper.UpdateUser)
	m.HandleFunc("POST "+options.BaseURL+"/rest/updateUser", wrapper.PostUpdateUser)

	return m
}

type BinaryResponseApplicationbinaryResponse struct {
	Body io.Reader

	ContentLength int64
}
type BinaryResponseTextxmlResponse struct {
	Body io.Reader

	ContentLength int64
}

type EmptySubsonicResponseJSONResponse SubsonicResponse

type HTTPFormPostNotSupportedResponse struct {
}

type TranscodeDecisionResponseJSONResponse struct {
	TranscodeDecision *TranscodeDecision `json:"transcodeDecision,omitempty"`
}
type TranscodeDecisionResponseApplicationxmlResponse struct {
	Body io.Reader

	ContentLength int64
}

type GetAddChatMessageRequestObject struct {
	Params GetAddChatMessageParams
}

type GetAddChatMessageResponseObject interface {
	VisitGetAddChatMessageResponse(w http.ResponseWriter) error
}

type GetAddChatMessage200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response GetAddChatMessage200JSONResponse) VisitGetAddChatMessageResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostAddChatMessageRequestObject struct {
	Body *PostAddChatMessageFormdataRequestBody
}

type PostAddChatMessageResponseObject interface {
	VisitPostAddChatMessageResponse(w http.ResponseWriter) error
}

type PostAddChatMessage200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostAddChatMessage200JSONResponse) VisitPostAddChatMessageResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostAddChatMessage405Response = HTTPFormPostNotSupportedResponse

func (response PostAddChatMessage405Response) VisitPostAddChatMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type ChangePasswordRequestObject struct {
	Params ChangePasswordParams
}

type ChangePasswordResponseObject interface {
	VisitChangePasswordResponse(w http.ResponseWriter) error
}

type ChangePassword200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response ChangePassword200JSONResponse) VisitChangePasswordResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostChangePasswordRequestObject struct {
	Body *PostChangePasswordFormdataRequestBody
}

type PostChangePasswordResponseObject interface {
	VisitPostChangePasswordResponse(w http.ResponseWriter) error
}

type PostChangePassword200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostChangePassword200JSONResponse) VisitPostChangePasswordResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostChangePassword405Response = HTTPFormPostNotSupportedResponse

func (response PostChangePassword405Response) VisitPostChangePasswordResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type CreateBookmarkRequestObject struct {
	Params CreateBookmarkParams
}

type CreateBookmarkResponseObject interface {
	VisitCreateBookmarkResponse(w http.ResponseWriter) error
}

type CreateBookmark200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response CreateBookmark200JSONResponse) VisitCreateBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreateBookmarkRequestObject struct {
	Body *PostCreateBookmarkFormdataRequestBody
}

type PostCreateBookmarkResponseObject interface {
	VisitPostCreateBookmarkResponse(w http.ResponseWriter) error
}

type PostCreateBookmark200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostCreateBookmark200JSONResponse) VisitPostCreateBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreateBookmark405Response = HTTPFormPostNotSupportedResponse

func (response PostCreateBookmark405Response) VisitPostCreateBookmarkResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type CreateInternetRadioStationRequestObject struct {
	Params CreateInternetRadioStationParams
}

type CreateInternetRadioStationResponseObject interface {
	VisitCreateInternetRadioStationResponse(w http.ResponseWriter) error
}

type CreateInternetRadioStation200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response CreateInternetRadioStation200JSONResponse) VisitCreateInternetRadioStationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreateInternetRadioStationRequestObject struct {
	Body *PostCreateInternetRadioStationFormdataRequestBody
}

type PostCreateInternetRadioStationResponseObject interface {
	VisitPostCreateInternetRadioStationResponse(w http.ResponseWriter) error
}

type PostCreateInternetRadioStation200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostCreateInternetRadioStation200JSONResponse) VisitPostCreateInternetRadioStationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreateInternetRadioStation405Response = HTTPFormPostNotSupportedResponse

func (response PostCreateInternetRadioStation405Response) VisitPostCreateInternetRadioStationResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type CreatePlaylistRequestObject struct {
	Params CreatePlaylistParams
}

type CreatePlaylistResponseObject interface {
	VisitCreatePlaylistResponse(w http.ResponseWriter) error
}

type CreatePlaylist200JSONResponse CreatePlaylistResponse

func (response CreatePlaylist200JSONResponse) VisitCreatePlaylistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreatePlaylistRequestObject struct {
	Body *PostCreatePlaylistFormdataRequestBody
}

type PostCreatePlaylistResponseObject interface {
	VisitPostCreatePlaylistResponse(w http.ResponseWriter) error
}

type PostCreatePlaylist200JSONResponse CreatePlaylistResponse

func (response PostCreatePlaylist200JSONResponse) VisitPostCreatePlaylistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreatePlaylist405Response = HTTPFormPostNotSupportedResponse

func (response PostCreatePlaylist405Response) VisitPostCreatePlaylistResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type CreatePodcastChannelRequestObject struct {
	Params CreatePodcastChannelParams
}

type CreatePodcastChannelResponseObject interface {
	VisitCreatePodcastChannelResponse(w http.ResponseWriter) error
}

type CreatePodcastChannel200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response CreatePodcastChannel200JSONResponse) VisitCreatePodcastChannelResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreatePodcastChannelRequestObject struct {
	Body *PostCreatePodcastChannelFormdataRequestBody
}

type PostCreatePodcastChannelResponseObject interface {
	VisitPostCreatePodcastChannelResponse(w http.ResponseWriter) error
}

type PostCreatePodcastChannel200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostCreatePodcastChannel200JSONResponse) VisitPostCreatePodcastChannelResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreatePodcastChannel405Response = HTTPFormPostNotSupportedResponse

func (response PostCreatePodcastChannel405Response) VisitPostCreatePodcastChannelResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type CreateShareRequestObject struct {
	Params CreateShareParams
}

type CreateShareResponseObject interface {
	VisitCreateShareResponse(w http.ResponseWriter) error
}

type CreateShare200JSONResponse CreateSharesResponse

func (response CreateShare200JSONResponse) VisitCreateShareResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreateShareRequestObject struct {
	Body *PostCreateShareFormdataRequestBody
}

type PostCreateShareResponseObject interface {
	VisitPostCreateShareResponse(w http.ResponseWriter) error
}

type PostCreateShare200JSONResponse CreateSharesResponse

func (response PostCreateShare200JSONResponse) VisitPostCreateShareResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreateShare405Response = HTTPFormPostNotSupportedResponse

func (response PostCreateShare405Response) VisitPostCreateShareResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type CreateUserRequestObject struct {
	Params CreateUserParams
}

type CreateUserResponseObject interface {
	VisitCreateUserResponse(w http.ResponseWriter) error
}

type CreateUser200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response CreateUser200JSONResponse) VisitCreateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreateUserRequestObject struct {
	Body *PostCreateUserFormdataRequestBody
}

type PostCreateUserResponseObject interface {
	VisitPostCreateUserResponse(w http.ResponseWriter) error
}

type PostCreateUser200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostCreateUser200JSONResponse) VisitPostCreateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostCreateUser405Response = HTTPFormPostNotSupportedResponse

func (response PostCreateUser405Response) VisitPostCreateUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type DeleteBookmarkRequestObject struct {
	Params DeleteBookmarkParams
}

type DeleteBookmarkResponseObject interface {
	VisitDeleteBookmarkResponse(w http.ResponseWriter) error
}

type DeleteBookmark200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response DeleteBookmark200JSONResponse) VisitDeleteBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeleteBookmarkRequestObject struct {
	Body *PostDeleteBookmarkFormdataRequestBody
}

type PostDeleteBookmarkResponseObject interface {
	VisitPostDeleteBookmarkResponse(w http.ResponseWriter) error
}

type PostDeleteBookmark200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostDeleteBookmark200JSONResponse) VisitPostDeleteBookmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeleteBookmark405Response = HTTPFormPostNotSupportedResponse

func (response PostDeleteBookmark405Response) VisitPostDeleteBookmarkResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type DeleteInternetRadioStationRequestObject struct {
	Params DeleteInternetRadioStationParams
}

type DeleteInternetRadioStationResponseObject interface {
	VisitDeleteInternetRadioStationResponse(w http.ResponseWriter) error
}

type DeleteInternetRadioStation200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response DeleteInternetRadioStation200JSONResponse) VisitDeleteInternetRadioStationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeleteInternetRadioStationRequestObject struct {
	Body *PostDeleteInternetRadioStationFormdataRequestBody
}

type PostDeleteInternetRadioStationResponseObject interface {
	VisitPostDeleteInternetRadioStationResponse(w http.ResponseWriter) error
}

type PostDeleteInternetRadioStation200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostDeleteInternetRadioStation200JSONResponse) VisitPostDeleteInternetRadioStationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeleteInternetRadioStation405Response = HTTPFormPostNotSupportedResponse

func (response PostDeleteInternetRadioStation405Response) VisitPostDeleteInternetRadioStationResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type DeletePlaylistRequestObject struct {
	Params DeletePlaylistParams
}

type DeletePlaylistResponseObject interface {
	VisitDeletePlaylistResponse(w http.ResponseWriter) error
}

type DeletePlaylist200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response DeletePlaylist200JSONResponse) VisitDeletePlaylistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeletePlaylistRequestObject struct {
	Body *PostDeletePlaylistFormdataRequestBody
}

type PostDeletePlaylistResponseObject interface {
	VisitPostDeletePlaylistResponse(w http.ResponseWriter) error
}

type PostDeletePlaylist200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostDeletePlaylist200JSONResponse) VisitPostDeletePlaylistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeletePlaylist405Response = HTTPFormPostNotSupportedResponse

func (response PostDeletePlaylist405Response) VisitPostDeletePlaylistResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type DeletePodcastChannelRequestObject struct {
	Params DeletePodcastChannelParams
}

type DeletePodcastChannelResponseObject interface {
	VisitDeletePodcastChannelResponse(w http.ResponseWriter) error
}

type DeletePodcastChannel200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response DeletePodcastChannel200JSONResponse) VisitDeletePodcastChannelResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeletePodcastChannelRequestObject struct {
	Body *PostDeletePodcastChannelFormdataRequestBody
}

type PostDeletePodcastChannelResponseObject interface {
	VisitPostDeletePodcastChannelResponse(w http.ResponseWriter) error
}

type PostDeletePodcastChannel200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostDeletePodcastChannel200JSONResponse) VisitPostDeletePodcastChannelResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeletePodcastChannel405Response = HTTPFormPostNotSupportedResponse

func (response PostDeletePodcastChannel405Response) VisitPostDeletePodcastChannelResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type DeletePodcastEpisodeRequestObject struct {
	Params DeletePodcastEpisodeParams
}

type DeletePodcastEpisodeResponseObject interface {
	VisitDeletePodcastEpisodeResponse(w http.ResponseWriter) error
}

type DeletePodcastEpisode200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response DeletePodcastEpisode200JSONResponse) VisitDeletePodcastEpisodeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeletePodcastEpisodeRequestObject struct {
	Body *PostDeletePodcastEpisodeFormdataRequestBody
}

type PostDeletePodcastEpisodeResponseObject interface {
	VisitPostDeletePodcastEpisodeResponse(w http.ResponseWriter) error
}

type PostDeletePodcastEpisode200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostDeletePodcastEpisode200JSONResponse) VisitPostDeletePodcastEpisodeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeletePodcastEpisode405Response = HTTPFormPostNotSupportedResponse

func (response PostDeletePodcastEpisode405Response) VisitPostDeletePodcastEpisodeResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type DeleteShareRequestObject struct {
	Params DeleteShareParams
}

type DeleteShareResponseObject interface {
	VisitDeleteShareResponse(w http.ResponseWriter) error
}

type DeleteShare200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response DeleteShare200JSONResponse) VisitDeleteShareResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeleteShareRequestObject struct {
	Body *PostDeleteShareFormdataRequestBody
}

type PostDeleteShareResponseObject interface {
	VisitPostDeleteShareResponse(w http.ResponseWriter) error
}

type PostDeleteShare200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostDeleteShare200JSONResponse) VisitPostDeleteShareResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeleteShare405Response = HTTPFormPostNotSupportedResponse

func (response PostDeleteShare405Response) VisitPostDeleteShareResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type DeleteUserRequestObject struct {
	Params DeleteUserParams
}

type DeleteUserResponseObject interface {
	VisitDeleteUserResponse(w http.ResponseWriter) error
}

type DeleteUser200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response DeleteUser200JSONResponse) VisitDeleteUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeleteUserRequestObject struct {
	Body *PostDeleteUserFormdataRequestBody
}

type PostDeleteUserResponseObject interface {
	VisitPostDeleteUserResponse(w http.ResponseWriter) error
}

type PostDeleteUser200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostDeleteUser200JSONResponse) VisitPostDeleteUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDeleteUser405Response = HTTPFormPostNotSupportedResponse

func (response PostDeleteUser405Response) VisitPostDeleteUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type DownloadRequestObject struct {
	Params DownloadParams
}

type DownloadResponseObject interface {
	VisitDownloadResponse(w http.ResponseWriter) error
}

type Download200ApplicationbinaryResponse struct {
	BinaryResponseApplicationbinaryResponse
}

func (response Download200ApplicationbinaryResponse) VisitDownloadResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/binary")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type Download200TextxmlResponse struct{ BinaryResponseTextxmlResponse }

func (response Download200TextxmlResponse) VisitDownloadResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostDownloadRequestObject struct {
	Body *PostDownloadFormdataRequestBody
}

type PostDownloadResponseObject interface {
	VisitPostDownloadResponse(w http.ResponseWriter) error
}

type PostDownload200ApplicationbinaryResponse struct {
	BinaryResponseApplicationbinaryResponse
}

func (response PostDownload200ApplicationbinaryResponse) VisitPostDownloadResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/binary")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostDownload200TextxmlResponse struct{ BinaryResponseTextxmlResponse }

func (response PostDownload200TextxmlResponse) VisitPostDownloadResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostDownload405Response = HTTPFormPostNotSupportedResponse

func (response PostDownload405Response) VisitPostDownloadResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type DownloadPodcastEpisodeRequestObject struct {
	Params DownloadPodcastEpisodeParams
}

type DownloadPodcastEpisodeResponseObject interface {
	VisitDownloadPodcastEpisodeResponse(w http.ResponseWriter) error
}

type DownloadPodcastEpisode200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response DownloadPodcastEpisode200JSONResponse) VisitDownloadPodcastEpisodeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDownloadPodcastEpisodeRequestObject struct {
	Body *PostDownloadPodcastEpisodeFormdataRequestBody
}

type PostDownloadPodcastEpisodeResponseObject interface {
	VisitPostDownloadPodcastEpisodeResponse(w http.ResponseWriter) error
}

type PostDownloadPodcastEpisode200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostDownloadPodcastEpisode200JSONResponse) VisitPostDownloadPodcastEpisodeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostDownloadPodcastEpisode405Response = HTTPFormPostNotSupportedResponse

func (response PostDownloadPodcastEpisode405Response) VisitPostDownloadPodcastEpisodeResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetAlbumRequestObject struct {
	Params GetAlbumParams
}

type GetAlbumResponseObject interface {
	VisitGetAlbumResponse(w http.ResponseWriter) error
}

type GetAlbum200JSONResponse GetAlbumResponse

func (response GetAlbum200JSONResponse) VisitGetAlbumResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetAlbumRequestObject struct {
	Body *PostGetAlbumFormdataRequestBody
}

type PostGetAlbumResponseObject interface {
	VisitPostGetAlbumResponse(w http.ResponseWriter) error
}

type PostGetAlbum200JSONResponse GetAlbumResponse

func (response PostGetAlbum200JSONResponse) VisitPostGetAlbumResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetAlbum405Response = HTTPFormPostNotSupportedResponse

func (response PostGetAlbum405Response) VisitPostGetAlbumResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetAlbumInfoRequestObject struct {
	Params GetAlbumInfoParams
}

type GetAlbumInfoResponseObject interface {
	VisitGetAlbumInfoResponse(w http.ResponseWriter) error
}

type GetAlbumInfo200JSONResponse GetAlbumInfoResponse

func (response GetAlbumInfo200JSONResponse) VisitGetAlbumInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetAlbumInfoRequestObject struct {
	Body *PostGetAlbumInfoFormdataRequestBody
}

type PostGetAlbumInfoResponseObject interface {
	VisitPostGetAlbumInfoResponse(w http.ResponseWriter) error
}

type PostGetAlbumInfo200JSONResponse GetAlbumInfoResponse

func (response PostGetAlbumInfo200JSONResponse) VisitPostGetAlbumInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetAlbumInfo405Response = HTTPFormPostNotSupportedResponse

func (response PostGetAlbumInfo405Response) VisitPostGetAlbumInfoResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetAlbumInfo2RequestObject struct {
	Params GetAlbumInfo2Params
}

type GetAlbumInfo2ResponseObject interface {
	VisitGetAlbumInfo2Response(w http.ResponseWriter) error
}

type GetAlbumInfo2200JSONResponse GetAlbumInfoResponse

func (response GetAlbumInfo2200JSONResponse) VisitGetAlbumInfo2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetAlbumInfo2RequestObject struct {
	Body *PostGetAlbumInfo2FormdataRequestBody
}

type PostGetAlbumInfo2ResponseObject interface {
	VisitPostGetAlbumInfo2Response(w http.ResponseWriter) error
}

type PostGetAlbumInfo2200JSONResponse GetAlbumInfoResponse

func (response PostGetAlbumInfo2200JSONResponse) VisitPostGetAlbumInfo2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetAlbumInfo2405Response = HTTPFormPostNotSupportedResponse

func (response PostGetAlbumInfo2405Response) VisitPostGetAlbumInfo2Response(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetAlbumListRequestObject struct {
	Params GetAlbumListParams
}

type GetAlbumListResponseObject interface {
	VisitGetAlbumListResponse(w http.ResponseWriter) error
}

type GetAlbumList200JSONResponse GetAlbumListResponse

func (response GetAlbumList200JSONResponse) VisitGetAlbumListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetAlbumListRequestObject struct {
	Body *PostGetAlbumListFormdataRequestBody
}

type PostGetAlbumListResponseObject interface {
	VisitPostGetAlbumListResponse(w http.ResponseWriter) error
}

type PostGetAlbumList200JSONResponse GetAlbumListResponse

func (response PostGetAlbumList200JSONResponse) VisitPostGetAlbumListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetAlbumList405Response = HTTPFormPostNotSupportedResponse

func (response PostGetAlbumList405Response) VisitPostGetAlbumListResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetAlbumList2RequestObject struct {
	Params GetAlbumList2Params
}

type GetAlbumList2ResponseObject interface {
	VisitGetAlbumList2Response(w http.ResponseWriter) error
}

type GetAlbumList2200JSONResponse GetAlbumList2Response

func (response GetAlbumList2200JSONResponse) VisitGetAlbumList2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetAlbumList2RequestObject struct {
	Body *PostGetAlbumList2FormdataRequestBody
}

type PostGetAlbumList2ResponseObject interface {
	VisitPostGetAlbumList2Response(w http.ResponseWriter) error
}

type PostGetAlbumList2200JSONResponse GetAlbumList2Response

func (response PostGetAlbumList2200JSONResponse) VisitPostGetAlbumList2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetAlbumList2405Response = HTTPFormPostNotSupportedResponse

func (response PostGetAlbumList2405Response) VisitPostGetAlbumList2Response(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetArtistRequestObject struct {
	Params GetArtistParams
}

type GetArtistResponseObject interface {
	VisitGetArtistResponse(w http.ResponseWriter) error
}

type GetArtist200JSONResponse GetArtistResponse

func (response GetArtist200JSONResponse) VisitGetArtistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetArtistRequestObject struct {
	Body *PostGetArtistFormdataRequestBody
}

type PostGetArtistResponseObject interface {
	VisitPostGetArtistResponse(w http.ResponseWriter) error
}

type PostGetArtist200JSONResponse GetArtistResponse

func (response PostGetArtist200JSONResponse) VisitPostGetArtistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetArtist405Response = HTTPFormPostNotSupportedResponse

func (response PostGetArtist405Response) VisitPostGetArtistResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetArtistInfoRequestObject struct {
	Params GetArtistInfoParams
}

type GetArtistInfoResponseObject interface {
	VisitGetArtistInfoResponse(w http.ResponseWriter) error
}

type GetArtistInfo200JSONResponse GetArtistInfoResponse

func (response GetArtistInfo200JSONResponse) VisitGetArtistInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetArtistInfoRequestObject struct {
	Body *PostGetArtistInfoFormdataRequestBody
}

type PostGetArtistInfoResponseObject interface {
	VisitPostGetArtistInfoResponse(w http.ResponseWriter) error
}

type PostGetArtistInfo200JSONResponse GetArtistInfoResponse

func (response PostGetArtistInfo200JSONResponse) VisitPostGetArtistInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetArtistInfo405Response = HTTPFormPostNotSupportedResponse

func (response PostGetArtistInfo405Response) VisitPostGetArtistInfoResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetArtistInfo2RequestObject struct {
	Params GetArtistInfo2Params
}

type GetArtistInfo2ResponseObject interface {
	VisitGetArtistInfo2Response(w http.ResponseWriter) error
}

type GetArtistInfo2200JSONResponse GetArtistInfo2Response

func (response GetArtistInfo2200JSONResponse) VisitGetArtistInfo2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetArtistInfo2RequestObject struct {
	Body *PostGetArtistInfo2FormdataRequestBody
}

type PostGetArtistInfo2ResponseObject interface {
	VisitPostGetArtistInfo2Response(w http.ResponseWriter) error
}

type PostGetArtistInfo2200JSONResponse GetArtistInfo2Response

func (response PostGetArtistInfo2200JSONResponse) VisitPostGetArtistInfo2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetArtistInfo2405Response = HTTPFormPostNotSupportedResponse

func (response PostGetArtistInfo2405Response) VisitPostGetArtistInfo2Response(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetArtistsRequestObject struct {
	Params GetArtistsParams
}

type GetArtistsResponseObject interface {
	VisitGetArtistsResponse(w http.ResponseWriter) error
}

type GetArtists200JSONResponse GetArtistsResponse

func (response GetArtists200JSONResponse) VisitGetArtistsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetArtistsRequestObject struct {
	Body *PostGetArtistsFormdataRequestBody
}

type PostGetArtistsResponseObject interface {
	VisitPostGetArtistsResponse(w http.ResponseWriter) error
}

type PostGetArtists200JSONResponse GetArtistsResponse

func (response PostGetArtists200JSONResponse) VisitPostGetArtistsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetArtists405Response = HTTPFormPostNotSupportedResponse

func (response PostGetArtists405Response) VisitPostGetArtistsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetAvatarRequestObject struct {
	Params GetAvatarParams
}

type GetAvatarResponseObject interface {
	VisitGetAvatarResponse(w http.ResponseWriter) error
}

type GetAvatar200ApplicationbinaryResponse struct {
	BinaryResponseApplicationbinaryResponse
}

func (response GetAvatar200ApplicationbinaryResponse) VisitGetAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/binary")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetAvatar200TextxmlResponse struct{ BinaryResponseTextxmlResponse }

func (response GetAvatar200TextxmlResponse) VisitGetAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostGetAvatarRequestObject struct {
	Body *PostGetAvatarFormdataRequestBody
}

type PostGetAvatarResponseObject interface {
	VisitPostGetAvatarResponse(w http.ResponseWriter) error
}

type PostGetAvatar200ApplicationbinaryResponse struct {
	BinaryResponseApplicationbinaryResponse
}

func (response PostGetAvatar200ApplicationbinaryResponse) VisitPostGetAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/binary")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostGetAvatar200TextxmlResponse struct{ BinaryResponseTextxmlResponse }

func (response PostGetAvatar200TextxmlResponse) VisitPostGetAvatarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostGetAvatar405Response = HTTPFormPostNotSupportedResponse

func (response PostGetAvatar405Response) VisitPostGetAvatarResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetBookmarksRequestObject struct {
}

type GetBookmarksResponseObject interface {
	VisitGetBookmarksResponse(w http.ResponseWriter) error
}

type GetBookmarks200JSONResponse GetBookmarksResponse

func (response GetBookmarks200JSONResponse) VisitGetBookmarksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetBookmarksRequestObject struct {
	Body *PostGetBookmarksFormdataRequestBody
}

type PostGetBookmarksResponseObject interface {
	VisitPostGetBookmarksResponse(w http.ResponseWriter) error
}

type PostGetBookmarks200JSONResponse GetBookmarksResponse

func (response PostGetBookmarks200JSONResponse) VisitPostGetBookmarksResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetBookmarks405Response = HTTPFormPostNotSupportedResponse

func (response PostGetBookmarks405Response) VisitPostGetBookmarksResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetCaptionsRequestObject struct {
	Params GetCaptionsParams
}

type GetCaptionsResponseObject interface {
	VisitGetCaptionsResponse(w http.ResponseWriter) error
}

type GetCaptions200ApplicationbinaryResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response GetCaptions200ApplicationbinaryResponse) VisitGetCaptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/binary")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetCaptions200TextResponse string

func (response GetCaptions200TextResponse) VisitGetCaptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/plain")
	w.WriteHeader(200)

	_, err := w.Write([]byte(response))
	return err
}

type PostGetCaptionsRequestObject struct {
	Body *PostGetCaptionsFormdataRequestBody
}

type PostGetCaptionsResponseObject interface {
	VisitPostGetCaptionsResponse(w http.ResponseWriter) error
}

type PostGetCaptions200ApplicationbinaryResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response PostGetCaptions200ApplicationbinaryResponse) VisitPostGetCaptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/binary")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostGetCaptions200TextResponse string

func (response PostGetCaptions200TextResponse) VisitPostGetCaptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/plain")
	w.WriteHeader(200)

	_, err := w.Write([]byte(response))
	return err
}

type PostGetCaptions405Response = HTTPFormPostNotSupportedResponse

func (response PostGetCaptions405Response) VisitPostGetCaptionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetChatMessagesRequestObject struct {
}

type GetChatMessagesResponseObject interface {
	VisitGetChatMessagesResponse(w http.ResponseWriter) error
}

type GetChatMessages200JSONResponse GetChatMessagesResponse

func (response GetChatMessages200JSONResponse) VisitGetChatMessagesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetChatMessagesRequestObject struct {
	Body *PostGetChatMessagesFormdataRequestBody
}

type PostGetChatMessagesResponseObject interface {
	VisitPostGetChatMessagesResponse(w http.ResponseWriter) error
}

type PostGetChatMessages200JSONResponse GetChatMessagesResponse

func (response PostGetChatMessages200JSONResponse) VisitPostGetChatMessagesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetChatMessages405Response = HTTPFormPostNotSupportedResponse

func (response PostGetChatMessages405Response) VisitPostGetChatMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetCoverArtRequestObject struct {
	Params GetCoverArtParams
}

type GetCoverArtResponseObject interface {
	VisitGetCoverArtResponse(w http.ResponseWriter) error
}

type GetCoverArt200ApplicationbinaryResponse struct {
	BinaryResponseApplicationbinaryResponse
}

func (response GetCoverArt200ApplicationbinaryResponse) VisitGetCoverArtResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/binary")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetCoverArt200TextxmlResponse struct{ BinaryResponseTextxmlResponse }

func (response GetCoverArt200TextxmlResponse) VisitGetCoverArtResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostGetCoverArtRequestObject struct {
	Body *PostGetCoverArtFormdataRequestBody
}

type PostGetCoverArtResponseObject interface {
	VisitPostGetCoverArtResponse(w http.ResponseWriter) error
}

type PostGetCoverArt200ApplicationbinaryResponse struct {
	BinaryResponseApplicationbinaryResponse
}

func (response PostGetCoverArt200ApplicationbinaryResponse) VisitPostGetCoverArtResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/binary")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostGetCoverArt200TextxmlResponse struct{ BinaryResponseTextxmlResponse }

func (response PostGetCoverArt200TextxmlResponse) VisitPostGetCoverArtResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostGetCoverArt405Response = HTTPFormPostNotSupportedResponse

func (response PostGetCoverArt405Response) VisitPostGetCoverArtResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetGenresRequestObject struct {
}

type GetGenresResponseObject interface {
	VisitGetGenresResponse(w http.ResponseWriter) error
}

type GetGenres200JSONResponse GetGenresResponse

func (response GetGenres200JSONResponse) VisitGetGenresResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetGenresRequestObject struct {
	Body *PostGetGenresFormdataRequestBody
}

type PostGetGenresResponseObject interface {
	VisitPostGetGenresResponse(w http.ResponseWriter) error
}

type PostGetGenres200JSONResponse GetGenresResponse

func (response PostGetGenres200JSONResponse) VisitPostGetGenresResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetGenres405Response = HTTPFormPostNotSupportedResponse

func (response PostGetGenres405Response) VisitPostGetGenresResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetIndexesRequestObject struct {
	Params GetIndexesParams
}

type GetIndexesResponseObject interface {
	VisitGetIndexesResponse(w http.ResponseWriter) error
}

type GetIndexes200JSONResponse GetIndexesResponse

func (response GetIndexes200JSONResponse) VisitGetIndexesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetIndexesRequestObject struct {
	Body *PostGetIndexesFormdataRequestBody
}

type PostGetIndexesResponseObject interface {
	VisitPostGetIndexesResponse(w http.ResponseWriter) error
}

type PostGetIndexes200JSONResponse GetIndexesResponse

func (response PostGetIndexes200JSONResponse) VisitPostGetIndexesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetIndexes405Response = HTTPFormPostNotSupportedResponse

func (response PostGetIndexes405Response) VisitPostGetIndexesResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetInternetRadioStationsRequestObject struct {
}

type GetInternetRadioStationsResponseObject interface {
	VisitGetInternetRadioStationsResponse(w http.ResponseWriter) error
}

type GetInternetRadioStations200JSONResponse GetInternetRadioStationsResponse

func (response GetInternetRadioStations200JSONResponse) VisitGetInternetRadioStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetInternetRadioStationsRequestObject struct {
	Body *PostGetInternetRadioStationsFormdataRequestBody
}

type PostGetInternetRadioStationsResponseObject interface {
	VisitPostGetInternetRadioStationsResponse(w http.ResponseWriter) error
}

type PostGetInternetRadioStations200JSONResponse GetInternetRadioStationsResponse

func (response PostGetInternetRadioStations200JSONResponse) VisitPostGetInternetRadioStationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetInternetRadioStations405Response = HTTPFormPostNotSupportedResponse

func (response PostGetInternetRadioStations405Response) VisitPostGetInternetRadioStationsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetLicenseRequestObject struct {
}

type GetLicenseResponseObject interface {
	VisitGetLicenseResponse(w http.ResponseWriter) error
}

type GetLicense200JSONResponse GetLicenseResponse

func (response GetLicense200JSONResponse) VisitGetLicenseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetLicenseRequestObject struct {
	Body *PostGetLicenseFormdataRequestBody
}

type PostGetLicenseResponseObject interface {
	VisitPostGetLicenseResponse(w http.ResponseWriter) error
}

type PostGetLicense200JSONResponse GetLicenseResponse

func (response PostGetLicense200JSONResponse) VisitPostGetLicenseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetLicense405Response = HTTPFormPostNotSupportedResponse

func (response PostGetLicense405Response) VisitPostGetLicenseResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetLyricsRequestObject struct {
	Params GetLyricsParams
}

type GetLyricsResponseObject interface {
	VisitGetLyricsResponse(w http.ResponseWriter) error
}

type GetLyrics200JSONResponse GetLyricsResponse

func (response GetLyrics200JSONResponse) VisitGetLyricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetLyricsRequestObject struct {
	Body *PostGetLyricsFormdataRequestBody
}

type PostGetLyricsResponseObject interface {
	VisitPostGetLyricsResponse(w http.ResponseWriter) error
}

type PostGetLyrics200JSONResponse GetLyricsResponse

func (response PostGetLyrics200JSONResponse) VisitPostGetLyricsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetLyrics405Response = HTTPFormPostNotSupportedResponse

func (response PostGetLyrics405Response) VisitPostGetLyricsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetLyricsBySongIdRequestObject struct {
	Params GetLyricsBySongIdParams
}

type GetLyricsBySongIdResponseObject interface {
	VisitGetLyricsBySongIdResponse(w http.ResponseWriter) error
}

type GetLyricsBySongId200JSONResponse GetLyricsBySongIdResponse

func (response GetLyricsBySongId200JSONResponse) VisitGetLyricsBySongIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetLyricsBySongId404Response struct {
}

func (response GetLyricsBySongId404Response) VisitGetLyricsBySongIdResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type PostGetLyricsBySongIdRequestObject struct {
	Body *PostGetLyricsBySongIdFormdataRequestBody
}

type PostGetLyricsBySongIdResponseObject interface {
	VisitPostGetLyricsBySongIdResponse(w http.ResponseWriter) error
}

type PostGetLyricsBySongId200JSONResponse GetLyricsBySongIdResponse

func (response PostGetLyricsBySongId200JSONResponse) VisitPostGetLyricsBySongIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetLyricsBySongId404Response struct {
}

func (response PostGetLyricsBySongId404Response) VisitPostGetLyricsBySongIdResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type PostGetLyricsBySongId405Response = HTTPFormPostNotSupportedResponse

func (response PostGetLyricsBySongId405Response) VisitPostGetLyricsBySongIdResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetMusicDirectoryRequestObject struct {
	Params GetMusicDirectoryParams
}

type GetMusicDirectoryResponseObject interface {
	VisitGetMusicDirectoryResponse(w http.ResponseWriter) error
}

type GetMusicDirectory200JSONResponse GetMusicDirectoryResponse

func (response GetMusicDirectory200JSONResponse) VisitGetMusicDirectoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetMusicDirectoryRequestObject struct {
	Body *PostGetMusicDirectoryFormdataRequestBody
}

type PostGetMusicDirectoryResponseObject interface {
	VisitPostGetMusicDirectoryResponse(w http.ResponseWriter) error
}

type PostGetMusicDirectory200JSONResponse GetMusicDirectoryResponse

func (response PostGetMusicDirectory200JSONResponse) VisitPostGetMusicDirectoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetMusicDirectory405Response = HTTPFormPostNotSupportedResponse

func (response PostGetMusicDirectory405Response) VisitPostGetMusicDirectoryResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetMusicFoldersRequestObject struct {
}

type GetMusicFoldersResponseObject interface {
	VisitGetMusicFoldersResponse(w http.ResponseWriter) error
}

type GetMusicFolders200JSONResponse GetMusicFoldersResponse

func (response GetMusicFolders200JSONResponse) VisitGetMusicFoldersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetMusicFoldersRequestObject struct {
	Body *PostGetMusicFoldersFormdataRequestBody
}

type PostGetMusicFoldersResponseObject interface {
	VisitPostGetMusicFoldersResponse(w http.ResponseWriter) error
}

type PostGetMusicFolders200JSONResponse GetMusicFoldersResponse

func (response PostGetMusicFolders200JSONResponse) VisitPostGetMusicFoldersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetMusicFolders405Response = HTTPFormPostNotSupportedResponse

func (response PostGetMusicFolders405Response) VisitPostGetMusicFoldersResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetNewestPodcastsRequestObject struct {
	Params GetNewestPodcastsParams
}

type GetNewestPodcastsResponseObject interface {
	VisitGetNewestPodcastsResponse(w http.ResponseWriter) error
}

type GetNewestPodcasts200JSONResponse GetNewestPodcastsResponse

func (response GetNewestPodcasts200JSONResponse) VisitGetNewestPodcastsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetNewestPodcastsRequestObject struct {
	Body *PostGetNewestPodcastsFormdataRequestBody
}

type PostGetNewestPodcastsResponseObject interface {
	VisitPostGetNewestPodcastsResponse(w http.ResponseWriter) error
}

type PostGetNewestPodcasts200JSONResponse GetNewestPodcastsResponse

func (response PostGetNewestPodcasts200JSONResponse) VisitPostGetNewestPodcastsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetNewestPodcasts405Response = HTTPFormPostNotSupportedResponse

func (response PostGetNewestPodcasts405Response) VisitPostGetNewestPodcastsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetNowPlayingRequestObject struct {
}

type GetNowPlayingResponseObject interface {
	VisitGetNowPlayingResponse(w http.ResponseWriter) error
}

type GetNowPlaying200JSONResponse GetNowPlayingResponse

func (response GetNowPlaying200JSONResponse) VisitGetNowPlayingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetNowPlayingRequestObject struct {
	Body *PostGetNowPlayingFormdataRequestBody
}

type PostGetNowPlayingResponseObject interface {
	VisitPostGetNowPlayingResponse(w http.ResponseWriter) error
}

type PostGetNowPlaying200JSONResponse GetNowPlayingResponse

func (response PostGetNowPlaying200JSONResponse) VisitPostGetNowPlayingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetNowPlaying405Response = HTTPFormPostNotSupportedResponse

func (response PostGetNowPlaying405Response) VisitPostGetNowPlayingResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetOpenSubsonicExtensionsRequestObject struct {
}

type GetOpenSubsonicExtensionsResponseObject interface {
	VisitGetOpenSubsonicExtensionsResponse(w http.ResponseWriter) error
}

type GetOpenSubsonicExtensions200JSONResponse GetOpenSubsonicExtensionsResponse

func (response GetOpenSubsonicExtensions200JSONResponse) VisitGetOpenSubsonicExtensionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetOpenSubsonicExtensionsRequestObject struct {
	Body *PostGetOpenSubsonicExtensionsFormdataRequestBody
}

type PostGetOpenSubsonicExtensionsResponseObject interface {
	VisitPostGetOpenSubsonicExtensionsResponse(w http.ResponseWriter) error
}

type PostGetOpenSubsonicExtensions200JSONResponse GetOpenSubsonicExtensionsResponse

func (response PostGetOpenSubsonicExtensions200JSONResponse) VisitPostGetOpenSubsonicExtensionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetOpenSubsonicExtensions405Response = HTTPFormPostNotSupportedResponse

func (response PostGetOpenSubsonicExtensions405Response) VisitPostGetOpenSubsonicExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetPlayQueueRequestObject struct {
}

type GetPlayQueueResponseObject interface {
	VisitGetPlayQueueResponse(w http.ResponseWriter) error
}

type GetPlayQueue200JSONResponse GetPlayQueueResponse

func (response GetPlayQueue200JSONResponse) VisitGetPlayQueueResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPlayQueueRequestObject struct {
	Body *PostGetPlayQueueFormdataRequestBody
}

type PostGetPlayQueueResponseObject interface {
	VisitPostGetPlayQueueResponse(w http.ResponseWriter) error
}

type PostGetPlayQueue200JSONResponse GetPlayQueueResponse

func (response PostGetPlayQueue200JSONResponse) VisitPostGetPlayQueueResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPlayQueue405Response = HTTPFormPostNotSupportedResponse

func (response PostGetPlayQueue405Response) VisitPostGetPlayQueueResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetPlayQueueByIndexRequestObject struct {
}

type GetPlayQueueByIndexResponseObject interface {
	VisitGetPlayQueueByIndexResponse(w http.ResponseWriter) error
}

type GetPlayQueueByIndex200JSONResponse GetPlayQueueByIndexResponse

func (response GetPlayQueueByIndex200JSONResponse) VisitGetPlayQueueByIndexResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPlayQueueByIndexRequestObject struct {
	Body *PostGetPlayQueueByIndexFormdataRequestBody
}

type PostGetPlayQueueByIndexResponseObject interface {
	VisitPostGetPlayQueueByIndexResponse(w http.ResponseWriter) error
}

type PostGetPlayQueueByIndex200JSONResponse GetPlayQueueByIndexResponse

func (response PostGetPlayQueueByIndex200JSONResponse) VisitPostGetPlayQueueByIndexResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPlayQueueByIndex405Response = HTTPFormPostNotSupportedResponse

func (response PostGetPlayQueueByIndex405Response) VisitPostGetPlayQueueByIndexResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetPlaylistRequestObject struct {
	Params GetPlaylistParams
}

type GetPlaylistResponseObject interface {
	VisitGetPlaylistResponse(w http.ResponseWriter) error
}

type GetPlaylist200JSONResponse GetPlaylistResponse

func (response GetPlaylist200JSONResponse) VisitGetPlaylistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPlaylistRequestObject struct {
	Body *PostGetPlaylistFormdataRequestBody
}

type PostGetPlaylistResponseObject interface {
	VisitPostGetPlaylistResponse(w http.ResponseWriter) error
}

type PostGetPlaylist200JSONResponse GetPlaylistResponse

func (response PostGetPlaylist200JSONResponse) VisitPostGetPlaylistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPlaylist405Response = HTTPFormPostNotSupportedResponse

func (response PostGetPlaylist405Response) VisitPostGetPlaylistResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetPlaylistsRequestObject struct {
	Params GetPlaylistsParams
}

type GetPlaylistsResponseObject interface {
	VisitGetPlaylistsResponse(w http.ResponseWriter) error
}

type GetPlaylists200JSONResponse GetPlaylistsResponse

func (response GetPlaylists200JSONResponse) VisitGetPlaylistsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPlaylistsRequestObject struct {
	Body *PostGetPlaylistsFormdataRequestBody
}

type PostGetPlaylistsResponseObject interface {
	VisitPostGetPlaylistsResponse(w http.ResponseWriter) error
}

type PostGetPlaylists200JSONResponse GetPlaylistsResponse

func (response PostGetPlaylists200JSONResponse) VisitPostGetPlaylistsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPlaylists405Response = HTTPFormPostNotSupportedResponse

func (response PostGetPlaylists405Response) VisitPostGetPlaylistsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetPodcastEpisodeRequestObject struct {
	Params GetPodcastEpisodeParams
}

type GetPodcastEpisodeResponseObject interface {
	VisitGetPodcastEpisodeResponse(w http.ResponseWriter) error
}

type GetPodcastEpisode200JSONResponse GetPodcastEpisodeResponse

func (response GetPodcastEpisode200JSONResponse) VisitGetPodcastEpisodeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPodcastEpisode404Response struct {
}

func (response GetPodcastEpisode404Response) VisitGetPodcastEpisodeResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type PostGetPodcastEpisodeRequestObject struct {
	Body *PostGetPodcastEpisodeFormdataRequestBody
}

type PostGetPodcastEpisodeResponseObject interface {
	VisitPostGetPodcastEpisodeResponse(w http.ResponseWriter) error
}

type PostGetPodcastEpisode200JSONResponse GetPodcastEpisodeResponse

func (response PostGetPodcastEpisode200JSONResponse) VisitPostGetPodcastEpisodeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPodcastEpisode404Response struct {
}

func (response PostGetPodcastEpisode404Response) VisitPostGetPodcastEpisodeResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type PostGetPodcastEpisode405Response = HTTPFormPostNotSupportedResponse

func (response PostGetPodcastEpisode405Response) VisitPostGetPodcastEpisodeResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetPodcastsRequestObject struct {
	Params GetPodcastsParams
}

type GetPodcastsResponseObject interface {
	VisitGetPodcastsResponse(w http.ResponseWriter) error
}

type GetPodcasts200JSONResponse GetPodcastsResponse

func (response GetPodcasts200JSONResponse) VisitGetPodcastsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPodcastsRequestObject struct {
	Body *PostGetPodcastsFormdataRequestBody
}

type PostGetPodcastsResponseObject interface {
	VisitPostGetPodcastsResponse(w http.ResponseWriter) error
}

type PostGetPodcasts200JSONResponse GetPodcastsResponse

func (response PostGetPodcasts200JSONResponse) VisitPostGetPodcastsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetPodcasts405Response = HTTPFormPostNotSupportedResponse

func (response PostGetPodcasts405Response) VisitPostGetPodcastsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetRandomSongsRequestObject struct {
	Params GetRandomSongsParams
}

type GetRandomSongsResponseObject interface {
	VisitGetRandomSongsResponse(w http.ResponseWriter) error
}

type GetRandomSongs200JSONResponse GetRandomSongsResponse

func (response GetRandomSongs200JSONResponse) VisitGetRandomSongsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetRandomSongsRequestObject struct {
	Body *PostGetRandomSongsFormdataRequestBody
}

type PostGetRandomSongsResponseObject interface {
	VisitPostGetRandomSongsResponse(w http.ResponseWriter) error
}

type PostGetRandomSongs200JSONResponse GetRandomSongsResponse

func (response PostGetRandomSongs200JSONResponse) VisitPostGetRandomSongsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetRandomSongs405Response = HTTPFormPostNotSupportedResponse

func (response PostGetRandomSongs405Response) VisitPostGetRandomSongsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetScanStatusRequestObject struct {
}

type GetScanStatusResponseObject interface {
	VisitGetScanStatusResponse(w http.ResponseWriter) error
}

type GetScanStatus200JSONResponse GetScanStatusResponse

func (response GetScanStatus200JSONResponse) VisitGetScanStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetScanStatusRequestObject struct {
	Body *PostGetScanStatusFormdataRequestBody
}

type PostGetScanStatusResponseObject interface {
	VisitPostGetScanStatusResponse(w http.ResponseWriter) error
}

type PostGetScanStatus200JSONResponse GetScanStatusResponse

func (response PostGetScanStatus200JSONResponse) VisitPostGetScanStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetScanStatus405Response = HTTPFormPostNotSupportedResponse

func (response PostGetScanStatus405Response) VisitPostGetScanStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetSharesRequestObject struct {
}

type GetSharesResponseObject interface {
	VisitGetSharesResponse(w http.ResponseWriter) error
}

type GetShares200JSONResponse GetSharesResponse

func (response GetShares200JSONResponse) VisitGetSharesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetSharesRequestObject struct {
	Body *PostGetSharesFormdataRequestBody
}

type PostGetSharesResponseObject interface {
	VisitPostGetSharesResponse(w http.ResponseWriter) error
}

type PostGetShares200JSONResponse GetSharesResponse

func (response PostGetShares200JSONResponse) VisitPostGetSharesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetShares405Response = HTTPFormPostNotSupportedResponse

func (response PostGetShares405Response) VisitPostGetSharesResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetSimilarSongsRequestObject struct {
	Params GetSimilarSongsParams
}

type GetSimilarSongsResponseObject interface {
	VisitGetSimilarSongsResponse(w http.ResponseWriter) error
}

type GetSimilarSongs200JSONResponse GetSimilarSongsResponse

func (response GetSimilarSongs200JSONResponse) VisitGetSimilarSongsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetSimilarSongsRequestObject struct {
	Body *PostGetSimilarSongsFormdataRequestBody
}

type PostGetSimilarSongsResponseObject interface {
	VisitPostGetSimilarSongsResponse(w http.ResponseWriter) error
}

type PostGetSimilarSongs200JSONResponse GetSimilarSongsResponse

func (response PostGetSimilarSongs200JSONResponse) VisitPostGetSimilarSongsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetSimilarSongs405Response = HTTPFormPostNotSupportedResponse

func (response PostGetSimilarSongs405Response) VisitPostGetSimilarSongsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetSimilarSongs2RequestObject struct {
	Params GetSimilarSongs2Params
}

type GetSimilarSongs2ResponseObject interface {
	VisitGetSimilarSongs2Response(w http.ResponseWriter) error
}

type GetSimilarSongs2200JSONResponse GetSimilarSongs2Response

func (response GetSimilarSongs2200JSONResponse) VisitGetSimilarSongs2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetSimilarSongs2RequestObject struct {
	Body *PostGetSimilarSongs2FormdataRequestBody
}

type PostGetSimilarSongs2ResponseObject interface {
	VisitPostGetSimilarSongs2Response(w http.ResponseWriter) error
}

type PostGetSimilarSongs2200JSONResponse GetSimilarSongs2Response

func (response PostGetSimilarSongs2200JSONResponse) VisitPostGetSimilarSongs2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetSimilarSongs2405Response = HTTPFormPostNotSupportedResponse

func (response PostGetSimilarSongs2405Response) VisitPostGetSimilarSongs2Response(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetSongRequestObject struct {
	Params GetSongParams
}

type GetSongResponseObject interface {
	VisitGetSongResponse(w http.ResponseWriter) error
}

type GetSong200JSONResponse GetSongResponse

func (response GetSong200JSONResponse) VisitGetSongResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetSongRequestObject struct {
	Body *PostGetSongFormdataRequestBody
}

type PostGetSongResponseObject interface {
	VisitPostGetSongResponse(w http.ResponseWriter) error
}

type PostGetSong200JSONResponse GetSongResponse

func (response PostGetSong200JSONResponse) VisitPostGetSongResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetSong405Response = HTTPFormPostNotSupportedResponse

func (response PostGetSong405Response) VisitPostGetSongResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetSongsByGenreRequestObject struct {
	Params GetSongsByGenreParams
}

type GetSongsByGenreResponseObject interface {
	VisitGetSongsByGenreResponse(w http.ResponseWriter) error
}

type GetSongsByGenre200JSONResponse GetSongsByGenreResponse

func (response GetSongsByGenre200JSONResponse) VisitGetSongsByGenreResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetSongsByGenreRequestObject struct {
	Body *PostGetSongsByGenreFormdataRequestBody
}

type PostGetSongsByGenreResponseObject interface {
	VisitPostGetSongsByGenreResponse(w http.ResponseWriter) error
}

type PostGetSongsByGenre200JSONResponse GetSongsByGenreResponse

func (response PostGetSongsByGenre200JSONResponse) VisitPostGetSongsByGenreResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetSongsByGenre405Response = HTTPFormPostNotSupportedResponse

func (response PostGetSongsByGenre405Response) VisitPostGetSongsByGenreResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetStarredRequestObject struct {
	Params GetStarredParams
}

type GetStarredResponseObject interface {
	VisitGetStarredResponse(w http.ResponseWriter) error
}

type GetStarred200JSONResponse GetStarredResponse

func (response GetStarred200JSONResponse) VisitGetStarredResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetStarredRequestObject struct {
	Body *PostGetStarredFormdataRequestBody
}

type PostGetStarredResponseObject interface {
	VisitPostGetStarredResponse(w http.ResponseWriter) error
}

type PostGetStarred200JSONResponse GetStarredResponse

func (response PostGetStarred200JSONResponse) VisitPostGetStarredResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetStarred405Response = HTTPFormPostNotSupportedResponse

func (response PostGetStarred405Response) VisitPostGetStarredResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetStarred2RequestObject struct {
	Params GetStarred2Params
}

type GetStarred2ResponseObject interface {
	VisitGetStarred2Response(w http.ResponseWriter) error
}

type GetStarred2200JSONResponse GetStarred2Response

func (response GetStarred2200JSONResponse) VisitGetStarred2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetStarred2RequestObject struct {
	Body *PostGetStarred2FormdataRequestBody
}

type PostGetStarred2ResponseObject interface {
	VisitPostGetStarred2Response(w http.ResponseWriter) error
}

type PostGetStarred2200JSONResponse GetStarred2Response

func (response PostGetStarred2200JSONResponse) VisitPostGetStarred2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetStarred2405Response = HTTPFormPostNotSupportedResponse

func (response PostGetStarred2405Response) VisitPostGetStarred2Response(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetTopSongsRequestObject struct {
	Params GetTopSongsParams
}

type GetTopSongsResponseObject interface {
	VisitGetTopSongsResponse(w http.ResponseWriter) error
}

type GetTopSongs200JSONResponse GetTopSongsResponse

func (response GetTopSongs200JSONResponse) VisitGetTopSongsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetTopSongsRequestObject struct {
	Body *PostGetTopSongsFormdataRequestBody
}

type PostGetTopSongsResponseObject interface {
	VisitPostGetTopSongsResponse(w http.ResponseWriter) error
}

type PostGetTopSongs200JSONResponse GetTopSongsResponse

func (response PostGetTopSongs200JSONResponse) VisitPostGetTopSongsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetTopSongs405Response = HTTPFormPostNotSupportedResponse

func (response PostGetTopSongs405Response) VisitPostGetTopSongsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetTranscodeDecisionRequestObject struct {
	Params GetTranscodeDecisionParams
	Body   *GetTranscodeDecisionJSONRequestBody
}

type GetTranscodeDecisionResponseObject interface {
	VisitGetTranscodeDecisionResponse(w http.ResponseWriter) error
}

type GetTranscodeDecision200JSONResponse struct {
	TranscodeDecisionResponseJSONResponse
}

func (response GetTranscodeDecision200JSONResponse) VisitGetTranscodeDecisionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetTranscodeDecision200ApplicationxmlResponse struct {
	TranscodeDecisionResponseApplicationxmlResponse
}

func (response GetTranscodeDecision200ApplicationxmlResponse) VisitGetTranscodeDecisionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetTranscodeStreamRequestObject struct {
	Params GetTranscodeStreamParams
}

type GetTranscodeStreamResponseObject interface {
	VisitGetTranscodeStreamResponse(w http.ResponseWriter) error
}

type GetTranscodeStream200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response GetTranscodeStream200ApplicationoctetStreamResponse) VisitGetTranscodeStreamResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetTranscodeStream400Response struct {
}

func (response GetTranscodeStream400Response) VisitGetTranscodeStreamResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetTranscodeStream401Response struct {
}

func (response GetTranscodeStream401Response) VisitGetTranscodeStreamResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetTranscodeStream404Response struct {
}

func (response GetTranscodeStream404Response) VisitGetTranscodeStreamResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetTranscodeStream500Response struct {
}

func (response GetTranscodeStream500Response) VisitGetTranscodeStreamResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type GetUserRequestObject struct {
	Params GetUserParams
}

type GetUserResponseObject interface {
	VisitGetUserResponse(w http.ResponseWriter) error
}

type GetUser200JSONResponse GetUserResponse

func (response GetUser200JSONResponse) VisitGetUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetUserRequestObject struct {
	Body *PostGetUserFormdataRequestBody
}

type PostGetUserResponseObject interface {
	VisitPostGetUserResponse(w http.ResponseWriter) error
}

type PostGetUser200JSONResponse GetUserResponse

func (response PostGetUser200JSONResponse) VisitPostGetUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetUser405Response = HTTPFormPostNotSupportedResponse

func (response PostGetUser405Response) VisitPostGetUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetUsersRequestObject struct {
}

type GetUsersResponseObject interface {
	VisitGetUsersResponse(w http.ResponseWriter) error
}

type GetUsers200JSONResponse GetUsersResponse

func (response GetUsers200JSONResponse) VisitGetUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetUsersRequestObject struct {
	Body *PostGetUsersFormdataRequestBody
}

type PostGetUsersResponseObject interface {
	VisitPostGetUsersResponse(w http.ResponseWriter) error
}

type PostGetUsers200JSONResponse GetUsersResponse

func (response PostGetUsers200JSONResponse) VisitPostGetUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetUsers405Response = HTTPFormPostNotSupportedResponse

func (response PostGetUsers405Response) VisitPostGetUsersResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetVideoInfoRequestObject struct {
	Params GetVideoInfoParams
}

type GetVideoInfoResponseObject interface {
	VisitGetVideoInfoResponse(w http.ResponseWriter) error
}

type GetVideoInfo200JSONResponse GetVideoInfoResponse

func (response GetVideoInfo200JSONResponse) VisitGetVideoInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetVideoInfoRequestObject struct {
	Body *PostGetVideoInfoFormdataRequestBody
}

type PostGetVideoInfoResponseObject interface {
	VisitPostGetVideoInfoResponse(w http.ResponseWriter) error
}

type PostGetVideoInfo200JSONResponse GetVideoInfoResponse

func (response PostGetVideoInfo200JSONResponse) VisitPostGetVideoInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetVideoInfo405Response = HTTPFormPostNotSupportedResponse

func (response PostGetVideoInfo405Response) VisitPostGetVideoInfoResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type GetVideosRequestObject struct {
}

type GetVideosResponseObject interface {
	VisitGetVideosResponse(w http.ResponseWriter) error
}

type GetVideos200JSONResponse GetVideosResponse

func (response GetVideos200JSONResponse) VisitGetVideosResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetVideosRequestObject struct {
	Body *PostGetVideosFormdataRequestBody
}

type PostGetVideosResponseObject interface {
	VisitPostGetVideosResponse(w http.ResponseWriter) error
}

type PostGetVideos200JSONResponse GetVideosResponse

func (response PostGetVideos200JSONResponse) VisitPostGetVideosResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostGetVideos405Response = HTTPFormPostNotSupportedResponse

func (response PostGetVideos405Response) VisitPostGetVideosResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type HlsM3u8RequestObject struct {
	Params HlsM3u8Params
}

type HlsM3u8ResponseObject interface {
	VisitHlsM3u8Response(w http.ResponseWriter) error
}

type HlsM3u8200ApplicationvndAppleMpegurlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response HlsM3u8200ApplicationvndAppleMpegurlResponse) VisitHlsM3u8Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/vnd.apple.mpegurl")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type HlsM3u8200TextxmlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response HlsM3u8200TextxmlResponse) VisitHlsM3u8Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostHlsM3u8RequestObject struct {
	Body *PostHlsM3u8FormdataRequestBody
}

type PostHlsM3u8ResponseObject interface {
	VisitPostHlsM3u8Response(w http.ResponseWriter) error
}

type PostHlsM3u8200ApplicationvndAppleMpegurlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response PostHlsM3u8200ApplicationvndAppleMpegurlResponse) VisitPostHlsM3u8Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/vnd.apple.mpegurl")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostHlsM3u8200TextxmlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response PostHlsM3u8200TextxmlResponse) VisitPostHlsM3u8Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostHlsM3u8405Response = HTTPFormPostNotSupportedResponse

func (response PostHlsM3u8405Response) VisitPostHlsM3u8Response(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type JukeboxControlRequestObject struct {
	Params JukeboxControlParams
}

type JukeboxControlResponseObject interface {
	VisitJukeboxControlResponse(w http.ResponseWriter) error
}

type JukeboxControl200JSONResponse JukeboxControlResponse

func (response JukeboxControl200JSONResponse) VisitJukeboxControlResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostJukeboxControlRequestObject struct {
	Body *PostJukeboxControlFormdataRequestBody
}

type PostJukeboxControlResponseObject interface {
	VisitPostJukeboxControlResponse(w http.ResponseWriter) error
}

type PostJukeboxControl200JSONResponse JukeboxControlResponse

func (response PostJukeboxControl200JSONResponse) VisitPostJukeboxControlResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostJukeboxControl405Response = HTTPFormPostNotSupportedResponse

func (response PostJukeboxControl405Response) VisitPostJukeboxControlResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type PingRequestObject struct {
}

type PingResponseObject interface {
	VisitPingResponse(w http.ResponseWriter) error
}

type Ping200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response Ping200JSONResponse) VisitPingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostPingRequestObject struct {
	Body *PostPingFormdataRequestBody
}

type PostPingResponseObject interface {
	VisitPostPingResponse(w http.ResponseWriter) error
}

type PostPing200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostPing200JSONResponse) VisitPostPingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostPing405Response = HTTPFormPostNotSupportedResponse

func (response PostPing405Response) VisitPostPingResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type RefreshPodcastsRequestObject struct {
}

type RefreshPodcastsResponseObject interface {
	VisitRefreshPodcastsResponse(w http.ResponseWriter) error
}

type RefreshPodcasts200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response RefreshPodcasts200JSONResponse) VisitRefreshPodcastsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostRefreshPodcastsRequestObject struct {
	Body *PostRefreshPodcastsFormdataRequestBody
}

type PostRefreshPodcastsResponseObject interface {
	VisitPostRefreshPodcastsResponse(w http.ResponseWriter) error
}

type PostRefreshPodcasts200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostRefreshPodcasts200JSONResponse) VisitPostRefreshPodcastsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostRefreshPodcasts405Response = HTTPFormPostNotSupportedResponse

func (response PostRefreshPodcasts405Response) VisitPostRefreshPodcastsResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type SavePlayQueueRequestObject struct {
	Params SavePlayQueueParams
}

type SavePlayQueueResponseObject interface {
	VisitSavePlayQueueResponse(w http.ResponseWriter) error
}

type SavePlayQueue200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response SavePlayQueue200JSONResponse) VisitSavePlayQueueResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSavePlayQueueRequestObject struct {
	Body *PostSavePlayQueueFormdataRequestBody
}

type PostSavePlayQueueResponseObject interface {
	VisitPostSavePlayQueueResponse(w http.ResponseWriter) error
}

type PostSavePlayQueue200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostSavePlayQueue200JSONResponse) VisitPostSavePlayQueueResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSavePlayQueue405Response = HTTPFormPostNotSupportedResponse

func (response PostSavePlayQueue405Response) VisitPostSavePlayQueueResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type SavePlayQueueByIndexRequestObject struct {
	Params SavePlayQueueByIndexParams
}

type SavePlayQueueByIndexResponseObject interface {
	VisitSavePlayQueueByIndexResponse(w http.ResponseWriter) error
}

type SavePlayQueueByIndex200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response SavePlayQueueByIndex200JSONResponse) VisitSavePlayQueueByIndexResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSavePlayQueueByIndexRequestObject struct {
	Body *PostSavePlayQueueByIndexFormdataRequestBody
}

type PostSavePlayQueueByIndexResponseObject interface {
	VisitPostSavePlayQueueByIndexResponse(w http.ResponseWriter) error
}

type PostSavePlayQueueByIndex200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostSavePlayQueueByIndex200JSONResponse) VisitPostSavePlayQueueByIndexResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSavePlayQueueByIndex405Response = HTTPFormPostNotSupportedResponse

func (response PostSavePlayQueueByIndex405Response) VisitPostSavePlayQueueByIndexResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type ScrobbleRequestObject struct {
	Params ScrobbleParams
}

type ScrobbleResponseObject interface {
	VisitScrobbleResponse(w http.ResponseWriter) error
}

type Scrobble200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response Scrobble200JSONResponse) VisitScrobbleResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostScrobbleRequestObject struct {
	Body *PostScrobbleFormdataRequestBody
}

type PostScrobbleResponseObject interface {
	VisitPostScrobbleResponse(w http.ResponseWriter) error
}

type PostScrobble200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostScrobble200JSONResponse) VisitPostScrobbleResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostScrobble405Response = HTTPFormPostNotSupportedResponse

func (response PostScrobble405Response) VisitPostScrobbleResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type SearchRequestObject struct {
	Params SearchParams
}

type SearchResponseObject interface {
	VisitSearchResponse(w http.ResponseWriter) error
}

type Search200JSONResponse SearchResponse

func (response Search200JSONResponse) VisitSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSearchRequestObject struct {
	Body *PostSearchFormdataRequestBody
}

type PostSearchResponseObject interface {
	VisitPostSearchResponse(w http.ResponseWriter) error
}

type PostSearch200JSONResponse SearchResponse

func (response PostSearch200JSONResponse) VisitPostSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSearch405Response = HTTPFormPostNotSupportedResponse

func (response PostSearch405Response) VisitPostSearchResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type Search2RequestObject struct {
	Params Search2Params
}

type Search2ResponseObject interface {
	VisitSearch2Response(w http.ResponseWriter) error
}

type Search2200JSONResponse Search2Response

func (response Search2200JSONResponse) VisitSearch2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSearch2RequestObject struct {
	Body *PostSearch2FormdataRequestBody
}

type PostSearch2ResponseObject interface {
	VisitPostSearch2Response(w http.ResponseWriter) error
}

type PostSearch2200JSONResponse Search2Response

func (response PostSearch2200JSONResponse) VisitPostSearch2Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSearch2405Response = HTTPFormPostNotSupportedResponse

func (response PostSearch2405Response) VisitPostSearch2Response(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type Search3RequestObject struct {
	Params Search3Params
}

type Search3ResponseObject interface {
	VisitSearch3Response(w http.ResponseWriter) error
}

type Search3200JSONResponse Search3Response

func (response Search3200JSONResponse) VisitSearch3Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSearch3RequestObject struct {
	Body *PostSearch3FormdataRequestBody
}

type PostSearch3ResponseObject interface {
	VisitPostSearch3Response(w http.ResponseWriter) error
}

type PostSearch3200JSONResponse Search3Response

func (response PostSearch3200JSONResponse) VisitPostSearch3Response(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSearch3405Response = HTTPFormPostNotSupportedResponse

func (response PostSearch3405Response) VisitPostSearch3Response(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type SetRatingRequestObject struct {
	Params SetRatingParams
}

type SetRatingResponseObject interface {
	VisitSetRatingResponse(w http.ResponseWriter) error
}

type SetRating200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response SetRating200JSONResponse) VisitSetRatingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSetRatingRequestObject struct {
	Body *PostSetRatingFormdataRequestBody
}

type PostSetRatingResponseObject interface {
	VisitPostSetRatingResponse(w http.ResponseWriter) error
}

type PostSetRating200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostSetRating200JSONResponse) VisitPostSetRatingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostSetRating405Response = HTTPFormPostNotSupportedResponse

func (response PostSetRating405Response) VisitPostSetRatingResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type StarRequestObject struct {
	Params StarParams
}

type StarResponseObject interface {
	VisitStarResponse(w http.ResponseWriter) error
}

type Star200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response Star200JSONResponse) VisitStarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostStarRequestObject struct {
	Body *PostStarFormdataRequestBody
}

type PostStarResponseObject interface {
	VisitPostStarResponse(w http.ResponseWriter) error
}

type PostStar200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostStar200JSONResponse) VisitPostStarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostStar405Response = HTTPFormPostNotSupportedResponse

func (response PostStar405Response) VisitPostStarResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type StartScanRequestObject struct {
}

type StartScanResponseObject interface {
	VisitStartScanResponse(w http.ResponseWriter) error
}

type StartScan200JSONResponse StartScanResponse

func (response StartScan200JSONResponse) VisitStartScanResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostStartScanRequestObject struct {
	Body *PostStartScanFormdataRequestBody
}

type PostStartScanResponseObject interface {
	VisitPostStartScanResponse(w http.ResponseWriter) error
}

type PostStartScan200JSONResponse StartScanResponse

func (response PostStartScan200JSONResponse) VisitPostStartScanResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostStartScan405Response = HTTPFormPostNotSupportedResponse

func (response PostStartScan405Response) VisitPostStartScanResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type StreamRequestObject struct {
	Params StreamParams
}

type StreamResponseObject interface {
	VisitStreamResponse(w http.ResponseWriter) error
}

type Stream200ApplicationbinaryResponse struct {
	BinaryResponseApplicationbinaryResponse
}

func (response Stream200ApplicationbinaryResponse) VisitStreamResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/binary")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type Stream200TextxmlResponse struct{ BinaryResponseTextxmlResponse }

func (response Stream200TextxmlResponse) VisitStreamResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostStreamRequestObject struct {
	Body *PostStreamFormdataRequestBody
}

type PostStreamResponseObject interface {
	VisitPostStreamResponse(w http.ResponseWriter) error
}

type PostStream200ApplicationbinaryResponse struct {
	BinaryResponseApplicationbinaryResponse
}

func (response PostStream200ApplicationbinaryResponse) VisitPostStreamResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/binary")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostStream200TextxmlResponse struct{ BinaryResponseTextxmlResponse }

func (response PostStream200TextxmlResponse) VisitPostStreamResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/xml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostStream405Response = HTTPFormPostNotSupportedResponse

func (response PostStream405Response) VisitPostStreamResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type TokenInfoRequestObject struct {
}

type TokenInfoResponseObject interface {
	VisitTokenInfoResponse(w http.ResponseWriter) error
}

type TokenInfo200JSONResponse GetTokenInfoResponse

func (response TokenInfo200JSONResponse) VisitTokenInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type TokenInfo404Response struct {
}

func (response TokenInfo404Response) VisitTokenInfoResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type PostTokenInfoRequestObject struct {
	Body *PostTokenInfoFormdataRequestBody
}

type PostTokenInfoResponseObject interface {
	VisitPostTokenInfoResponse(w http.ResponseWriter) error
}

type PostTokenInfo200JSONResponse GetTokenInfoResponse

func (response PostTokenInfo200JSONResponse) VisitPostTokenInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostTokenInfo404Response struct {
}

func (response PostTokenInfo404Response) VisitPostTokenInfoResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type PostTokenInfo405Response = HTTPFormPostNotSupportedResponse

func (response PostTokenInfo405Response) VisitPostTokenInfoResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type UnstarRequestObject struct {
	Params UnstarParams
}

type UnstarResponseObject interface {
	VisitUnstarResponse(w http.ResponseWriter) error
}

type Unstar200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response Unstar200JSONResponse) VisitUnstarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostUnstarRequestObject struct {
	Body *PostUnstarFormdataRequestBody
}

type PostUnstarResponseObject interface {
	VisitPostUnstarResponse(w http.ResponseWriter) error
}

type PostUnstar200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostUnstar200JSONResponse) VisitPostUnstarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostUnstar405Response = HTTPFormPostNotSupportedResponse

func (response PostUnstar405Response) VisitPostUnstarResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type UpdateInternetRadioStationRequestObject struct {
	Params UpdateInternetRadioStationParams
}

type UpdateInternetRadioStationResponseObject interface {
	VisitUpdateInternetRadioStationResponse(w http.ResponseWriter) error
}

type UpdateInternetRadioStation200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response UpdateInternetRadioStation200JSONResponse) VisitUpdateInternetRadioStationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostUpdateInternetRadioStationRequestObject struct {
	Body *PostUpdateInternetRadioStationFormdataRequestBody
}

type PostUpdateInternetRadioStationResponseObject interface {
	VisitPostUpdateInternetRadioStationResponse(w http.ResponseWriter) error
}

type PostUpdateInternetRadioStation200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostUpdateInternetRadioStation200JSONResponse) VisitPostUpdateInternetRadioStationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostUpdateInternetRadioStation405Response = HTTPFormPostNotSupportedResponse

func (response PostUpdateInternetRadioStation405Response) VisitPostUpdateInternetRadioStationResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type UpdatePlaylistRequestObject struct {
	Params UpdatePlaylistParams
}

type UpdatePlaylistResponseObject interface {
	VisitUpdatePlaylistResponse(w http.ResponseWriter) error
}

type UpdatePlaylist200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response UpdatePlaylist200JSONResponse) VisitUpdatePlaylistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostUpdatePlaylistRequestObject struct {
	Body *PostUpdatePlaylistFormdataRequestBody
}

type PostUpdatePlaylistResponseObject interface {
	VisitPostUpdatePlaylistResponse(w http.ResponseWriter) error
}

type PostUpdatePlaylist200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostUpdatePlaylist200JSONResponse) VisitPostUpdatePlaylistResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostUpdatePlaylist405Response = HTTPFormPostNotSupportedResponse

func (response PostUpdatePlaylist405Response) VisitPostUpdatePlaylistResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type UpdateShareRequestObject struct {
	Params UpdateShareParams
}

type UpdateShareResponseObject interface {
	VisitUpdateShareResponse(w http.ResponseWriter) error
}

type UpdateShare200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response UpdateShare200JSONResponse) VisitUpdateShareResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostUpdateShareRequestObject struct {
	Body *PostUpdateShareFormdataRequestBody
}

type PostUpdateShareResponseObject interface {
	VisitPostUpdateShareResponse(w http.ResponseWriter) error
}

type PostUpdateShare200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostUpdateShare200JSONResponse) VisitPostUpdateShareResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostUpdateShare405Response = HTTPFormPostNotSupportedResponse

func (response PostUpdateShare405Response) VisitPostUpdateShareResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type UpdateUserRequestObject struct {
	Params UpdateUserParams
}

type UpdateUserResponseObject interface {
	VisitUpdateUserResponse(w http.ResponseWriter) error
}

type UpdateUser200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response UpdateUser200JSONResponse) VisitUpdateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostUpdateUserRequestObject struct {
	Body *PostUpdateUserFormdataRequestBody
}

type PostUpdateUserResponseObject interface {
	VisitPostUpdateUserResponse(w http.ResponseWriter) error
}

type PostUpdateUser200JSONResponse struct {
	EmptySubsonicResponseJSONResponse
}

func (response PostUpdateUser200JSONResponse) VisitPostUpdateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PostUpdateUser405Response = HTTPFormPostNotSupportedResponse

func (response PostUpdateUser405Response) VisitPostUpdateUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Adds a message to the chat log.
	// (GET /rest/addChatMessage)
	GetAddChatMessage(ctx context.Context, request GetAddChatMessageRequestObject) (GetAddChatMessageResponseObject, error)
	// Adds a message to the chat log.
	// (POST /rest/addChatMessage)
	PostAddChatMessage(ctx context.Context, request PostAddChatMessageRequestObject) (PostAddChatMessageResponseObject, error)
	// Changes the password of an existing user on the server.
	// (GET /rest/changePassword)
	ChangePassword(ctx context.Context, request ChangePasswordRequestObject) (ChangePasswordResponseObject, error)
	// Changes the password of an existing user on the server.
	// (POST /rest/changePassword)
	PostChangePassword(ctx context.Context, request PostChangePasswordRequestObject) (PostChangePasswordResponseObject, error)
	// Creates or updates a bookmark.
	// (GET /rest/createBookmark)
	CreateBookmark(ctx context.Context, request CreateBookmarkRequestObject) (CreateBookmarkResponseObject, error)
	// Creates or updates a bookmark.
	// (POST /rest/createBookmark)
	PostCreateBookmark(ctx context.Context, request PostCreateBookmarkRequestObject) (PostCreateBookmarkResponseObject, error)
	// Adds a new internet radio station.
	// (GET /rest/createInternetRadioStation)
	CreateInternetRadioStation(ctx context.Context, request CreateInternetRadioStationRequestObject) (CreateInternetRadioStationResponseObject, error)
	// Adds a new internet radio station.
	// (POST /rest/createInternetRadioStation)
	PostCreateInternetRadioStation(ctx context.Context, request PostCreateInternetRadioStationRequestObject) (PostCreateInternetRadioStationResponseObject, error)
	// Creates (or updates) a playlist.
	// (GET /rest/createPlaylist)
	CreatePlaylist(ctx context.Context, request CreatePlaylistRequestObject) (CreatePlaylistResponseObject, error)
	// Creates (or updates) a playlist.
	// (POST /rest/createPlaylist)
	PostCreatePlaylist(ctx context.Context, request PostCreatePlaylistRequestObject) (PostCreatePlaylistResponseObject, error)
	// Adds a new Podcast channel.
	// (GET /rest/createPodcastChannel)
	CreatePodcastChannel(ctx context.Context, request CreatePodcastChannelRequestObject) (CreatePodcastChannelResponseObject, error)
	// Adds a new Podcast channel.
	// (POST /rest/createPodcastChannel)
	PostCreatePodcastChannel(ctx context.Context, request PostCreatePodcastChannelRequestObject) (PostCreatePodcastChannelResponseObject, error)
	// Creates a public URL that can be used by anyone to stream music or video from the server.
	// (GET /rest/createShare)
	CreateShare(ctx context.Context, request CreateShareRequestObject) (CreateShareResponseObject, error)
	// Creates a public URL that can be used by anyone to stream music or video from the server.
	// (POST /rest/createShare)
	PostCreateShare(ctx context.Context, request PostCreateShareRequestObject) (PostCreateShareResponseObject, error)
	// Creates a new user on the server.
	// (GET /rest/createUser)
	CreateUser(ctx context.Context, request CreateUserRequestObject) (CreateUserResponseObject, error)
	// Creates a new user on the server.
	// (POST /rest/createUser)
	PostCreateUser(ctx context.Context, request PostCreateUserRequestObject) (PostCreateUserResponseObject, error)
	// Deletes a bookmark.
	// (GET /rest/deleteBookmark)
	DeleteBookmark(ctx context.Context, request DeleteBookmarkRequestObject) (DeleteBookmarkResponseObject, error)
	// Deletes a bookmark.
	// (POST /rest/deleteBookmark)
	PostDeleteBookmark(ctx context.Context, request PostDeleteBookmarkRequestObject) (PostDeleteBookmarkResponseObject, error)
	// Deletes an existing internet radio station.
	// (GET /rest/deleteInternetRadioStation)
	DeleteInternetRadioStation(ctx context.Context, request DeleteInternetRadioStationRequestObject) (DeleteInternetRadioStationResponseObject, error)
	// Deletes an existing internet radio station.
	// (POST /rest/deleteInternetRadioStation)
	PostDeleteInternetRadioStation(ctx context.Context, request PostDeleteInternetRadioStationRequestObject) (PostDeleteInternetRadioStationResponseObject, error)
	// Deletes a saved playlist.
	// (GET /rest/deletePlaylist)
	DeletePlaylist(ctx context.Context, request DeletePlaylistRequestObject) (DeletePlaylistResponseObject, error)
	// Deletes a saved playlist.
	// (POST /rest/deletePlaylist)
	PostDeletePlaylist(ctx context.Context, request PostDeletePlaylistRequestObject) (PostDeletePlaylistResponseObject, error)
	// Deletes a Podcast channel.
	// (GET /rest/deletePodcastChannel)
	DeletePodcastChannel(ctx context.Context, request DeletePodcastChannelRequestObject) (DeletePodcastChannelResponseObject, error)
	// Deletes a Podcast channel.
	// (POST /rest/deletePodcastChannel)
	PostDeletePodcastChannel(ctx context.Context, request PostDeletePodcastChannelRequestObject) (PostDeletePodcastChannelResponseObject, error)
	// Deletes a Podcast episode.
	// (GET /rest/deletePodcastEpisode)
	DeletePodcastEpisode(ctx context.Context, request DeletePodcastEpisodeRequestObject) (DeletePodcastEpisodeResponseObject, error)
	// Deletes a Podcast episode.
	// (POST /rest/deletePodcastEpisode)
	PostDeletePodcastEpisode(ctx context.Context, request PostDeletePodcastEpisodeRequestObject) (PostDeletePodcastEpisodeResponseObject, error)
	// Deletes an existing share.
	// (GET /rest/deleteShare)
	DeleteShare(ctx context.Context, request DeleteShareRequestObject) (DeleteShareResponseObject, error)
	// Deletes an existing share.
	// (POST /rest/deleteShare)
	PostDeleteShare(ctx context.Context, request PostDeleteShareRequestObject) (PostDeleteShareResponseObject, error)
	// Deletes an existing user on the server.
	// (GET /rest/deleteUser)
	DeleteUser(ctx context.Context, request DeleteUserRequestObject) (DeleteUserResponseObject, error)
	// Deletes an existing user on the server.
	// (POST /rest/deleteUser)
	PostDeleteUser(ctx context.Context, request PostDeleteUserRequestObject) (PostDeleteUserResponseObject, error)
	// Downloads a given media file.
	// (GET /rest/download)
	Download(ctx context.Context, request DownloadRequestObject) (DownloadResponseObject, error)
	// Downloads a given media file.
	// (POST /rest/download)
	PostDownload(ctx context.Context, request PostDownloadRequestObject) (PostDownloadResponseObject, error)
	// Request the server to start downloading a given Podcast episode.
	// (GET /rest/downloadPodcastEpisode)
	DownloadPodcastEpisode(ctx context.Context, request DownloadPodcastEpisodeRequestObject) (DownloadPodcastEpisodeResponseObject, error)
	// Request the server to start downloading a given Podcast episode.
	// (POST /rest/downloadPodcastEpisode)
	PostDownloadPodcastEpisode(ctx context.Context, request PostDownloadPodcastEpisodeRequestObject) (PostDownloadPodcastEpisodeResponseObject, error)
	// Returns details for an album.
	// (GET /rest/getAlbum)
	GetAlbum(ctx context.Context, request GetAlbumRequestObject) (GetAlbumResponseObject, error)
	// Returns details for an album.
	// (POST /rest/getAlbum)
	PostGetAlbum(ctx context.Context, request PostGetAlbumRequestObject) (PostGetAlbumResponseObject, error)
	// Returns album info.
	// (GET /rest/getAlbumInfo)
	GetAlbumInfo(ctx context.Context, request GetAlbumInfoRequestObject) (GetAlbumInfoResponseObject, error)
	// Returns album info.
	// (POST /rest/getAlbumInfo)
	PostGetAlbumInfo(ctx context.Context, request PostGetAlbumInfoRequestObject) (PostGetAlbumInfoResponseObject, error)
	// Returns album info (v2).
	// (GET /rest/getAlbumInfo2)
	GetAlbumInfo2(ctx context.Context, request GetAlbumInfo2RequestObject) (GetAlbumInfo2ResponseObject, error)
	// Returns album info (v2).
	// (POST /rest/getAlbumInfo2)
	PostGetAlbumInfo2(ctx context.Context, request PostGetAlbumInfo2RequestObject) (PostGetAlbumInfo2ResponseObject, error)
	// Returns a list of random, newest, highest rated etc. albums.
	// (GET /rest/getAlbumList)
	GetAlbumList(ctx context.Context, request GetAlbumListRequestObject) (GetAlbumListResponseObject, error)
	// Returns a list of random, newest, highest rated etc. albums.
	// (POST /rest/getAlbumList)
	PostGetAlbumList(ctx context.Context, request PostGetAlbumListRequestObject) (PostGetAlbumListResponseObject, error)
	// Returns a list of random, newest, highest rated etc. albums (v2).
	// (GET /rest/getAlbumList2)
	GetAlbumList2(ctx context.Context, request GetAlbumList2RequestObject) (GetAlbumList2ResponseObject, error)
	// Returns a list of random, newest, highest rated etc. albums (v2).
	// (POST /rest/getAlbumList2)
	PostGetAlbumList2(ctx context.Context, request PostGetAlbumList2RequestObject) (PostGetAlbumList2ResponseObject, error)
	// Returns details for an artist.
	// (GET /rest/getArtist)
	GetArtist(ctx context.Context, request GetArtistRequestObject) (GetArtistResponseObject, error)
	// Returns details for an artist.
	// (POST /rest/getArtist)
	PostGetArtist(ctx context.Context, request PostGetArtistRequestObject) (PostGetArtistResponseObject, error)
	// Returns artist info.
	// (GET /rest/getArtistInfo)
	GetArtistInfo(ctx context.Context, request GetArtistInfoRequestObject) (GetArtistInfoResponseObject, error)
	// Returns artist info.
	// (POST /rest/getArtistInfo)
	PostGetArtistInfo(ctx context.Context, request PostGetArtistInfoRequestObject) (PostGetArtistInfoResponseObject, error)
	// Returns artist info (v2).
	// (GET /rest/getArtistInfo2)
	GetArtistInfo2(ctx context.Context, request GetArtistInfo2RequestObject) (GetArtistInfo2ResponseObject, error)
	// Returns artist info (v2).
	// (POST /rest/getArtistInfo2)
	PostGetArtistInfo2(ctx context.Context, request PostGetArtistInfo2RequestObject) (PostGetArtistInfo2ResponseObject, error)
	// Returns all artists.
	// (GET /rest/getArtists)
	GetArtists(ctx context.Context, request GetArtistsRequestObject) (GetArtistsResponseObject, error)
	// Returns all artists.
	// (POST /rest/getArtists)
	PostGetArtists(ctx context.Context, request PostGetArtistsRequestObject) (PostGetArtistsResponseObject, error)
	// Returns the avatar (personal image) for a user.
	// (GET /rest/getAvatar)
	GetAvatar(ctx context.Context, request GetAvatarRequestObject) (GetAvatarResponseObject, error)
	// Returns the avatar (personal image) for a user.
	// (POST /rest/getAvatar)
	PostGetAvatar(ctx context.Context, request PostGetAvatarRequestObject) (PostGetAvatarResponseObject, error)
	// Returns all bookmarks for this user.
	// (GET /rest/getBookmarks)
	GetBookmarks(ctx context.Context, request GetBookmarksRequestObject) (GetBookmarksResponseObject, error)
	// Returns all bookmarks for this user.
	// (POST /rest/getBookmarks)
	PostGetBookmarks(ctx context.Context, request PostGetBookmarksRequestObject) (PostGetBookmarksResponseObject, error)
	// Returns captions (subtitles) for a video.
	// (GET /rest/getCaptions)
	GetCaptions(ctx context.Context, request GetCaptionsRequestObject) (GetCaptionsResponseObject, error)
	// Returns captions (subtitles) for a video.
	// (POST /rest/getCaptions)
	PostGetCaptions(ctx context.Context, request PostGetCaptionsRequestObject) (PostGetCaptionsResponseObject, error)
	// Returns the current visible (non-expired) chat messages.
	// (GET /rest/getChatMessages)
	GetChatMessages(ctx context.Context, request GetChatMessagesRequestObject) (GetChatMessagesResponseObject, error)
	// Returns the current visible (non-expired) chat messages.
	// (POST /rest/getChatMessages)
	PostGetChatMessages(ctx context.Context, request PostGetChatMessagesRequestObject) (PostGetChatMessagesResponseObject, error)
	// Returns a cover art image.
	// (GET /rest/getCoverArt)
	GetCoverArt(ctx context.Context, request GetCoverArtRequestObject) (GetCoverArtResponseObject, error)
	// Returns a cover art image.
	// (POST /rest/getCoverArt)
	PostGetCoverArt(ctx context.Context, request PostGetCoverArtRequestObject) (PostGetCoverArtResponseObject, error)
	// Returns all genres.
	// (GET /rest/getGenres)
	GetGenres(ctx context.Context, request GetGenresRequestObject) (GetGenresResponseObject, error)
	// Returns all genres.
	// (POST /rest/getGenres)
	PostGetGenres(ctx context.Context, request PostGetGenresRequestObject) (PostGetGenresResponseObject, error)
	// Returns an indexed structure of all artists.
	// (GET /rest/getIndexes)
	GetIndexes(ctx context.Context, request GetIndexesRequestObject) (GetIndexesResponseObject, error)
	// Returns an indexed structure of all artists.
	// (POST /rest/getIndexes)
	PostGetIndexes(ctx context.Context, request PostGetIndexesRequestObject) (PostGetIndexesResponseObject, error)
	// Returns all internet radio stations.
	// (GET /rest/getInternetRadioStations)
	GetInternetRadioStations(ctx context.Context, request GetInternetRadioStationsRequestObject) (GetInternetRadioStationsResponseObject, error)
	// Returns all internet radio stations.
	// (POST /rest/getInternetRadioStations)
	PostGetInternetRadioStations(ctx context.Context, request PostGetInternetRadioStationsRequestObject) (PostGetInternetRadioStationsResponseObject, error)
	// Get details about the software license.
	// (GET /rest/getLicense)
	GetLicense(ctx context.Context, request GetLicenseRequestObject) (GetLicenseResponseObject, error)
	// Get details about the software license.
	// (POST /rest/getLicense)
	PostGetLicense(ctx context.Context, request PostGetLicenseRequestObject) (PostGetLicenseResponseObject, error)
	// Searches for and returns lyrics for a given song.
	// (GET /rest/getLyrics)
	GetLyrics(ctx context.Context, request GetLyricsRequestObject) (GetLyricsResponseObject, error)
	// Searches for and returns lyrics for a given song.
	// (POST /rest/getLyrics)
	PostGetLyrics(ctx context.Context, request PostGetLyricsRequestObject) (PostGetLyricsResponseObject, error)
	// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
	// (GET /rest/getLyricsBySongId)
	GetLyricsBySongId(ctx context.Context, request GetLyricsBySongIdRequestObject) (GetLyricsBySongIdResponseObject, error)
	// Add support for synchronized lyrics, multiple languages, and retrieval by song ID.
	// (POST /rest/getLyricsBySongId)
	PostGetLyricsBySongId(ctx context.Context, request PostGetLyricsBySongIdRequestObject) (PostGetLyricsBySongIdResponseObject, error)
	// Returns a listing of all files in a music directory.
	// (GET /rest/getMusicDirectory)
	GetMusicDirectory(ctx context.Context, request GetMusicDirectoryRequestObject) (GetMusicDirectoryResponseObject, error)
	// Returns a listing of all files in a music directory.
	// (POST /rest/getMusicDirectory)
	PostGetMusicDirectory(ctx context.Context, request PostGetMusicDirectoryRequestObject) (PostGetMusicDirectoryResponseObject, error)
	// Returns all configured top-level music folders.
	// (GET /rest/getMusicFolders)
	GetMusicFolders(ctx context.Context, request GetMusicFoldersRequestObject) (GetMusicFoldersResponseObject, error)
	// Returns all configured top-level music folders.
	// (POST /rest/getMusicFolders)
	PostGetMusicFolders(ctx context.Context, request PostGetMusicFoldersRequestObject) (PostGetMusicFoldersResponseObject, error)
	// Returns the most recently published Podcast episodes.
	// (GET /rest/getNewestPodcasts)
	GetNewestPodcasts(ctx context.Context, request GetNewestPodcastsRequestObject) (GetNewestPodcastsResponseObject, error)
	// Returns the most recently published Podcast episodes.
	// (POST /rest/getNewestPodcasts)
	PostGetNewestPodcasts(ctx context.Context, request PostGetNewestPodcastsRequestObject) (PostGetNewestPodcastsResponseObject, error)
	// Returns what is currently being played by all users.
	// (GET /rest/getNowPlaying)
	GetNowPlaying(ctx context.Context, request GetNowPlayingRequestObject) (GetNowPlayingResponseObject, error)
	// Returns what is currently being played by all users.
	// (POST /rest/getNowPlaying)
	PostGetNowPlaying(ctx context.Context, request PostGetNowPlayingRequestObject) (PostGetNowPlayingResponseObject, error)
	// List the OpenSubsonic extensions supported by this server.
	// (GET /rest/getOpenSubsonicExtensions)
	GetOpenSubsonicExtensions(ctx context.Context, request GetOpenSubsonicExtensionsRequestObject) (GetOpenSubsonicExtensionsResponseObject, error)
	// List the OpenSubsonic extensions supported by this server.
	// (POST /rest/getOpenSubsonicExtensions)
	PostGetOpenSubsonicExtensions(ctx context.Context, request PostGetOpenSubsonicExtensionsRequestObject) (PostGetOpenSubsonicExtensionsResponseObject, error)
	// Returns the state of the play queue for this user.
	// (GET /rest/getPlayQueue)
	GetPlayQueue(ctx context.Context, request GetPlayQueueRequestObject) (GetPlayQueueResponseObject, error)
	// Returns the state of the play queue for this user.
	// (POST /rest/getPlayQueue)
	PostGetPlayQueue(ctx context.Context, request PostGetPlayQueueRequestObject) (PostGetPlayQueueResponseObject, error)
	// Returns the state of the play queue for this user, using queue index.
	// (GET /rest/getPlayQueueByIndex)
	GetPlayQueueByIndex(ctx context.Context, request GetPlayQueueByIndexRequestObject) (GetPlayQueueByIndexResponseObject, error)
	// Returns the state of the play queue for this user.
	// (POST /rest/getPlayQueueByIndex)
	PostGetPlayQueueByIndex(ctx context.Context, request PostGetPlayQueueByIndexRequestObject) (PostGetPlayQueueByIndexResponseObject, error)
	// Returns a listing of files in a saved playlist.
	// (GET /rest/getPlaylist)
	GetPlaylist(ctx context.Context, request GetPlaylistRequestObject) (GetPlaylistResponseObject, error)
	// Returns a listing of files in a saved playlist.
	// (POST /rest/getPlaylist)
	PostGetPlaylist(ctx context.Context, request PostGetPlaylistRequestObject) (PostGetPlaylistResponseObject, error)
	// Returns all playlists a user is allowed to play.
	// (GET /rest/getPlaylists)
	GetPlaylists(ctx context.Context, request GetPlaylistsRequestObject) (GetPlaylistsResponseObject, error)
	// Returns all playlists a user is allowed to play.
	// (POST /rest/getPlaylists)
	PostGetPlaylists(ctx context.Context, request PostGetPlaylistsRequestObject) (PostGetPlaylistsResponseObject, error)
	// Returns details for a podcast episode.
	// (GET /rest/getPodcastEpisode)
	GetPodcastEpisode(ctx context.Context, request GetPodcastEpisodeRequestObject) (GetPodcastEpisodeResponseObject, error)
	// Returns details for a podcast episode.
	// (POST /rest/getPodcastEpisode)
	PostGetPodcastEpisode(ctx context.Context, request PostGetPodcastEpisodeRequestObject) (PostGetPodcastEpisodeResponseObject, error)
	// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
	// (GET /rest/getPodcasts)
	GetPodcasts(ctx context.Context, request GetPodcastsRequestObject) (GetPodcastsResponseObject, error)
	// Returns all Podcast channels the server subscribes to, and (optionally) their episodes.
	// (POST /rest/getPodcasts)
	PostGetPodcasts(ctx context.Context, request PostGetPodcastsRequestObject) (PostGetPodcastsResponseObject, error)
	// Returns random songs matching the given criteria.
	// (GET /rest/getRandomSongs)
	GetRandomSongs(ctx context.Context, request GetRandomSongsRequestObject) (GetRandomSongsResponseObject, error)
	// Returns random songs matching the given criteria.
	// (POST /rest/getRandomSongs)
	PostGetRandomSongs(ctx context.Context, request PostGetRandomSongsRequestObject) (PostGetRandomSongsResponseObject, error)
	// Returns the current status for media library scanning.
	// (GET /rest/getScanStatus)
	GetScanStatus(ctx context.Context, request GetScanStatusRequestObject) (GetScanStatusResponseObject, error)
	// Returns the current status for media library scanning.
	// (POST /rest/getScanStatus)
	PostGetScanStatus(ctx context.Context, request PostGetScanStatusRequestObject) (PostGetScanStatusResponseObject, error)
	// Returns information about shared media this user is allowed to manage.
	// (GET /rest/getShares)
	GetShares(ctx context.Context, request GetSharesRequestObject) (GetSharesResponseObject, error)
	// Returns information about shared media this user is allowed to manage.
	// (POST /rest/getShares)
	PostGetShares(ctx context.Context, request PostGetSharesRequestObject) (PostGetSharesResponseObject, error)
	// Returns a random collection of songs from the given artist and similar artists.
	// (GET /rest/getSimilarSongs)
	GetSimilarSongs(ctx context.Context, request GetSimilarSongsRequestObject) (GetSimilarSongsResponseObject, error)
	// Returns a random collection of songs from the given artist and similar artists.
	// (POST /rest/getSimilarSongs)
	PostGetSimilarSongs(ctx context.Context, request PostGetSimilarSongsRequestObject) (PostGetSimilarSongsResponseObject, error)
	// Returns a random collection of songs from the given artist and similar artists (v2).
	// (GET /rest/getSimilarSongs2)
	GetSimilarSongs2(ctx context.Context, request GetSimilarSongs2RequestObject) (GetSimilarSongs2ResponseObject, error)
	// Returns a random collection of songs from the given artist and similar artists (v2).
	// (POST /rest/getSimilarSongs2)
	PostGetSimilarSongs2(ctx context.Context, request PostGetSimilarSongs2RequestObject) (PostGetSimilarSongs2ResponseObject, error)
	// Returns details for a song.
	// (GET /rest/getSong)
	GetSong(ctx context.Context, request GetSongRequestObject) (GetSongResponseObject, error)
	// Returns details for a song.
	// (POST /rest/getSong)
	PostGetSong(ctx context.Context, request PostGetSongRequestObject) (PostGetSongResponseObject, error)
	// Returns songs in a given genre.
	// (GET /rest/getSongsByGenre)
	GetSongsByGenre(ctx context.Context, request GetSongsByGenreRequestObject) (GetSongsByGenreResponseObject, error)
	// Returns songs in a given genre.
	// (POST /rest/getSongsByGenre)
	PostGetSongsByGenre(ctx context.Context, request PostGetSongsByGenreRequestObject) (PostGetSongsByGenreResponseObject, error)
	// Returns starred songs, albums and artists.
	// (GET /rest/getStarred)
	GetStarred(ctx context.Context, request GetStarredRequestObject) (GetStarredResponseObject, error)
	// Returns starred songs, albums and artists.
	// (POST /rest/getStarred)
	PostGetStarred(ctx context.Context, request PostGetStarredRequestObject) (PostGetStarredResponseObject, error)
	// Returns starred songs, albums and artists.
	// (GET /rest/getStarred2)
	GetStarred2(ctx context.Context, request GetStarred2RequestObject) (GetStarred2ResponseObject, error)
	// Returns starred songs, albums and artists.
	// (POST /rest/getStarred2)
	PostGetStarred2(ctx context.Context, request PostGetStarred2RequestObject) (PostGetStarred2ResponseObject, error)
	// Returns top songs for the given artist.
	// (GET /rest/getTopSongs)
	GetTopSongs(ctx context.Context, request GetTopSongsRequestObject) (GetTopSongsResponseObject, error)
	// Returns top songs for the given artist.
	// (POST /rest/getTopSongs)
	PostGetTopSongs(ctx context.Context, request PostGetTopSongsRequestObject) (PostGetTopSongsResponseObject, error)
	// Get Transcode Decision
	// (POST /rest/getTranscodeDecision)
	GetTranscodeDecision(ctx context.Context, request GetTranscodeDecisionRequestObject) (GetTranscodeDecisionResponseObject, error)
	// Get Transcoded Stream
	// (GET /rest/getTranscodeStream)
	GetTranscodeStream(ctx context.Context, request GetTranscodeStreamRequestObject) (GetTranscodeStreamResponseObject, error)
	// Get details about a given user, including which authorization roles and folder access it has.
	// (GET /rest/getUser)
	GetUser(ctx context.Context, request GetUserRequestObject) (GetUserResponseObject, error)
	// Get details about a given user, including which authorization roles and folder access it has.
	// (POST /rest/getUser)
	PostGetUser(ctx context.Context, request PostGetUserRequestObject) (PostGetUserResponseObject, error)
	// Get details about all users, including which authorization roles and folder access they have
	// (GET /rest/getUsers)
	GetUsers(ctx context.Context, request GetUsersRequestObject) (GetUsersResponseObject, error)
	// Get details about all users, including which authorization roles and folder access they have
	// (POST /rest/getUsers)
	PostGetUsers(ctx context.Context, request PostGetUsersRequestObject) (PostGetUsersResponseObject, error)
	// Returns details for a video.
	// (GET /rest/getVideoInfo)
	GetVideoInfo(ctx context.Context, request GetVideoInfoRequestObject) (GetVideoInfoResponseObject, error)
	// Returns details for a video.
	// (POST /rest/getVideoInfo)
	PostGetVideoInfo(ctx context.Context, request PostGetVideoInfoRequestObject) (PostGetVideoInfoResponseObject, error)
	// Returns all video files.
	// (GET /rest/getVideos)
	GetVideos(ctx context.Context, request GetVideosRequestObject) (GetVideosResponseObject, error)
	// Returns all video files.
	// (POST /rest/getVideos)
	PostGetVideos(ctx context.Context, request PostGetVideosRequestObject) (PostGetVideosResponseObject, error)
	// Downloads a given media file (HLS).
	// (GET /rest/hls.m3u8)
	HlsM3u8(ctx context.Context, request HlsM3u8RequestObject) (HlsM3u8ResponseObject, error)
	// Downloads a given media file (HLS).
	// (POST /rest/hls.m3u8)
	PostHlsM3u8(ctx context.Context, request PostHlsM3u8RequestObject) (PostHlsM3u8ResponseObject, error)
	// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
	// (GET /rest/jukeboxControl)
	JukeboxControl(ctx context.Context, request JukeboxControlRequestObject) (JukeboxControlResponseObject, error)
	// Controls the jukebox, i.e., playback directly on the server’s audio hardware.
	// (POST /rest/jukeboxControl)
	PostJukeboxControl(ctx context.Context, request PostJukeboxControlRequestObject) (PostJukeboxControlResponseObject, error)
	// Used to test connectivity with the server.
	// (GET /rest/ping)
	Ping(ctx context.Context, request PingRequestObject) (PingResponseObject, error)
	// Used to test connectivity with the server.
	// (POST /rest/ping)
	PostPing(ctx context.Context, request PostPingRequestObject) (PostPingResponseObject, error)
	// Requests the server to check for new Podcast episodes.
	// (GET /rest/refreshPodcasts)
	RefreshPodcasts(ctx context.Context, request RefreshPodcastsRequestObject) (RefreshPodcastsResponseObject, error)
	// Requests the server to check for new Podcast episodes.
	// (POST /rest/refreshPodcasts)
	PostRefreshPodcasts(ctx context.Context, request PostRefreshPodcastsRequestObject) (PostRefreshPodcastsResponseObject, error)
	// Saves the state of the play queue for this user.
	// (GET /rest/savePlayQueue)
	SavePlayQueue(ctx context.Context, request SavePlayQueueRequestObject) (SavePlayQueueResponseObject, error)
	// Saves the state of the play queue for this user.
	// (POST /rest/savePlayQueue)
	PostSavePlayQueue(ctx context.Context, request PostSavePlayQueueRequestObject) (PostSavePlayQueueResponseObject, error)
	// Saves the state of the play queue for this user, using queue index.
	// (GET /rest/savePlayQueueByIndex)
	SavePlayQueueByIndex(ctx context.Context, request SavePlayQueueByIndexRequestObject) (SavePlayQueueByIndexResponseObject, error)
	// Saves the state of the play queue for this user.
	// (POST /rest/savePlayQueueByIndex)
	PostSavePlayQueueByIndex(ctx context.Context, request PostSavePlayQueueByIndexRequestObject) (PostSavePlayQueueByIndexResponseObject, error)
	// Registers the local playback of one or more media files.
	// (GET /rest/scrobble)
	Scrobble(ctx context.Context, request ScrobbleRequestObject) (ScrobbleResponseObject, error)
	// Registers the local playback of one or more media files.
	// (POST /rest/scrobble)
	PostScrobble(ctx context.Context, request PostScrobbleRequestObject) (PostScrobbleResponseObject, error)
	// Returns a listing of files matching the given search criteria. Supports paging through the result.
	// (GET /rest/search)
	Search(ctx context.Context, request SearchRequestObject) (SearchResponseObject, error)
	// Returns a listing of files matching the given search criteria. Supports paging through the result.
	// (POST /rest/search)
	PostSearch(ctx context.Context, request PostSearchRequestObject) (PostSearchResponseObject, error)
	// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
	// (GET /rest/search2)
	Search2(ctx context.Context, request Search2RequestObject) (Search2ResponseObject, error)
	// Returns a listing of files matching the given search criteria. Supports paging through the result. (v2)
	// (POST /rest/search2)
	PostSearch2(ctx context.Context, request PostSearch2RequestObject) (PostSearch2ResponseObject, error)
	// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
	// (GET /rest/search3)
	Search3(ctx context.Context, request Search3RequestObject) (Search3ResponseObject, error)
	// Returns albums, artists and songs matching the given search criteria. Supports paging through the result. (v3)
	// (POST /rest/search3)
	PostSearch3(ctx context.Context, request PostSearch3RequestObject) (PostSearch3ResponseObject, error)
	// Sets the rating for a music file.
	// (GET /rest/setRating)
	SetRating(ctx context.Context, request SetRatingRequestObject) (SetRatingResponseObject, error)
	// Sets the rating for a music file.
	// (POST /rest/setRating)
	PostSetRating(ctx context.Context, request PostSetRatingRequestObject) (PostSetRatingResponseObject, error)
	// Attaches a star to a song, album or artist.
	// (GET /rest/star)
	Star(ctx context.Context, request StarRequestObject) (StarResponseObject, error)
	// Attaches a star to a song, album or artist.
	// (POST /rest/star)
	PostStar(ctx context.Context, request PostStarRequestObject) (PostStarResponseObject, error)
	// Initiates a rescan of the media libraries.
	// (GET /rest/startScan)
	StartScan(ctx context.Context, request StartScanRequestObject) (StartScanResponseObject, error)
	// Initiates a rescan of the media libraries.
	// (POST /rest/startScan)
	PostStartScan(ctx context.Context, request PostStartScanRequestObject) (PostStartScanResponseObject, error)
	// Streams a given media file.
	// (GET /rest/stream)
	Stream(ctx context.Context, request StreamRequestObject) (StreamResponseObject, error)
	// Streams a given media file.
	// (POST /rest/stream)
	PostStream(ctx context.Context, request PostStreamRequestObject) (PostStreamResponseObject, error)
	// Returns information about an API key
	// (GET /rest/tokenInfo)
	TokenInfo(ctx context.Context, request TokenInfoRequestObject) (TokenInfoResponseObject, error)
	// Returns information about an API key
	// (POST /rest/tokenInfo)
	PostTokenInfo(ctx context.Context, request PostTokenInfoRequestObject) (PostTokenInfoResponseObject, error)
	// Removes a star to a song, album or artist.
	// (GET /rest/unstar)
	Unstar(ctx context.Context, request UnstarRequestObject) (UnstarResponseObject, error)
	// Removes a star to a song, album or artist.
	// (POST /rest/unstar)
	PostUnstar(ctx context.Context, request PostUnstarRequestObject) (PostUnstarResponseObject, error)
	// Updates an existing internet radio station.
	// (GET /rest/updateInternetRadioStation)
	UpdateInternetRadioStation(ctx context.Context, request UpdateInternetRadioStationRequestObject) (UpdateInternetRadioStationResponseObject, error)
	// Updates an existing internet radio station.
	// (POST /rest/updateInternetRadioStation)
	PostUpdateInternetRadioStation(ctx context.Context, request PostUpdateInternetRadioStationRequestObject) (PostUpdateInternetRadioStationResponseObject, error)
	// Updates a playlist. Only the owner of a playlist is allowed to update it.
	// (GET /rest/updatePlaylist)
	UpdatePlaylist(ctx context.Context, request UpdatePlaylistRequestObject) (UpdatePlaylistResponseObject, error)
	// Updates a playlist. Only the owner of a playlist is allowed to update it.
	// (POST /rest/updatePlaylist)
	PostUpdatePlaylist(ctx context.Context, request PostUpdatePlaylistRequestObject) (PostUpdatePlaylistResponseObject, error)
	// Updates the description and/or expiration date for an existing share.
	// (GET /rest/updateShare)
	UpdateShare(ctx context.Context, request UpdateShareRequestObject) (UpdateShareResponseObject, error)
	// Updates the description and/or expiration date for an existing share.
	// (POST /rest/updateShare)
	PostUpdateShare(ctx context.Context, request PostUpdateShareRequestObject) (PostUpdateShareResponseObject, error)
	// Modifies an existing user on the server.
	// (GET /rest/updateUser)
	UpdateUser(ctx context.Context, request UpdateUserRequestObject) (UpdateUserResponseObject, error)
	// Modifies an existing user on the server.
	// (POST /rest/updateUser)
	PostUpdateUser(ctx context.Context, request PostUpdateUserRequestObject) (PostUpdateUserResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// GetAddChatMessage operation middleware
func (sh *strictHandler) GetAddChatMessage(w http.ResponseWriter, r *http.Request, params GetAddChatMessageParams) {
	var request GetAddChatMessageRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAddChatMessage(ctx, request.(GetAddChatMessageRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAddChatMessage")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAddChatMessageResponseObject); ok {
		if err := validResponse.VisitGetAddChatMessageResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostAddChatMessage operation middleware
func (sh *strictHandler) PostAddChatMessage(w http.ResponseWriter, r *http.Request) {
	var request PostAddChatMessageRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostAddChatMessageFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostAddChatMessage(ctx, request.(PostAddChatMessageRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostAddChatMessage")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostAddChatMessageResponseObject); ok {
		if err := validResponse.VisitPostAddChatMessageResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ChangePassword operation middleware
func (sh *strictHandler) ChangePassword(w http.ResponseWriter, r *http.Request, params ChangePasswordParams) {
	var request ChangePasswordRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ChangePassword(ctx, request.(ChangePasswordRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ChangePassword")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ChangePasswordResponseObject); ok {
		if err := validResponse.VisitChangePasswordResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostChangePassword operation middleware
func (sh *strictHandler) PostChangePassword(w http.ResponseWriter, r *http.Request) {
	var request PostChangePasswordRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostChangePasswordFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostChangePassword(ctx, request.(PostChangePasswordRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostChangePassword")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostChangePasswordResponseObject); ok {
		if err := validResponse.VisitPostChangePasswordResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateBookmark operation middleware
func (sh *strictHandler) CreateBookmark(w http.ResponseWriter, r *http.Request, params CreateBookmarkParams) {
	var request CreateBookmarkRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateBookmark(ctx, request.(CreateBookmarkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateBookmark")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateBookmarkResponseObject); ok {
		if err := validResponse.VisitCreateBookmarkResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostCreateBookmark operation middleware
func (sh *strictHandler) PostCreateBookmark(w http.ResponseWriter, r *http.Request) {
	var request PostCreateBookmarkRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostCreateBookmarkFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostCreateBookmark(ctx, request.(PostCreateBookmarkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostCreateBookmark")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostCreateBookmarkResponseObject); ok {
		if err := validResponse.VisitPostCreateBookmarkResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateInternetRadioStation operation middleware
func (sh *strictHandler) CreateInternetRadioStation(w http.ResponseWriter, r *http.Request, params CreateInternetRadioStationParams) {
	var request CreateInternetRadioStationRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateInternetRadioStation(ctx, request.(CreateInternetRadioStationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateInternetRadioStation")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateInternetRadioStationResponseObject); ok {
		if err := validResponse.VisitCreateInternetRadioStationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostCreateInternetRadioStation operation middleware
func (sh *strictHandler) PostCreateInternetRadioStation(w http.ResponseWriter, r *http.Request) {
	var request PostCreateInternetRadioStationRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostCreateInternetRadioStationFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostCreateInternetRadioStation(ctx, request.(PostCreateInternetRadioStationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostCreateInternetRadioStation")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostCreateInternetRadioStationResponseObject); ok {
		if err := validResponse.VisitPostCreateInternetRadioStationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreatePlaylist operation middleware
func (sh *strictHandler) CreatePlaylist(w http.ResponseWriter, r *http.Request, params CreatePlaylistParams) {
	var request CreatePlaylistRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePlaylist(ctx, request.(CreatePlaylistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePlaylist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreatePlaylistResponseObject); ok {
		if err := validResponse.VisitCreatePlaylistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostCreatePlaylist operation middleware
func (sh *strictHandler) PostCreatePlaylist(w http.ResponseWriter, r *http.Request) {
	var request PostCreatePlaylistRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostCreatePlaylistFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostCreatePlaylist(ctx, request.(PostCreatePlaylistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostCreatePlaylist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostCreatePlaylistResponseObject); ok {
		if err := validResponse.VisitPostCreatePlaylistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreatePodcastChannel operation middleware
func (sh *strictHandler) CreatePodcastChannel(w http.ResponseWriter, r *http.Request, params CreatePodcastChannelParams) {
	var request CreatePodcastChannelRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePodcastChannel(ctx, request.(CreatePodcastChannelRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePodcastChannel")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreatePodcastChannelResponseObject); ok {
		if err := validResponse.VisitCreatePodcastChannelResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostCreatePodcastChannel operation middleware
func (sh *strictHandler) PostCreatePodcastChannel(w http.ResponseWriter, r *http.Request) {
	var request PostCreatePodcastChannelRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostCreatePodcastChannelFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostCreatePodcastChannel(ctx, request.(PostCreatePodcastChannelRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostCreatePodcastChannel")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostCreatePodcastChannelResponseObject); ok {
		if err := validResponse.VisitPostCreatePodcastChannelResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateShare operation middleware
func (sh *strictHandler) CreateShare(w http.ResponseWriter, r *http.Request, params CreateShareParams) {
	var request CreateShareRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateShare(ctx, request.(CreateShareRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateShare")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateShareResponseObject); ok {
		if err := validResponse.VisitCreateShareResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostCreateShare operation middleware
func (sh *strictHandler) PostCreateShare(w http.ResponseWriter, r *http.Request) {
	var request PostCreateShareRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostCreateShareFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostCreateShare(ctx, request.(PostCreateShareRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostCreateShare")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostCreateShareResponseObject); ok {
		if err := validResponse.VisitPostCreateShareResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateUser operation middleware
func (sh *strictHandler) CreateUser(w http.ResponseWriter, r *http.Request, params CreateUserParams) {
	var request CreateUserRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateUser(ctx, request.(CreateUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateUserResponseObject); ok {
		if err := validResponse.VisitCreateUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostCreateUser operation middleware
func (sh *strictHandler) PostCreateUser(w http.ResponseWriter, r *http.Request) {
	var request PostCreateUserRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostCreateUserFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostCreateUser(ctx, request.(PostCreateUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostCreateUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostCreateUserResponseObject); ok {
		if err := validResponse.VisitPostCreateUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteBookmark operation middleware
func (sh *strictHandler) DeleteBookmark(w http.ResponseWriter, r *http.Request, params DeleteBookmarkParams) {
	var request DeleteBookmarkRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteBookmark(ctx, request.(DeleteBookmarkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteBookmark")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteBookmarkResponseObject); ok {
		if err := validResponse.VisitDeleteBookmarkResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostDeleteBookmark operation middleware
func (sh *strictHandler) PostDeleteBookmark(w http.ResponseWriter, r *http.Request) {
	var request PostDeleteBookmarkRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostDeleteBookmarkFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostDeleteBookmark(ctx, request.(PostDeleteBookmarkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostDeleteBookmark")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostDeleteBookmarkResponseObject); ok {
		if err := validResponse.VisitPostDeleteBookmarkResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteInternetRadioStation operation middleware
func (sh *strictHandler) DeleteInternetRadioStation(w http.ResponseWriter, r *http.Request, params DeleteInternetRadioStationParams) {
	var request DeleteInternetRadioStationRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteInternetRadioStation(ctx, request.(DeleteInternetRadioStationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteInternetRadioStation")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteInternetRadioStationResponseObject); ok {
		if err := validResponse.VisitDeleteInternetRadioStationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostDeleteInternetRadioStation operation middleware
func (sh *strictHandler) PostDeleteInternetRadioStation(w http.ResponseWriter, r *http.Request) {
	var request PostDeleteInternetRadioStationRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostDeleteInternetRadioStationFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostDeleteInternetRadioStation(ctx, request.(PostDeleteInternetRadioStationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostDeleteInternetRadioStation")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostDeleteInternetRadioStationResponseObject); ok {
		if err := validResponse.VisitPostDeleteInternetRadioStationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeletePlaylist operation middleware
func (sh *strictHandler) DeletePlaylist(w http.ResponseWriter, r *http.Request, params DeletePlaylistParams) {
	var request DeletePlaylistRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeletePlaylist(ctx, request.(DeletePlaylistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeletePlaylist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeletePlaylistResponseObject); ok {
		if err := validResponse.VisitDeletePlaylistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostDeletePlaylist operation middleware
func (sh *strictHandler) PostDeletePlaylist(w http.ResponseWriter, r *http.Request) {
	var request PostDeletePlaylistRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostDeletePlaylistFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostDeletePlaylist(ctx, request.(PostDeletePlaylistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostDeletePlaylist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostDeletePlaylistResponseObject); ok {
		if err := validResponse.VisitPostDeletePlaylistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeletePodcastChannel operation middleware
func (sh *strictHandler) DeletePodcastChannel(w http.ResponseWriter, r *http.Request, params DeletePodcastChannelParams) {
	var request DeletePodcastChannelRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeletePodcastChannel(ctx, request.(DeletePodcastChannelRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeletePodcastChannel")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeletePodcastChannelResponseObject); ok {
		if err := validResponse.VisitDeletePodcastChannelResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostDeletePodcastChannel operation middleware
func (sh *strictHandler) PostDeletePodcastChannel(w http.ResponseWriter, r *http.Request) {
	var request PostDeletePodcastChannelRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostDeletePodcastChannelFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostDeletePodcastChannel(ctx, request.(PostDeletePodcastChannelRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostDeletePodcastChannel")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostDeletePodcastChannelResponseObject); ok {
		if err := validResponse.VisitPostDeletePodcastChannelResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeletePodcastEpisode operation middleware
func (sh *strictHandler) DeletePodcastEpisode(w http.ResponseWriter, r *http.Request, params DeletePodcastEpisodeParams) {
	var request DeletePodcastEpisodeRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeletePodcastEpisode(ctx, request.(DeletePodcastEpisodeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeletePodcastEpisode")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeletePodcastEpisodeResponseObject); ok {
		if err := validResponse.VisitDeletePodcastEpisodeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostDeletePodcastEpisode operation middleware
func (sh *strictHandler) PostDeletePodcastEpisode(w http.ResponseWriter, r *http.Request) {
	var request PostDeletePodcastEpisodeRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostDeletePodcastEpisodeFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostDeletePodcastEpisode(ctx, request.(PostDeletePodcastEpisodeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostDeletePodcastEpisode")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostDeletePodcastEpisodeResponseObject); ok {
		if err := validResponse.VisitPostDeletePodcastEpisodeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteShare operation middleware
func (sh *strictHandler) DeleteShare(w http.ResponseWriter, r *http.Request, params DeleteShareParams) {
	var request DeleteShareRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteShare(ctx, request.(DeleteShareRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteShare")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteShareResponseObject); ok {
		if err := validResponse.VisitDeleteShareResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostDeleteShare operation middleware
func (sh *strictHandler) PostDeleteShare(w http.ResponseWriter, r *http.Request) {
	var request PostDeleteShareRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostDeleteShareFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostDeleteShare(ctx, request.(PostDeleteShareRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostDeleteShare")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostDeleteShareResponseObject); ok {
		if err := validResponse.VisitPostDeleteShareResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteUser operation middleware
func (sh *strictHandler) DeleteUser(w http.ResponseWriter, r *http.Request, params DeleteUserParams) {
	var request DeleteUserRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteUser(ctx, request.(DeleteUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteUserResponseObject); ok {
		if err := validResponse.VisitDeleteUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostDeleteUser operation middleware
func (sh *strictHandler) PostDeleteUser(w http.ResponseWriter, r *http.Request) {
	var request PostDeleteUserRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostDeleteUserFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostDeleteUser(ctx, request.(PostDeleteUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostDeleteUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostDeleteUserResponseObject); ok {
		if err := validResponse.VisitPostDeleteUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Download operation middleware
func (sh *strictHandler) Download(w http.ResponseWriter, r *http.Request, params DownloadParams) {
	var request DownloadRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Download(ctx, request.(DownloadRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Download")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DownloadResponseObject); ok {
		if err := validResponse.VisitDownloadResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostDownload operation middleware
func (sh *strictHandler) PostDownload(w http.ResponseWriter, r *http.Request) {
	var request PostDownloadRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostDownloadFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostDownload(ctx, request.(PostDownloadRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostDownload")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostDownloadResponseObject); ok {
		if err := validResponse.VisitPostDownloadResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DownloadPodcastEpisode operation middleware
func (sh *strictHandler) DownloadPodcastEpisode(w http.ResponseWriter, r *http.Request, params DownloadPodcastEpisodeParams) {
	var request DownloadPodcastEpisodeRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DownloadPodcastEpisode(ctx, request.(DownloadPodcastEpisodeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DownloadPodcastEpisode")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DownloadPodcastEpisodeResponseObject); ok {
		if err := validResponse.VisitDownloadPodcastEpisodeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostDownloadPodcastEpisode operation middleware
func (sh *strictHandler) PostDownloadPodcastEpisode(w http.ResponseWriter, r *http.Request) {
	var request PostDownloadPodcastEpisodeRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostDownloadPodcastEpisodeFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostDownloadPodcastEpisode(ctx, request.(PostDownloadPodcastEpisodeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostDownloadPodcastEpisode")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostDownloadPodcastEpisodeResponseObject); ok {
		if err := validResponse.VisitPostDownloadPodcastEpisodeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAlbum operation middleware
func (sh *strictHandler) GetAlbum(w http.ResponseWriter, r *http.Request, params GetAlbumParams) {
	var request GetAlbumRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAlbum(ctx, request.(GetAlbumRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAlbum")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAlbumResponseObject); ok {
		if err := validResponse.VisitGetAlbumResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetAlbum operation middleware
func (sh *strictHandler) PostGetAlbum(w http.ResponseWriter, r *http.Request) {
	var request PostGetAlbumRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetAlbumFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetAlbum(ctx, request.(PostGetAlbumRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetAlbum")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetAlbumResponseObject); ok {
		if err := validResponse.VisitPostGetAlbumResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAlbumInfo operation middleware
func (sh *strictHandler) GetAlbumInfo(w http.ResponseWriter, r *http.Request, params GetAlbumInfoParams) {
	var request GetAlbumInfoRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAlbumInfo(ctx, request.(GetAlbumInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAlbumInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAlbumInfoResponseObject); ok {
		if err := validResponse.VisitGetAlbumInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetAlbumInfo operation middleware
func (sh *strictHandler) PostGetAlbumInfo(w http.ResponseWriter, r *http.Request) {
	var request PostGetAlbumInfoRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetAlbumInfoFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetAlbumInfo(ctx, request.(PostGetAlbumInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetAlbumInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetAlbumInfoResponseObject); ok {
		if err := validResponse.VisitPostGetAlbumInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAlbumInfo2 operation middleware
func (sh *strictHandler) GetAlbumInfo2(w http.ResponseWriter, r *http.Request, params GetAlbumInfo2Params) {
	var request GetAlbumInfo2RequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAlbumInfo2(ctx, request.(GetAlbumInfo2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAlbumInfo2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAlbumInfo2ResponseObject); ok {
		if err := validResponse.VisitGetAlbumInfo2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetAlbumInfo2 operation middleware
func (sh *strictHandler) PostGetAlbumInfo2(w http.ResponseWriter, r *http.Request) {
	var request PostGetAlbumInfo2RequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetAlbumInfo2FormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetAlbumInfo2(ctx, request.(PostGetAlbumInfo2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetAlbumInfo2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetAlbumInfo2ResponseObject); ok {
		if err := validResponse.VisitPostGetAlbumInfo2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAlbumList operation middleware
func (sh *strictHandler) GetAlbumList(w http.ResponseWriter, r *http.Request, params GetAlbumListParams) {
	var request GetAlbumListRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAlbumList(ctx, request.(GetAlbumListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAlbumList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAlbumListResponseObject); ok {
		if err := validResponse.VisitGetAlbumListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetAlbumList operation middleware
func (sh *strictHandler) PostGetAlbumList(w http.ResponseWriter, r *http.Request) {
	var request PostGetAlbumListRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetAlbumListFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetAlbumList(ctx, request.(PostGetAlbumListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetAlbumList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetAlbumListResponseObject); ok {
		if err := validResponse.VisitPostGetAlbumListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAlbumList2 operation middleware
func (sh *strictHandler) GetAlbumList2(w http.ResponseWriter, r *http.Request, params GetAlbumList2Params) {
	var request GetAlbumList2RequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAlbumList2(ctx, request.(GetAlbumList2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAlbumList2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAlbumList2ResponseObject); ok {
		if err := validResponse.VisitGetAlbumList2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetAlbumList2 operation middleware
func (sh *strictHandler) PostGetAlbumList2(w http.ResponseWriter, r *http.Request) {
	var request PostGetAlbumList2RequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetAlbumList2FormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetAlbumList2(ctx, request.(PostGetAlbumList2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetAlbumList2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetAlbumList2ResponseObject); ok {
		if err := validResponse.VisitPostGetAlbumList2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetArtist operation middleware
func (sh *strictHandler) GetArtist(w http.ResponseWriter, r *http.Request, params GetArtistParams) {
	var request GetArtistRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetArtist(ctx, request.(GetArtistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetArtist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetArtistResponseObject); ok {
		if err := validResponse.VisitGetArtistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetArtist operation middleware
func (sh *strictHandler) PostGetArtist(w http.ResponseWriter, r *http.Request) {
	var request PostGetArtistRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetArtistFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetArtist(ctx, request.(PostGetArtistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetArtist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetArtistResponseObject); ok {
		if err := validResponse.VisitPostGetArtistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetArtistInfo operation middleware
func (sh *strictHandler) GetArtistInfo(w http.ResponseWriter, r *http.Request, params GetArtistInfoParams) {
	var request GetArtistInfoRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetArtistInfo(ctx, request.(GetArtistInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetArtistInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetArtistInfoResponseObject); ok {
		if err := validResponse.VisitGetArtistInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetArtistInfo operation middleware
func (sh *strictHandler) PostGetArtistInfo(w http.ResponseWriter, r *http.Request) {
	var request PostGetArtistInfoRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetArtistInfoFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetArtistInfo(ctx, request.(PostGetArtistInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetArtistInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetArtistInfoResponseObject); ok {
		if err := validResponse.VisitPostGetArtistInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetArtistInfo2 operation middleware
func (sh *strictHandler) GetArtistInfo2(w http.ResponseWriter, r *http.Request, params GetArtistInfo2Params) {
	var request GetArtistInfo2RequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetArtistInfo2(ctx, request.(GetArtistInfo2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetArtistInfo2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetArtistInfo2ResponseObject); ok {
		if err := validResponse.VisitGetArtistInfo2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetArtistInfo2 operation middleware
func (sh *strictHandler) PostGetArtistInfo2(w http.ResponseWriter, r *http.Request) {
	var request PostGetArtistInfo2RequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetArtistInfo2FormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetArtistInfo2(ctx, request.(PostGetArtistInfo2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetArtistInfo2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetArtistInfo2ResponseObject); ok {
		if err := validResponse.VisitPostGetArtistInfo2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetArtists operation middleware
func (sh *strictHandler) GetArtists(w http.ResponseWriter, r *http.Request, params GetArtistsParams) {
	var request GetArtistsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetArtists(ctx, request.(GetArtistsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetArtists")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetArtistsResponseObject); ok {
		if err := validResponse.VisitGetArtistsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetArtists operation middleware
func (sh *strictHandler) PostGetArtists(w http.ResponseWriter, r *http.Request) {
	var request PostGetArtistsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetArtistsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetArtists(ctx, request.(PostGetArtistsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetArtists")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetArtistsResponseObject); ok {
		if err := validResponse.VisitPostGetArtistsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetAvatar operation middleware
func (sh *strictHandler) GetAvatar(w http.ResponseWriter, r *http.Request, params GetAvatarParams) {
	var request GetAvatarRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetAvatar(ctx, request.(GetAvatarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAvatar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetAvatarResponseObject); ok {
		if err := validResponse.VisitGetAvatarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetAvatar operation middleware
func (sh *strictHandler) PostGetAvatar(w http.ResponseWriter, r *http.Request) {
	var request PostGetAvatarRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetAvatarFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetAvatar(ctx, request.(PostGetAvatarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetAvatar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetAvatarResponseObject); ok {
		if err := validResponse.VisitPostGetAvatarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetBookmarks operation middleware
func (sh *strictHandler) GetBookmarks(w http.ResponseWriter, r *http.Request) {
	var request GetBookmarksRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetBookmarks(ctx, request.(GetBookmarksRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetBookmarks")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetBookmarksResponseObject); ok {
		if err := validResponse.VisitGetBookmarksResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetBookmarks operation middleware
func (sh *strictHandler) PostGetBookmarks(w http.ResponseWriter, r *http.Request) {
	var request PostGetBookmarksRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetBookmarksFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetBookmarks(ctx, request.(PostGetBookmarksRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetBookmarks")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetBookmarksResponseObject); ok {
		if err := validResponse.VisitPostGetBookmarksResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetCaptions operation middleware
func (sh *strictHandler) GetCaptions(w http.ResponseWriter, r *http.Request, params GetCaptionsParams) {
	var request GetCaptionsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetCaptions(ctx, request.(GetCaptionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCaptions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetCaptionsResponseObject); ok {
		if err := validResponse.VisitGetCaptionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetCaptions operation middleware
func (sh *strictHandler) PostGetCaptions(w http.ResponseWriter, r *http.Request) {
	var request PostGetCaptionsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetCaptionsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetCaptions(ctx, request.(PostGetCaptionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetCaptions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetCaptionsResponseObject); ok {
		if err := validResponse.VisitPostGetCaptionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetChatMessages operation middleware
func (sh *strictHandler) GetChatMessages(w http.ResponseWriter, r *http.Request) {
	var request GetChatMessagesRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetChatMessages(ctx, request.(GetChatMessagesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChatMessages")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetChatMessagesResponseObject); ok {
		if err := validResponse.VisitGetChatMessagesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetChatMessages operation middleware
func (sh *strictHandler) PostGetChatMessages(w http.ResponseWriter, r *http.Request) {
	var request PostGetChatMessagesRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetChatMessagesFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetChatMessages(ctx, request.(PostGetChatMessagesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetChatMessages")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetChatMessagesResponseObject); ok {
		if err := validResponse.VisitPostGetChatMessagesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetCoverArt operation middleware
func (sh *strictHandler) GetCoverArt(w http.ResponseWriter, r *http.Request, params GetCoverArtParams) {
	var request GetCoverArtRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetCoverArt(ctx, request.(GetCoverArtRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCoverArt")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetCoverArtResponseObject); ok {
		if err := validResponse.VisitGetCoverArtResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetCoverArt operation middleware
func (sh *strictHandler) PostGetCoverArt(w http.ResponseWriter, r *http.Request) {
	var request PostGetCoverArtRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetCoverArtFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetCoverArt(ctx, request.(PostGetCoverArtRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetCoverArt")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetCoverArtResponseObject); ok {
		if err := validResponse.VisitPostGetCoverArtResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetGenres operation middleware
func (sh *strictHandler) GetGenres(w http.ResponseWriter, r *http.Request) {
	var request GetGenresRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetGenres(ctx, request.(GetGenresRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetGenres")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetGenresResponseObject); ok {
		if err := validResponse.VisitGetGenresResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetGenres operation middleware
func (sh *strictHandler) PostGetGenres(w http.ResponseWriter, r *http.Request) {
	var request PostGetGenresRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetGenresFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetGenres(ctx, request.(PostGetGenresRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetGenres")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetGenresResponseObject); ok {
		if err := validResponse.VisitPostGetGenresResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetIndexes operation middleware
func (sh *strictHandler) GetIndexes(w http.ResponseWriter, r *http.Request, params GetIndexesParams) {
	var request GetIndexesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetIndexes(ctx, request.(GetIndexesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetIndexes")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetIndexesResponseObject); ok {
		if err := validResponse.VisitGetIndexesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetIndexes operation middleware
func (sh *strictHandler) PostGetIndexes(w http.ResponseWriter, r *http.Request) {
	var request PostGetIndexesRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetIndexesFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetIndexes(ctx, request.(PostGetIndexesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetIndexes")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetIndexesResponseObject); ok {
		if err := validResponse.VisitPostGetIndexesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetInternetRadioStations operation middleware
func (sh *strictHandler) GetInternetRadioStations(w http.ResponseWriter, r *http.Request) {
	var request GetInternetRadioStationsRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetInternetRadioStations(ctx, request.(GetInternetRadioStationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetInternetRadioStations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetInternetRadioStationsResponseObject); ok {
		if err := validResponse.VisitGetInternetRadioStationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetInternetRadioStations operation middleware
func (sh *strictHandler) PostGetInternetRadioStations(w http.ResponseWriter, r *http.Request) {
	var request PostGetInternetRadioStationsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetInternetRadioStationsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetInternetRadioStations(ctx, request.(PostGetInternetRadioStationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetInternetRadioStations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetInternetRadioStationsResponseObject); ok {
		if err := validResponse.VisitPostGetInternetRadioStationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetLicense operation middleware
func (sh *strictHandler) GetLicense(w http.ResponseWriter, r *http.Request) {
	var request GetLicenseRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetLicense(ctx, request.(GetLicenseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetLicense")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetLicenseResponseObject); ok {
		if err := validResponse.VisitGetLicenseResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetLicense operation middleware
func (sh *strictHandler) PostGetLicense(w http.ResponseWriter, r *http.Request) {
	var request PostGetLicenseRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetLicenseFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetLicense(ctx, request.(PostGetLicenseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetLicense")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetLicenseResponseObject); ok {
		if err := validResponse.VisitPostGetLicenseResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetLyrics operation middleware
func (sh *strictHandler) GetLyrics(w http.ResponseWriter, r *http.Request, params GetLyricsParams) {
	var request GetLyricsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetLyrics(ctx, request.(GetLyricsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetLyrics")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetLyricsResponseObject); ok {
		if err := validResponse.VisitGetLyricsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetLyrics operation middleware
func (sh *strictHandler) PostGetLyrics(w http.ResponseWriter, r *http.Request) {
	var request PostGetLyricsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetLyricsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetLyrics(ctx, request.(PostGetLyricsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetLyrics")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetLyricsResponseObject); ok {
		if err := validResponse.VisitPostGetLyricsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetLyricsBySongId operation middleware
func (sh *strictHandler) GetLyricsBySongId(w http.ResponseWriter, r *http.Request, params GetLyricsBySongIdParams) {
	var request GetLyricsBySongIdRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetLyricsBySongId(ctx, request.(GetLyricsBySongIdRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetLyricsBySongId")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetLyricsBySongIdResponseObject); ok {
		if err := validResponse.VisitGetLyricsBySongIdResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetLyricsBySongId operation middleware
func (sh *strictHandler) PostGetLyricsBySongId(w http.ResponseWriter, r *http.Request) {
	var request PostGetLyricsBySongIdRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetLyricsBySongIdFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetLyricsBySongId(ctx, request.(PostGetLyricsBySongIdRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetLyricsBySongId")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetLyricsBySongIdResponseObject); ok {
		if err := validResponse.VisitPostGetLyricsBySongIdResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetMusicDirectory operation middleware
func (sh *strictHandler) GetMusicDirectory(w http.ResponseWriter, r *http.Request, params GetMusicDirectoryParams) {
	var request GetMusicDirectoryRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetMusicDirectory(ctx, request.(GetMusicDirectoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetMusicDirectory")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetMusicDirectoryResponseObject); ok {
		if err := validResponse.VisitGetMusicDirectoryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetMusicDirectory operation middleware
func (sh *strictHandler) PostGetMusicDirectory(w http.ResponseWriter, r *http.Request) {
	var request PostGetMusicDirectoryRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetMusicDirectoryFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetMusicDirectory(ctx, request.(PostGetMusicDirectoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetMusicDirectory")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetMusicDirectoryResponseObject); ok {
		if err := validResponse.VisitPostGetMusicDirectoryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetMusicFolders operation middleware
func (sh *strictHandler) GetMusicFolders(w http.ResponseWriter, r *http.Request) {
	var request GetMusicFoldersRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetMusicFolders(ctx, request.(GetMusicFoldersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetMusicFolders")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetMusicFoldersResponseObject); ok {
		if err := validResponse.VisitGetMusicFoldersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetMusicFolders operation middleware
func (sh *strictHandler) PostGetMusicFolders(w http.ResponseWriter, r *http.Request) {
	var request PostGetMusicFoldersRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetMusicFoldersFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetMusicFolders(ctx, request.(PostGetMusicFoldersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetMusicFolders")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetMusicFoldersResponseObject); ok {
		if err := validResponse.VisitPostGetMusicFoldersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetNewestPodcasts operation middleware
func (sh *strictHandler) GetNewestPodcasts(w http.ResponseWriter, r *http.Request, params GetNewestPodcastsParams) {
	var request GetNewestPodcastsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetNewestPodcasts(ctx, request.(GetNewestPodcastsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetNewestPodcasts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetNewestPodcastsResponseObject); ok {
		if err := validResponse.VisitGetNewestPodcastsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetNewestPodcasts operation middleware
func (sh *strictHandler) PostGetNewestPodcasts(w http.ResponseWriter, r *http.Request) {
	var request PostGetNewestPodcastsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetNewestPodcastsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetNewestPodcasts(ctx, request.(PostGetNewestPodcastsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetNewestPodcasts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetNewestPodcastsResponseObject); ok {
		if err := validResponse.VisitPostGetNewestPodcastsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetNowPlaying operation middleware
func (sh *strictHandler) GetNowPlaying(w http.ResponseWriter, r *http.Request) {
	var request GetNowPlayingRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetNowPlaying(ctx, request.(GetNowPlayingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetNowPlaying")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetNowPlayingResponseObject); ok {
		if err := validResponse.VisitGetNowPlayingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetNowPlaying operation middleware
func (sh *strictHandler) PostGetNowPlaying(w http.ResponseWriter, r *http.Request) {
	var request PostGetNowPlayingRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetNowPlayingFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetNowPlaying(ctx, request.(PostGetNowPlayingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetNowPlaying")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetNowPlayingResponseObject); ok {
		if err := validResponse.VisitPostGetNowPlayingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOpenSubsonicExtensions operation middleware
func (sh *strictHandler) GetOpenSubsonicExtensions(w http.ResponseWriter, r *http.Request) {
	var request GetOpenSubsonicExtensionsRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetOpenSubsonicExtensions(ctx, request.(GetOpenSubsonicExtensionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOpenSubsonicExtensions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetOpenSubsonicExtensionsResponseObject); ok {
		if err := validResponse.VisitGetOpenSubsonicExtensionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetOpenSubsonicExtensions operation middleware
func (sh *strictHandler) PostGetOpenSubsonicExtensions(w http.ResponseWriter, r *http.Request) {
	var request PostGetOpenSubsonicExtensionsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetOpenSubsonicExtensionsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetOpenSubsonicExtensions(ctx, request.(PostGetOpenSubsonicExtensionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetOpenSubsonicExtensions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetOpenSubsonicExtensionsResponseObject); ok {
		if err := validResponse.VisitPostGetOpenSubsonicExtensionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPlayQueue operation middleware
func (sh *strictHandler) GetPlayQueue(w http.ResponseWriter, r *http.Request) {
	var request GetPlayQueueRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPlayQueue(ctx, request.(GetPlayQueueRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPlayQueue")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPlayQueueResponseObject); ok {
		if err := validResponse.VisitGetPlayQueueResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetPlayQueue operation middleware
func (sh *strictHandler) PostGetPlayQueue(w http.ResponseWriter, r *http.Request) {
	var request PostGetPlayQueueRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetPlayQueueFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetPlayQueue(ctx, request.(PostGetPlayQueueRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetPlayQueue")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetPlayQueueResponseObject); ok {
		if err := validResponse.VisitPostGetPlayQueueResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPlayQueueByIndex operation middleware
func (sh *strictHandler) GetPlayQueueByIndex(w http.ResponseWriter, r *http.Request) {
	var request GetPlayQueueByIndexRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPlayQueueByIndex(ctx, request.(GetPlayQueueByIndexRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPlayQueueByIndex")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPlayQueueByIndexResponseObject); ok {
		if err := validResponse.VisitGetPlayQueueByIndexResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetPlayQueueByIndex operation middleware
func (sh *strictHandler) PostGetPlayQueueByIndex(w http.ResponseWriter, r *http.Request) {
	var request PostGetPlayQueueByIndexRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetPlayQueueByIndexFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetPlayQueueByIndex(ctx, request.(PostGetPlayQueueByIndexRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetPlayQueueByIndex")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetPlayQueueByIndexResponseObject); ok {
		if err := validResponse.VisitPostGetPlayQueueByIndexResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPlaylist operation middleware
func (sh *strictHandler) GetPlaylist(w http.ResponseWriter, r *http.Request, params GetPlaylistParams) {
	var request GetPlaylistRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPlaylist(ctx, request.(GetPlaylistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPlaylist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPlaylistResponseObject); ok {
		if err := validResponse.VisitGetPlaylistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetPlaylist operation middleware
func (sh *strictHandler) PostGetPlaylist(w http.ResponseWriter, r *http.Request) {
	var request PostGetPlaylistRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetPlaylistFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetPlaylist(ctx, request.(PostGetPlaylistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetPlaylist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetPlaylistResponseObject); ok {
		if err := validResponse.VisitPostGetPlaylistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPlaylists operation middleware
func (sh *strictHandler) GetPlaylists(w http.ResponseWriter, r *http.Request, params GetPlaylistsParams) {
	var request GetPlaylistsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPlaylists(ctx, request.(GetPlaylistsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPlaylists")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPlaylistsResponseObject); ok {
		if err := validResponse.VisitGetPlaylistsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetPlaylists operation middleware
func (sh *strictHandler) PostGetPlaylists(w http.ResponseWriter, r *http.Request) {
	var request PostGetPlaylistsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetPlaylistsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetPlaylists(ctx, request.(PostGetPlaylistsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetPlaylists")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetPlaylistsResponseObject); ok {
		if err := validResponse.VisitPostGetPlaylistsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPodcastEpisode operation middleware
func (sh *strictHandler) GetPodcastEpisode(w http.ResponseWriter, r *http.Request, params GetPodcastEpisodeParams) {
	var request GetPodcastEpisodeRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPodcastEpisode(ctx, request.(GetPodcastEpisodeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPodcastEpisode")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPodcastEpisodeResponseObject); ok {
		if err := validResponse.VisitGetPodcastEpisodeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetPodcastEpisode operation middleware
func (sh *strictHandler) PostGetPodcastEpisode(w http.ResponseWriter, r *http.Request) {
	var request PostGetPodcastEpisodeRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetPodcastEpisodeFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetPodcastEpisode(ctx, request.(PostGetPodcastEpisodeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetPodcastEpisode")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetPodcastEpisodeResponseObject); ok {
		if err := validResponse.VisitPostGetPodcastEpisodeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPodcasts operation middleware
func (sh *strictHandler) GetPodcasts(w http.ResponseWriter, r *http.Request, params GetPodcastsParams) {
	var request GetPodcastsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPodcasts(ctx, request.(GetPodcastsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPodcasts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPodcastsResponseObject); ok {
		if err := validResponse.VisitGetPodcastsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetPodcasts operation middleware
func (sh *strictHandler) PostGetPodcasts(w http.ResponseWriter, r *http.Request) {
	var request PostGetPodcastsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetPodcastsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetPodcasts(ctx, request.(PostGetPodcastsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetPodcasts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetPodcastsResponseObject); ok {
		if err := validResponse.VisitPostGetPodcastsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetRandomSongs operation middleware
func (sh *strictHandler) GetRandomSongs(w http.ResponseWriter, r *http.Request, params GetRandomSongsParams) {
	var request GetRandomSongsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetRandomSongs(ctx, request.(GetRandomSongsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetRandomSongs")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetRandomSongsResponseObject); ok {
		if err := validResponse.VisitGetRandomSongsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetRandomSongs operation middleware
func (sh *strictHandler) PostGetRandomSongs(w http.ResponseWriter, r *http.Request) {
	var request PostGetRandomSongsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetRandomSongsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetRandomSongs(ctx, request.(PostGetRandomSongsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetRandomSongs")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetRandomSongsResponseObject); ok {
		if err := validResponse.VisitPostGetRandomSongsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetScanStatus operation middleware
func (sh *strictHandler) GetScanStatus(w http.ResponseWriter, r *http.Request) {
	var request GetScanStatusRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetScanStatus(ctx, request.(GetScanStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetScanStatus")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetScanStatusResponseObject); ok {
		if err := validResponse.VisitGetScanStatusResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetScanStatus operation middleware
func (sh *strictHandler) PostGetScanStatus(w http.ResponseWriter, r *http.Request) {
	var request PostGetScanStatusRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetScanStatusFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetScanStatus(ctx, request.(PostGetScanStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetScanStatus")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetScanStatusResponseObject); ok {
		if err := validResponse.VisitPostGetScanStatusResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetShares operation middleware
func (sh *strictHandler) GetShares(w http.ResponseWriter, r *http.Request) {
	var request GetSharesRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetShares(ctx, request.(GetSharesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetShares")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSharesResponseObject); ok {
		if err := validResponse.VisitGetSharesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetShares operation middleware
func (sh *strictHandler) PostGetShares(w http.ResponseWriter, r *http.Request) {
	var request PostGetSharesRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetSharesFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetShares(ctx, request.(PostGetSharesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetShares")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetSharesResponseObject); ok {
		if err := validResponse.VisitPostGetSharesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSimilarSongs operation middleware
func (sh *strictHandler) GetSimilarSongs(w http.ResponseWriter, r *http.Request, params GetSimilarSongsParams) {
	var request GetSimilarSongsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSimilarSongs(ctx, request.(GetSimilarSongsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSimilarSongs")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSimilarSongsResponseObject); ok {
		if err := validResponse.VisitGetSimilarSongsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetSimilarSongs operation middleware
func (sh *strictHandler) PostGetSimilarSongs(w http.ResponseWriter, r *http.Request) {
	var request PostGetSimilarSongsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetSimilarSongsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetSimilarSongs(ctx, request.(PostGetSimilarSongsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetSimilarSongs")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetSimilarSongsResponseObject); ok {
		if err := validResponse.VisitPostGetSimilarSongsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSimilarSongs2 operation middleware
func (sh *strictHandler) GetSimilarSongs2(w http.ResponseWriter, r *http.Request, params GetSimilarSongs2Params) {
	var request GetSimilarSongs2RequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSimilarSongs2(ctx, request.(GetSimilarSongs2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSimilarSongs2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSimilarSongs2ResponseObject); ok {
		if err := validResponse.VisitGetSimilarSongs2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetSimilarSongs2 operation middleware
func (sh *strictHandler) PostGetSimilarSongs2(w http.ResponseWriter, r *http.Request) {
	var request PostGetSimilarSongs2RequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetSimilarSongs2FormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetSimilarSongs2(ctx, request.(PostGetSimilarSongs2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetSimilarSongs2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetSimilarSongs2ResponseObject); ok {
		if err := validResponse.VisitPostGetSimilarSongs2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSong operation middleware
func (sh *strictHandler) GetSong(w http.ResponseWriter, r *http.Request, params GetSongParams) {
	var request GetSongRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSong(ctx, request.(GetSongRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSong")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSongResponseObject); ok {
		if err := validResponse.VisitGetSongResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetSong operation middleware
func (sh *strictHandler) PostGetSong(w http.ResponseWriter, r *http.Request) {
	var request PostGetSongRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetSongFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetSong(ctx, request.(PostGetSongRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetSong")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetSongResponseObject); ok {
		if err := validResponse.VisitPostGetSongResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSongsByGenre operation middleware
func (sh *strictHandler) GetSongsByGenre(w http.ResponseWriter, r *http.Request, params GetSongsByGenreParams) {
	var request GetSongsByGenreRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSongsByGenre(ctx, request.(GetSongsByGenreRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSongsByGenre")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSongsByGenreResponseObject); ok {
		if err := validResponse.VisitGetSongsByGenreResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetSongsByGenre operation middleware
func (sh *strictHandler) PostGetSongsByGenre(w http.ResponseWriter, r *http.Request) {
	var request PostGetSongsByGenreRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetSongsByGenreFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetSongsByGenre(ctx, request.(PostGetSongsByGenreRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetSongsByGenre")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetSongsByGenreResponseObject); ok {
		if err := validResponse.VisitPostGetSongsByGenreResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetStarred operation middleware
func (sh *strictHandler) GetStarred(w http.ResponseWriter, r *http.Request, params GetStarredParams) {
	var request GetStarredRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetStarred(ctx, request.(GetStarredRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetStarred")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetStarredResponseObject); ok {
		if err := validResponse.VisitGetStarredResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetStarred operation middleware
func (sh *strictHandler) PostGetStarred(w http.ResponseWriter, r *http.Request) {
	var request PostGetStarredRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetStarredFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetStarred(ctx, request.(PostGetStarredRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetStarred")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetStarredResponseObject); ok {
		if err := validResponse.VisitPostGetStarredResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetStarred2 operation middleware
func (sh *strictHandler) GetStarred2(w http.ResponseWriter, r *http.Request, params GetStarred2Params) {
	var request GetStarred2RequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetStarred2(ctx, request.(GetStarred2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetStarred2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetStarred2ResponseObject); ok {
		if err := validResponse.VisitGetStarred2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetStarred2 operation middleware
func (sh *strictHandler) PostGetStarred2(w http.ResponseWriter, r *http.Request) {
	var request PostGetStarred2RequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetStarred2FormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetStarred2(ctx, request.(PostGetStarred2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetStarred2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetStarred2ResponseObject); ok {
		if err := validResponse.VisitPostGetStarred2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTopSongs operation middleware
func (sh *strictHandler) GetTopSongs(w http.ResponseWriter, r *http.Request, params GetTopSongsParams) {
	var request GetTopSongsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetTopSongs(ctx, request.(GetTopSongsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTopSongs")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTopSongsResponseObject); ok {
		if err := validResponse.VisitGetTopSongsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetTopSongs operation middleware
func (sh *strictHandler) PostGetTopSongs(w http.ResponseWriter, r *http.Request) {
	var request PostGetTopSongsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetTopSongsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetTopSongs(ctx, request.(PostGetTopSongsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetTopSongs")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetTopSongsResponseObject); ok {
		if err := validResponse.VisitPostGetTopSongsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTranscodeDecision operation middleware
func (sh *strictHandler) GetTranscodeDecision(w http.ResponseWriter, r *http.Request, params GetTranscodeDecisionParams) {
	var request GetTranscodeDecisionRequestObject

	request.Params = params

	var body GetTranscodeDecisionJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetTranscodeDecision(ctx, request.(GetTranscodeDecisionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTranscodeDecision")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTranscodeDecisionResponseObject); ok {
		if err := validResponse.VisitGetTranscodeDecisionResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetTranscodeStream operation middleware
func (sh *strictHandler) GetTranscodeStream(w http.ResponseWriter, r *http.Request, params GetTranscodeStreamParams) {
	var request GetTranscodeStreamRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetTranscodeStream(ctx, request.(GetTranscodeStreamRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTranscodeStream")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetTranscodeStreamResponseObject); ok {
		if err := validResponse.VisitGetTranscodeStreamResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetUser operation middleware
func (sh *strictHandler) GetUser(w http.ResponseWriter, r *http.Request, params GetUserParams) {
	var request GetUserRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetUser(ctx, request.(GetUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetUserResponseObject); ok {
		if err := validResponse.VisitGetUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetUser operation middleware
func (sh *strictHandler) PostGetUser(w http.ResponseWriter, r *http.Request) {
	var request PostGetUserRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetUserFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetUser(ctx, request.(PostGetUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetUserResponseObject); ok {
		if err := validResponse.VisitPostGetUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetUsers operation middleware
func (sh *strictHandler) GetUsers(w http.ResponseWriter, r *http.Request) {
	var request GetUsersRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetUsers(ctx, request.(GetUsersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUsers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetUsersResponseObject); ok {
		if err := validResponse.VisitGetUsersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetUsers operation middleware
func (sh *strictHandler) PostGetUsers(w http.ResponseWriter, r *http.Request) {
	var request PostGetUsersRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetUsersFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetUsers(ctx, request.(PostGetUsersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetUsers")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetUsersResponseObject); ok {
		if err := validResponse.VisitPostGetUsersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetVideoInfo operation middleware
func (sh *strictHandler) GetVideoInfo(w http.ResponseWriter, r *http.Request, params GetVideoInfoParams) {
	var request GetVideoInfoRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetVideoInfo(ctx, request.(GetVideoInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVideoInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetVideoInfoResponseObject); ok {
		if err := validResponse.VisitGetVideoInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetVideoInfo operation middleware
func (sh *strictHandler) PostGetVideoInfo(w http.ResponseWriter, r *http.Request) {
	var request PostGetVideoInfoRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetVideoInfoFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetVideoInfo(ctx, request.(PostGetVideoInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetVideoInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetVideoInfoResponseObject); ok {
		if err := validResponse.VisitPostGetVideoInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetVideos operation middleware
func (sh *strictHandler) GetVideos(w http.ResponseWriter, r *http.Request) {
	var request GetVideosRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetVideos(ctx, request.(GetVideosRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVideos")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetVideosResponseObject); ok {
		if err := validResponse.VisitGetVideosResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostGetVideos operation middleware
func (sh *strictHandler) PostGetVideos(w http.ResponseWriter, r *http.Request) {
	var request PostGetVideosRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostGetVideosFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostGetVideos(ctx, request.(PostGetVideosRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostGetVideos")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostGetVideosResponseObject); ok {
		if err := validResponse.VisitPostGetVideosResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// HlsM3u8 operation middleware
func (sh *strictHandler) HlsM3u8(w http.ResponseWriter, r *http.Request, params HlsM3u8Params) {
	var request HlsM3u8RequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.HlsM3u8(ctx, request.(HlsM3u8RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "HlsM3u8")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(HlsM3u8ResponseObject); ok {
		if err := validResponse.VisitHlsM3u8Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostHlsM3u8 operation middleware
func (sh *strictHandler) PostHlsM3u8(w http.ResponseWriter, r *http.Request) {
	var request PostHlsM3u8RequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostHlsM3u8FormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostHlsM3u8(ctx, request.(PostHlsM3u8RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostHlsM3u8")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostHlsM3u8ResponseObject); ok {
		if err := validResponse.VisitPostHlsM3u8Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// JukeboxControl operation middleware
func (sh *strictHandler) JukeboxControl(w http.ResponseWriter, r *http.Request, params JukeboxControlParams) {
	var request JukeboxControlRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.JukeboxControl(ctx, request.(JukeboxControlRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "JukeboxControl")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(JukeboxControlResponseObject); ok {
		if err := validResponse.VisitJukeboxControlResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostJukeboxControl operation middleware
func (sh *strictHandler) PostJukeboxControl(w http.ResponseWriter, r *http.Request) {
	var request PostJukeboxControlRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostJukeboxControlFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostJukeboxControl(ctx, request.(PostJukeboxControlRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostJukeboxControl")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostJukeboxControlResponseObject); ok {
		if err := validResponse.VisitPostJukeboxControlResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Ping operation middleware
func (sh *strictHandler) Ping(w http.ResponseWriter, r *http.Request) {
	var request PingRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Ping(ctx, request.(PingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Ping")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PingResponseObject); ok {
		if err := validResponse.VisitPingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostPing operation middleware
func (sh *strictHandler) PostPing(w http.ResponseWriter, r *http.Request) {
	var request PostPingRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostPingFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostPing(ctx, request.(PostPingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostPing")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostPingResponseObject); ok {
		if err := validResponse.VisitPostPingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RefreshPodcasts operation middleware
func (sh *strictHandler) RefreshPodcasts(w http.ResponseWriter, r *http.Request) {
	var request RefreshPodcastsRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RefreshPodcasts(ctx, request.(RefreshPodcastsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RefreshPodcasts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RefreshPodcastsResponseObject); ok {
		if err := validResponse.VisitRefreshPodcastsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostRefreshPodcasts operation middleware
func (sh *strictHandler) PostRefreshPodcasts(w http.ResponseWriter, r *http.Request) {
	var request PostRefreshPodcastsRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostRefreshPodcastsFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostRefreshPodcasts(ctx, request.(PostRefreshPodcastsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostRefreshPodcasts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostRefreshPodcastsResponseObject); ok {
		if err := validResponse.VisitPostRefreshPodcastsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// SavePlayQueue operation middleware
func (sh *strictHandler) SavePlayQueue(w http.ResponseWriter, r *http.Request, params SavePlayQueueParams) {
	var request SavePlayQueueRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.SavePlayQueue(ctx, request.(SavePlayQueueRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SavePlayQueue")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(SavePlayQueueResponseObject); ok {
		if err := validResponse.VisitSavePlayQueueResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostSavePlayQueue operation middleware
func (sh *strictHandler) PostSavePlayQueue(w http.ResponseWriter, r *http.Request) {
	var request PostSavePlayQueueRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostSavePlayQueueFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostSavePlayQueue(ctx, request.(PostSavePlayQueueRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostSavePlayQueue")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostSavePlayQueueResponseObject); ok {
		if err := validResponse.VisitPostSavePlayQueueResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// SavePlayQueueByIndex operation middleware
func (sh *strictHandler) SavePlayQueueByIndex(w http.ResponseWriter, r *http.Request, params SavePlayQueueByIndexParams) {
	var request SavePlayQueueByIndexRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.SavePlayQueueByIndex(ctx, request.(SavePlayQueueByIndexRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SavePlayQueueByIndex")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(SavePlayQueueByIndexResponseObject); ok {
		if err := validResponse.VisitSavePlayQueueByIndexResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostSavePlayQueueByIndex operation middleware
func (sh *strictHandler) PostSavePlayQueueByIndex(w http.ResponseWriter, r *http.Request) {
	var request PostSavePlayQueueByIndexRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostSavePlayQueueByIndexFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostSavePlayQueueByIndex(ctx, request.(PostSavePlayQueueByIndexRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostSavePlayQueueByIndex")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostSavePlayQueueByIndexResponseObject); ok {
		if err := validResponse.VisitPostSavePlayQueueByIndexResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Scrobble operation middleware
func (sh *strictHandler) Scrobble(w http.ResponseWriter, r *http.Request, params ScrobbleParams) {
	var request ScrobbleRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Scrobble(ctx, request.(ScrobbleRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Scrobble")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ScrobbleResponseObject); ok {
		if err := validResponse.VisitScrobbleResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostScrobble operation middleware
func (sh *strictHandler) PostScrobble(w http.ResponseWriter, r *http.Request) {
	var request PostScrobbleRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostScrobbleFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostScrobble(ctx, request.(PostScrobbleRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostScrobble")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostScrobbleResponseObject); ok {
		if err := validResponse.VisitPostScrobbleResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Search operation middleware
func (sh *strictHandler) Search(w http.ResponseWriter, r *http.Request, params SearchParams) {
	var request SearchRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Search(ctx, request.(SearchRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Search")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(SearchResponseObject); ok {
		if err := validResponse.VisitSearchResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostSearch operation middleware
func (sh *strictHandler) PostSearch(w http.ResponseWriter, r *http.Request) {
	var request PostSearchRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostSearchFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostSearch(ctx, request.(PostSearchRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostSearch")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostSearchResponseObject); ok {
		if err := validResponse.VisitPostSearchResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Search2 operation middleware
func (sh *strictHandler) Search2(w http.ResponseWriter, r *http.Request, params Search2Params) {
	var request Search2RequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Search2(ctx, request.(Search2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Search2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(Search2ResponseObject); ok {
		if err := validResponse.VisitSearch2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostSearch2 operation middleware
func (sh *strictHandler) PostSearch2(w http.ResponseWriter, r *http.Request) {
	var request PostSearch2RequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostSearch2FormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostSearch2(ctx, request.(PostSearch2RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostSearch2")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostSearch2ResponseObject); ok {
		if err := validResponse.VisitPostSearch2Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Search3 operation middleware
func (sh *strictHandler) Search3(w http.ResponseWriter, r *http.Request, params Search3Params) {
	var request Search3RequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Search3(ctx, request.(Search3RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Search3")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(Search3ResponseObject); ok {
		if err := validResponse.VisitSearch3Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostSearch3 operation middleware
func (sh *strictHandler) PostSearch3(w http.ResponseWriter, r *http.Request) {
	var request PostSearch3RequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostSearch3FormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostSearch3(ctx, request.(PostSearch3RequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostSearch3")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostSearch3ResponseObject); ok {
		if err := validResponse.VisitPostSearch3Response(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// SetRating operation middleware
func (sh *strictHandler) SetRating(w http.ResponseWriter, r *http.Request, params SetRatingParams) {
	var request SetRatingRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.SetRating(ctx, request.(SetRatingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SetRating")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(SetRatingResponseObject); ok {
		if err := validResponse.VisitSetRatingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostSetRating operation middleware
func (sh *strictHandler) PostSetRating(w http.ResponseWriter, r *http.Request) {
	var request PostSetRatingRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostSetRatingFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostSetRating(ctx, request.(PostSetRatingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostSetRating")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostSetRatingResponseObject); ok {
		if err := validResponse.VisitPostSetRatingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Star operation middleware
func (sh *strictHandler) Star(w http.ResponseWriter, r *http.Request, params StarParams) {
	var request StarRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Star(ctx, request.(StarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Star")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StarResponseObject); ok {
		if err := validResponse.VisitStarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostStar operation middleware
func (sh *strictHandler) PostStar(w http.ResponseWriter, r *http.Request) {
	var request PostStarRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostStarFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostStar(ctx, request.(PostStarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostStar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostStarResponseObject); ok {
		if err := validResponse.VisitPostStarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StartScan operation middleware
func (sh *strictHandler) StartScan(w http.ResponseWriter, r *http.Request) {
	var request StartScanRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StartScan(ctx, request.(StartScanRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StartScan")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StartScanResponseObject); ok {
		if err := validResponse.VisitStartScanResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostStartScan operation middleware
func (sh *strictHandler) PostStartScan(w http.ResponseWriter, r *http.Request) {
	var request PostStartScanRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostStartScanFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostStartScan(ctx, request.(PostStartScanRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostStartScan")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostStartScanResponseObject); ok {
		if err := validResponse.VisitPostStartScanResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Stream operation middleware
func (sh *strictHandler) Stream(w http.ResponseWriter, r *http.Request, params StreamParams) {
	var request StreamRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Stream(ctx, request.(StreamRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Stream")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StreamResponseObject); ok {
		if err := validResponse.VisitStreamResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostStream operation middleware
func (sh *strictHandler) PostStream(w http.ResponseWriter, r *http.Request) {
	var request PostStreamRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostStreamFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostStream(ctx, request.(PostStreamRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostStream")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostStreamResponseObject); ok {
		if err := validResponse.VisitPostStreamResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// TokenInfo operation middleware
func (sh *strictHandler) TokenInfo(w http.ResponseWriter, r *http.Request) {
	var request TokenInfoRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.TokenInfo(ctx, request.(TokenInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "TokenInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(TokenInfoResponseObject); ok {
		if err := validResponse.VisitTokenInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostTokenInfo operation middleware
func (sh *strictHandler) PostTokenInfo(w http.ResponseWriter, r *http.Request) {
	var request PostTokenInfoRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostTokenInfoFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostTokenInfo(ctx, request.(PostTokenInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostTokenInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostTokenInfoResponseObject); ok {
		if err := validResponse.VisitPostTokenInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Unstar operation middleware
func (sh *strictHandler) Unstar(w http.ResponseWriter, r *http.Request, params UnstarParams) {
	var request UnstarRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Unstar(ctx, request.(UnstarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Unstar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UnstarResponseObject); ok {
		if err := validResponse.VisitUnstarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostUnstar operation middleware
func (sh *strictHandler) PostUnstar(w http.ResponseWriter, r *http.Request) {
	var request PostUnstarRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostUnstarFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostUnstar(ctx, request.(PostUnstarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostUnstar")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostUnstarResponseObject); ok {
		if err := validResponse.VisitPostUnstarResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateInternetRadioStation operation middleware
func (sh *strictHandler) UpdateInternetRadioStation(w http.ResponseWriter, r *http.Request, params UpdateInternetRadioStationParams) {
	var request UpdateInternetRadioStationRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateInternetRadioStation(ctx, request.(UpdateInternetRadioStationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateInternetRadioStation")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateInternetRadioStationResponseObject); ok {
		if err := validResponse.VisitUpdateInternetRadioStationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostUpdateInternetRadioStation operation middleware
func (sh *strictHandler) PostUpdateInternetRadioStation(w http.ResponseWriter, r *http.Request) {
	var request PostUpdateInternetRadioStationRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostUpdateInternetRadioStationFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostUpdateInternetRadioStation(ctx, request.(PostUpdateInternetRadioStationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostUpdateInternetRadioStation")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostUpdateInternetRadioStationResponseObject); ok {
		if err := validResponse.VisitPostUpdateInternetRadioStationResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdatePlaylist operation middleware
func (sh *strictHandler) UpdatePlaylist(w http.ResponseWriter, r *http.Request, params UpdatePlaylistParams) {
	var request UpdatePlaylistRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdatePlaylist(ctx, request.(UpdatePlaylistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdatePlaylist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdatePlaylistResponseObject); ok {
		if err := validResponse.VisitUpdatePlaylistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostUpdatePlaylist operation middleware
func (sh *strictHandler) PostUpdatePlaylist(w http.ResponseWriter, r *http.Request) {
	var request PostUpdatePlaylistRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostUpdatePlaylistFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostUpdatePlaylist(ctx, request.(PostUpdatePlaylistRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostUpdatePlaylist")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostUpdatePlaylistResponseObject); ok {
		if err := validResponse.VisitPostUpdatePlaylistResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateShare operation middleware
func (sh *strictHandler) UpdateShare(w http.ResponseWriter, r *http.Request, params UpdateShareParams) {
	var request UpdateShareRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateShare(ctx, request.(UpdateShareRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateShare")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateShareResponseObject); ok {
		if err := validResponse.VisitUpdateShareResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostUpdateShare operation middleware
func (sh *strictHandler) PostUpdateShare(w http.ResponseWriter, r *http.Request) {
	var request PostUpdateShareRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostUpdateShareFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostUpdateShare(ctx, request.(PostUpdateShareRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostUpdateShare")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostUpdateShareResponseObject); ok {
		if err := validResponse.VisitPostUpdateShareResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateUser operation middleware
func (sh *strictHandler) UpdateUser(w http.ResponseWriter, r *http.Request, params UpdateUserParams) {
	var request UpdateUserRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateUser(ctx, request.(UpdateUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdateUserResponseObject); ok {
		if err := validResponse.VisitUpdateUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostUpdateUser operation middleware
func (sh *strictHandler) PostUpdateUser(w http.ResponseWriter, r *http.Request) {
	var request PostUpdateUserRequestObject

	if err := r.ParseForm(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode formdata: %w", err))
		return
	}
	var body PostUpdateUserFormdataRequestBody
	if err := runtime.BindForm(&body, r.Form, nil, nil); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't bind formdata: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostUpdateUser(ctx, request.(PostUpdateUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostUpdateUser")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostUpdateUserResponseObject); ok {
		if err := validResponse.VisitPostUpdateUserResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}
